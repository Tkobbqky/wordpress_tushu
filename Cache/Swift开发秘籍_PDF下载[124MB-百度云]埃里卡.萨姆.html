Swift开发秘籍 PDF下载 埃里卡.萨姆 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730244375
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730244375
<p>书名:Swift开发秘籍</p><p>作者:埃里卡.萨姆</p><p>页数:217</p><p>定价:¥49.8</p><p>出版社:清华大学出版社</p><p>出版日期:2016-08-01</p><p>ISBN:9787302443759</p><p><h2>本书特色</h2></p>[<p>
在本书中，著名编程图书作者erica sadun介绍了有效的策略和即时可用的swift代码来应对日常开发所面临的挑战。
　　在erica sadun编写的所有编程畅销书中， swift开发秘籍 将现代的*佳实践转换为几十个行之有效、方便适用的解决方案。本书的代码示例是针对开发人员遇到的现实问题而创建的，以反映swift的*新功能和*佳实践。每章都将相关任务组织在一起。读者可以直接跳转到所需的解决方案，而不必先确定正确的类或框架。
　　本书涵盖了swift开发的关键概念，展示了如何编写健壮且高效的代码，并帮助读者避免其他开发人员经常遇到的陷阱。书中为使用这一功能强大的语言提供了一些权威的策略，并考虑了swift的快速更新和版本迁移工具。
　　你可能正在从objective-c语言、从swift语言的旧版本或者从非苹果语言迁移到现代的swift语言，本书将有助于你掌握“如何”以及“为什么”进行有效的swift开发。企业招聘人员正在寻找能解决实际问题并能开发有效工作代码的swift开发人员。有了这本书，就可以准备启航了。
                                        </p>]<p><h2>内容简介</h2></p>[<p>清华移动开发经典丛书
swift入门经典
畅销书作者erica sadun  全新作品
教会你进行有效的swift开发
源代码免费下载
 </p>]<p><h2>作者简介</h2></p>[<p>　Erica Sadun是一位畅销书作家，是几十本关于编程和其他技术主题书籍的编著者和贡献者。在苹果开发领域，她是世界上最受人尊敬的专家之一，她的新作包括《iOS Auto Layout开发秘籍(第2版)》等图书。她还是十几个原生iPhone应用的作者，并且在TUAW.com、O'Reilly's Mac Devcenter、Lifehacker和Ars Technica上都拥有自己的博客。Erica
Sadun拥有美国佐治亚理工学院的图形、可视化和可用性中心(Georgia Tech's Graphics, Visualization and Usability Center)的计算机科学博士学位。</p>]<p><h2>目录</h2></p>
    第1章  欢迎使用swift 11.1  代码迁移 21.1.1 如何迁移 21.1.2 迁移课程 31.2  使用swift 41.2.1 编译应用 41.2.2 框架和库 51.2.3 脚本 61.2.4 repl 61.2.5 playground 71.2.6 其他 81.3  学习swift 81.4  小结 9第2章  打印与映射 112.1  基础打印 112.1.1 打印多个条目 122.1.2 添加条目分隔符 132.1.3 字符串插值 132.1.4 控制换行符 142.2  秘诀：打印自定义目标 162.2.1 打印字符串 162.2.2 打印自定义输出流 172.3  秘诀：打印和字符串格式化192.3.1 swift和格式说明符 202.3.2 格式化的局限性 202.3.3 条件编译 212.4  调试打印 222.5  秘诀：后缀打印 242.6  快速查找 252.6.1 quick look for custom types 252.6.2 playground中的quick look for custom types 262.6.3 playground quick looks 262.6.4 为playground创建自定义quick look 272.6.5 内置quick look类型 282.6.6 第三方渲染 292.7  使用dump函数 302.8  构建自定义映射 312.8.1 递归映射 332.8.2 使用协议一致性构建基本映射描述 332.9  添加标题文档 352.9.1 构建标题文档 362.9.2 markdown支持 362.9.3 关键字 372.9.4 特殊的swift关注点 392.9.5 为标题文档添加图像 402.10 小结 41第3章  可选类型?! 433.1  可选类型初步 433.2  展开可选值(unwrappingoptionals) 453.2.1 强制展开 453.2.2 条件绑定 453.2.3 条件绑定和类型转换 463.2.4 级联绑定 483.2.5 guard语句 493.2.6 可选值的隐式展开 503.2.7 保护failable初始化器 523.2.8 可选值和哨兵值 533.2.9 合并 553.2.10 可选赋值 553.2.11 可选模式 563.3  可选链 583.3.1 选择器测试和可选链 603.3.2 下标 613.4  可选映射 613.4.1 映射和链 623.4.2 使用flatmap过滤nil值 623.5  非托管包装器 633.6  小结 64第4章  闭包和函数 674.1  创建函数 674.1.1 参数名 684.1.2 标签约定 684.1.3 方法和函数的命名 704.1.4 外部和局部参数 714.1.5 默认参数 714.1.6 常量和变量参数 734.1.7 修改参数 744.2  闭包和函数 754.2.1 函数类型 754.2.2 使用元组实参 764.2.3 使用实参名缩写 774.2.4 推断闭包类型 784.2.5 参数类型推断 804.2.6 声明类型别名 804.2.7 嵌套函数 814.3  元组 834.3.1 将元组转换成结构体 844.3.2 元组返回类型 854.4  可变参数 864.5  捕获值 874.6 autoclosure 904.7  柯里化(currying)944.7.1 柯里化的原因 954.7.2 构建库 954.7.3 局部应用 974.7.4 柯里化的成本 974.7.5 柯里化和回调 974.7.6 柯里化实践 994.8  将闭包传递给函数参数1004.9  小结 103第5章  泛型和协议 1055.1  详述泛型 1055.1.1 协议 1065.1.2 标记 1075.1.3 类型约束 1085.2  采用协议 1085.2.1 声明协议 1095.2.2 成员声明 1115.2.3 构建基本协议 1135.2.4 添加协议的默认实现 1145.2.5 可选的协议要求 1165.2.6 swift原生的可选协议要求 1165.3  构建泛型类型 1175.4  泛型要求 1195.4.1 一致性要求 1195.4.2 秘诀：相同类型要求 1205.4.3 泛型美化 1215.4.4 合法的标记 1225.4.5 匹配别名 1235.4.6 协议别名的默认值 1235.4.7 关联类型总结 1245.5  扩展泛型类型 1255.6  使用协议类型 1265.6.1 基于协议的集合 1265.6.2 self要求 1265.6.3 协议对象和self要求 1285.7  利用协议 1295.8  小结 129第6章  错误 1316.1  冷酷无情的失败 1316.1.1 致命错误 1326.1.2 断言 1326.1.3 先决条件 1336.1.4 中断和退出 1346.2  优雅地失败 1346.2.1 errortype协议 1346.2.2 在可选项和错误处理之间做出选择 1366.3 swift的错误规则 1366.3.1 规则1：远离nil哨兵 1366.3.2 规则2：使用throw抛出错误 1386.3.3 规则3：使用带有可见访问的错误类型 1396.3.4 规则4：使用throws来标记所有错误参与的方法 1396.3.5 规则5：坚持使用rethrows 1406.3.6 规则6：消耗错误是很重要的 1416.3.7 规则7：终止线程的错误链 1416.4  构建错误 1436.4.1 良好的错误 1446.4.2 为错误命名 1446.5  添加字符串描述 1456.5.1 添加原因 1456.5.2 简化输出 1466.5.3 扩展字符串 1476.5.4 类型特定的错误 1476.6  获取上下文 1476.6.1 将字符串置于上下文中研究 1486.6.2 将抛出类型置于上下文中研究 1496.6.3 简化上下文 1516.7  调用抛出函数 1526.7.1 使用try 1526.7.2 错误传播 1536.7.3 使用 try! 1546.7.4 使用 try? 1556.8  为try?实现替代方法 1566.8.1 谨慎使用结果 1586.8.2 构建try?的打印版本 1586.9  使用guard和defer 1596.10 小结 160第7章  类型 1617.1  语言概念 1617.1.1 引用类型和值类型 1617.1.2 复制与回写 1637.1.3 代数数据类型 1647.1.4 其他术语 1647.2  枚举 1657.2.1 基本枚举 1667.2.2 使用哈希值来支持区间 1667.2.3 原始值枚举 1687.2.4 原始值成员和序列 1697.2.5 关联值 1717.2.6 间接值 1727.3 switch语句 1737.3.1 分支 1737.3.2 中断 1747.3.3 fallthrough 1747.3.4 复杂的case 1767.3.5 元组 1767.3.6 值绑定的模式匹配 1777.3.7 where子句 1777.3.8 展开可选的枚举 1787.4  通过类型嵌入值 1797.5  选项集 1827.5.1 重温 ns_options 1827.5.2 构建枚举 1837.5.3 构建选项集 1847.5.4 查看选项 1847.6  类 1857.6.1 优化 1867.6.2 初始化器 1867.6.3 初始化步骤 1877.6.4 指定初始化器和便利初始化器 1877.6.5 初始化器规则 1877.6.6 构建便利初始化器 1887.6.7 可失败初始化器和抛出初始化器 1897.6.8 析构器 1917.7  属性观察器 1927.8  扩展和重写 1947.9  惰性求值 1967.9.1 惰性序列 1967.9.2 惰性属性 1967.10 小结 197第8章  杂记 1998.1  声明标签 1998.2  自定义运算符 2018.2.1 声明运算符 2018.2.2 运算符的一致性 2028.2.3 对运算符的取舍进行评估 2038.3  数组的索引 2038.3.1 多索引的数组访问 2048.3.2 封装索引 2068.3.3 数组切片 2068.4  泛型下标 2078.5  字符串工具 2098.5.1 重复元素初始化器 2098.5.2 字符串和基数 2098.5.3 字符串区间 2118.5.4 字符串分割 2128.5.5 字符串下标2138.5.6 与foundation的互操作 2148.5.7 连接与扩展 2148.6  序列生成器 2158.7  小结 217
