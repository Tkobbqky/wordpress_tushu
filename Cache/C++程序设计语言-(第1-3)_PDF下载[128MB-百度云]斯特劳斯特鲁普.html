C++程序设计语言-(第1-3) PDF下载 斯特劳斯特鲁普 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711153941
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711153941
<p>书名:C++程序设计语言-(第1-3)</p><p>作者:斯特劳斯特鲁普</p><p>页数:726</p><p>定价:¥139.0</p><p>出版社:机械工业出版社</p><p>出版日期:2016-06-01</p><p>ISBN:9787111539414</p><p><h2>本书特色</h2></p>[<p>
《c  程序设计语言》（原书第4版）是c  领域*经典的参考书，介绍了c  11的各项新特性和新功能。全书共分四部分。**部分（第1~5章）是引言，包括c  的背景知识，c  语言及其标准库的简要介绍；第二部分（第6~15章）介绍c  的内置类型和基本特性，以及如何用它们构造程序；第三部分（第16~29章）介绍c  的抽象机制及如何用这些机制编写面向对象程序和泛型程序；第四部分（第30~44章）概述标准库并讨论一些兼容性问题。由于篇幅问题，原书中文版分两册出版，分别对应原书的**至三部分和第四部分。这一册为**至三部分。
                                        </p>]<p><h2>内容简介</h2></p>[<p>
                                         


 </p>]<p><h2>目录</h2></p>
    目　录the c   programming language, fourth edition出版者的话译者序前言第3版前言第2版前言第1版前言**部分　引言第1章　致读者  21.1　本书结构  21.1.1　引言  21.1.2　基本特性  31.1.3　抽象机制  41.1.4　标准库  51.1.5　例子和参考文献  51.2　c  的设计  71.2.1　程序设计风格  81.2.2　类型检查  111.2.3　c兼容性  121.2.4　语言、库和系统  121.3　学习c    141.3.1　用c  编程  151.3.2　对c  程序员的建议  161.3.3　对c程序员的建议  161.3.4　对java程序员的建议  171.4　c  的历史  181.4.1　大事年表  191.4.2　早期的c    191.4.3　1998标准  211.4.4　2011标准  231.4.5　c  的用途  261.5　建议  271.6　参考文献  28第2章　c  概览：基础知识  322.1　引言  322.2　基本概念  332.2.1　hello，world!  332.2.2　类型、变量和算术运算  342.2.3　常量  362.2.4　检验和循环  372.2.5　指针、数组和循环  382.3　用户自定义类型  402.3.1　结构  412.3.2　类  422.3.3　枚举  432.4　模块化  442.4.1　分离编译  452.4.2　名字空间  462.4.3　错误处理  472.5　附记  502.6　建议  50第3章　c  概览：抽象机制  513.1　引言  513.2　类  513.2.1　具体类型  523.2.2　抽象类型  563.2.3　虚函数  583.2.4　类层次  593.3　拷贝和移动  623.3.1　拷贝容器  633.3.2　移动容器  643.3.3　资源管理  663.3.4　抑制操作  663.4　模板  673.4.1　参数化类型  673.4.2　函数模板  693.4.3　函数对象  693.4.4　可变参数模板  713.4.5　别名  723.5　建议  73第4章　c  概览：容器与算法  744.1　标准库  744.1.1　标准库概述  754.1.2　标准库头文件与名字空间  754.2　字符串  774.3　i/o流  784.3.1　输出  784.3.2　输入  794.3.3　用户自定义类型的i/o  804.4　容器  814.4.1　vector  814.4.2　list  844.4.3　map  854.4.4　unordered_map  864.4.5　容器概述  864.5　算法  874.5.1　使用迭代器  884.5.2　迭代器类型  904.5.3　流迭代器  914.5.4　谓词  934.5.5　算法概述  934.5.6　容器算法  944.6　建议  94第5章　c  概览：并发与实用功能  965.1　引言  965.2　资源管理  965.2.1　unique_ptr与shared_ptr  975.3　并发  995.3.1　任务和thread  995.3.2　传递参数  1005.3.3　返回结果  1005.3.4　共享数据  1015.3.5　任务通信  1035.4　小工具组件  1065.4.1　时间  1065.4.2　类型函数  1075.4.3　pair和tuple  1095.5　正则表达式  1105.6　数学计算  1115.6.1　数学函数和算法  1115.6.2　复数  1115.6.3　随机数  1125.6.4　向量算术  1135.6.5　数值限制  1135.7　建议  114第二部分　基本功能第6章　类型与声明  1166.1　iso c  标准  1166.1.1　实现  1176.1.2　基本源程序字符集  1186.2　类型  1186.2.1　基本类型  1196.2.2　布尔值  1196.2.3　字符类型  1216.2.4　整数类型  1246.2.5　浮点数类型  1266.2.6　前缀和后缀  1276.2.7　void  1286.2.8　类型尺寸  1286.2.9　对齐  1306.3　声明  1316.3.1　声明的结构  1336.3.2　声明多个名字  1346.3.3　名字  1346.3.4　作用域  1366.3.5　初始化  1386.3.6　推断类型：auto和decltype()  1416.4　对象和值  1446.4.1　左值和右值  1446.4.2　对象的生命周期  1456.5　类型别名  1466.6　建议  147第7章　指针、数组与引用  1487.1　引言  1487.2　指针  1487.2.1　void*  1497.2.2　nullptr  1507.3　数组  1507.3.1　数组的初始化器  1527.3.2　字符串字面值常量  1527.4　数组中的指针  1557.4.1　数组漫游  1567.4.2　多维数组  1587.4.3　传递数组  1597.5　指针与const  1617.6　指针与所有权  1637.7　引用  1637.7.1　左值引用  1647.7.2　右值引用  1677.7.3　引用的引用  1697.7.4　指针与引用  1707.8　建议  172第8章　结构、联合与枚举  1738.1　引言  1738.2　结构  1738.2.1　struct的布局  1758.2.2　struct的名字  1768.2.3　结构与类  1778.2.4　结构与数组  1788.2.5　类型等价  1808.2.6　普通旧数据  1808.2.7　域  1828.3　联合  1838.3.1　联合与类  1858.3.2　匿名union  1868.4　枚举  1888.4.1　enum class  1888.4.2　普通的enum  1918.4.3　未命名的enum  1928.5　建议  193第9章　语句  1949.1　引言  1949.2　语句概述  1949.3　声明作为语句  1959.4　选择语句  1969.4.1　if语句  1969.4.2　switch语句  1989.4.3　条件中的声明  2009.5　循环语句  2019.5.1　范围for语句  2019.5.2　for语句  2029.5.3　while语句  2039.5.4　do语句  2039.5.5　退出循环  2049.6　goto语句  2049.7　注释与缩进  2059.8　建议  207第10章　表达式  20810.1　引言  20810.2　一个桌面计算器示例  20810.2.1　分析器  20910.2.2　输入  21310.2.3　底层输入  21610.2.4　错误处理  21710.2.5　驱动程序  21710.2.6　头文件  21810.2.7　命令行参数  21810.2.8　关于风格  22010.3　运算符概述  22010.3.1　结果  22410.3.2　求值顺序  22410.3.3　运算符优先级  22510.3.4　临时对象  22610.4　常量表达式  22710.4.1　符号化常量  22910.4.2　常量表达式中的const  22910.4.3　字面值常量类型  22910.4.4　引用参数  23010.4.5　地址常量表达式  23110.5　隐式类型转换  23110.5.1　提升  23110.5.2　类型转换  23210.5.3　常用的算术类型转换  23410.6　建议  235第11章　选择适当的操作  23611.1　其他运算符  23611.1.1　逻辑运算符  23611.1.2　位逻辑运算符  23611.1.3　条件表达式  23811.1.4　递增与递减  23811.2　自由存储  24011.2.1　内存管理  24111.2.2　数组  24311.2.3　获取内存空间  24411.2.4　重载new  24511.3　列表  24711.3.1　实现模型  24811.3.2　限定列表  24911.3.3　未限定列表  24911.4　lambda表达式  25111.4.1　实现模型  25111.4.2　lambda的替代品  25211.4.3　捕获  25411.4.4　调用与返回  25711.4.5　lambda的类型  25711.5　显式类型转换  25811.5.1　构造  25911.5.2　命名转换  26111.5.3　c风格的转换  26211.5.4　函数形式的转换  26211.6　建议  263第12章　函数  26412.1　函数声明  26412.1.1　为什么使用函数  26512.1.2　函数声明的组成要件  26512.1.3　函数定义  26612.1.4　返回值  26712.1.5　inline函数  26912.1.6　constexpr函数  26912.1.7　[[noreturn]]函数  27112.1.8　局部变量  27212.2　参数传递  27312.2.1　引用参数  27312.2.2　数组参数  27512.2.3　列表参数  27712.2.4　数量未定的参数  27812.2.5　默认参数  28112.3　重载函数  28212.3.1　自动重载解析  28312.3.2　重载与返回类型  28412.3.3　重载与作用域  28512.3.4　多实参解析  28512.3.5　手动重载解析  28612.4　前置与后置条件  28612.5　函数指针  28812.6　宏  29212.6.1　条件编译  29412.6.2　预定义宏  29512.6.3　编译指令  29612.7　建议  296第13章　异常处理  29713.1　错误处理  29713.1.1　异常  29813.1.2　传统的错误处理  29913.1.3　渐进决策  30013.1.4　另一种视角看异常  30113.1.5　何时不应使用异常  30213.1.6　层次化错误处理  30313.1.7　异常与效率  30413.2　异常保障  30513.3　资源管理  30713.3.1　finally  31013.4　强制不变式  31113.5　抛出与捕获异常  31513.5.1　抛出异常  31513.5.2　捕获异常  31813.5.3　异常与线程  32413.6　vector的实现  32413.6.1　一个简单的vector  32513.6.2　显式地表示内存  32813.6.3　赋值  33113.6.4　改变尺寸  33213.7　建议  335第14章　名字空间  33714.1　组合问题  33714.2　名字空间  33814.2.1　显式限定  33914.2.2　using声明  34014.2.3　using指示  34114.2.4　参数依赖查找  34214.2.5　名字空间是开放的  34414.3　模块化和接口  34514.3.1　名字空间作为模块  34614.3.2　实现  34814.3.3　接口和名字  34914.4　组合使用名字空间  35114.4.1　便利性与安全性  35114.4.2　名字空间别名  35214.4.3　组合名字空间  35214.4.4　组合与选择  35314.4.5　名字空间和重载  35414.4.6　版本控制  35614.4.7　名字空间嵌套  35814.4.8　无名名字空间  35914.4.9　c头文件  35914.5　建议  360第15章　源文件与程序  36215.1　分离编译  36215.2　链接  36315.2.1　文件内名字  36515.2.2　头文件  36615.2.3　单一定义规则  36815.2.4　标准库头文件  36915.2.5　链接非c  代码  37015.2.6　链接和函数指针  37215.3　使用头文件  37315.3.1　单头文件组织  37315.3.2　多头文件组织  37615.3.3　包含保护  38015.4　程序  38115.4.1　非局部变量初始化  38115.4.2　初始化和并发  38215.4.3　程序终止  38315.5　建议  384第三部分　抽象机制第16章　类  38616.1　引言  38616.2　类基础  38716.2.1　成员函数  38816.2.2　默认拷贝  38916.2.3　访问控制  38916.2.4　class和struct  39016.2.5　构造函数  39116.2.6　explicit构造函数  39316.2.7　类内初始化器  39516.2.8　类内函数定义  39516.2.9　可变性  39616.2.10　自引用  39916.2.11　成员访问  40016.2.12　static成员  40116.2.13　成员类型  40316.3　具体类  40316.3.1　成员函数  40616.3.2　辅助函数  40816.3.3　重载运算符  41016.3.4　具体类的重要性  41016.4　建议  411第17章　构造、清理、拷贝和移动  41317.1　引言  41317.2　构造函数和析构函数  41517.2.1　构造函数和不变式  41517.2.2　析构函数和资源  41617.2.3　基类和成员析构函数  41717.2.4　调用构造函数和析构函数  41817.2.5　virtual析构函数  41917.3　类对象初始化  42017.3.1　不使用构造函数进行初始化  42017.3.2　使用构造函数进行初始化  42117.3.3　默认构造函数  42417.3.4　初始化器列表构造函数  42517.4　成员和基类初始化  42917.4.1　成员初始化  42917.4.2　基类初始化器  43117.4.3　委托构造函数  43117.4.4　类内初始化器  43217.4.5　static成员初始化  43417.5　拷贝和移动  43517.5.1　拷贝  43517.5.2　移动  44117.6　生成默认操作  44417.6.1　显式声明默认操作  44417.6.2　默认操作  44517.6.3　使用默认操作  44617.6.4　使用delete删除的函数  44917.7　建议  451第18章　运算符重载  45218.1　引言  45218.2　运算符函数  45318.2.1　二元和一元运算符  45418.2.2　运算符的预置含义  45518.2.3　运算符与用户自定义类型  45618.2.4　传递对象  45618.2.5　名字空间中的运算符  45718.3　复数类型  45918.3.1　成员和非成员运算符  45918.3.2　混合模式运算  46018.3.3　类型转换  46118.3.4　字面值常量  46318.3.5　访问函数  46418.3.6　辅助函数  46518.4　类型转换  46618.4.1　类型转换运算符  46618.4.2　explicit类型转换运算符  46718.4.3　二义性  46818.5　建议  469第19章　特殊运算符  47119.1　引言  47119.2　特殊运算符  47119.2.1　取下标  47119.2.2　函数调用  47219.2.3　解引用  47319.2.4　递增和递减  47519.2.5　分配和释放  47719.2.6　用户自定义字面值常量  47819.3　字符串类  48119.3.1　**操作  48119.3.2　访问字符  48219.3.3　类的表示  48319.3.4　成员函数  48519.3.5　辅助函数  48719.3.6　应用string  48919.4　友元  49019.4.1　发现友元  49119.4.2　友元与成员  49219.5　建议  493第20章　派生类  49520.1　引言  49520.2　派生类  49620.2.1　成员函数  49820.2.2　构造函数和析构函数  49920.3　类层次  50020.3.1　类型域  50020.3.2　虚函数  50220.3.3　显式限定  50420.3.4　覆盖控制  50520.3.5　using基类成员  50820.3.6　返回类型放松  51120.4　抽象类  51220.5　访问控制  51420.5.1　protected成员  51720.5.2　访问基类  51820.5.3　using声明与访问控制  51920.6　成员指针  52020.6.1　函数成员指针  52020.6.2　数据成员指针  52220.6.3　基类和派生类成员  52320.7　建议  523第21章　类层次  52421.1　引言  52421.2　设计类层次  52421.2.1　实现继承  52521.2.2　接口继承  52721.2.3　替代实现方式  52921.2.4　定位对象创建  53221.3　多重继承  53321.3.1　多重接口  53321.3.2　多重实现类  53321.3.3　二义性解析  53521.3.4　重复使用基类  53821.3.5　虚基类  53921.3.6　重复基类与虚基类  54421.4　建议  546第22章　运行时类型信息  54722.1　引言  54722.2　类层次导航  54722.2.1　dynamic_cast  54822.2.2　多重继承  55122.2.3　static_cast和dynamic_cast  55222.2.4　恢复接口  55322.3　双重分发和访客  55722.3.1　双重分发  55722.3.2　访客  55922.4　构造和析构  56122.5　类型识别  56122.5.1　扩展类型信息  56322.6　rtti的使用和误用  56422.7　建议  565第23章　模板  56623.1　引言和概述  56623.2　一个简单的字符串模板  56823.2.1　定义模板  56923.2.2　模板实例化  57123.3　类型检查  57123.3.1　类型等价  57223.3.2　错误检测  57323.4　类模板成员  57423.4.1　数据成员  57423.4.2　成员函数  57523.4.3　成员类型别名  57523.4.4　static成员  57523.4.5　成员类型  57623.4.6　成员模板  57723.4.7　友元  58023.5　函数模板  58223.5.1　函数模板实参  58323.5.2　函数模板实参推断  58423.5.3　函数模板重载  58623.6　模板别名  59023.7　源码组织  59123.7.1　链接  59323.8　建议  594第24章　泛型程序设计  59524.1　引言  59524.2　算法和提升  59624.3　概念  59924.3.1　发现概念  59924.3.2　概念和约束  60224.4　具体化概念  60424.4.1　公理  60724.4.2　多实参概念  60724.4.3　值概念  60824.4.4　约束检查  60924.4.5　模板定义检查  61024.5　建议  612第25章　特例化  61325.1　引言  61325.2　模板参数和实参  61425.2.1　类型作为实参  61425.2.2　值作为实参  61525.2.3　操作作为实参  61625.2.4　模板作为实参  61825.2.5　默认模板实参  61925.3　特例化  62125.3.1　接口特例化  62325.3.2　主模板  62425.3.3　特例化顺序  62525.3.4　函数模板特例化  62625.4　建议  628第26章　实例化  62926.1　引言  62926.2　模板实例化  63026.2.1　何时需要实例化  63026.2.2　手工控制实例化  63126.3　名字绑定  63226.3.1　依赖性名字  63326.3.2　定义点绑定  63526.3.3　实例化点绑定  63626.3.4　多实例化点  63826.3.5　模板和名字空间  63926.3.6　过于激进的adl  63926.3.7　来自基类的名字  64126.4　建议  643第27章　模板和类层次  64527.1　引言  64527.2　参数化和类层次  64627.2.1　生成类型  64727.2.2　模板类型转换  64927.3　类模板层次  65027.3.1　模板作为接口  65127.4　模板参数作为基类  65227.4.1　组合数据结构  65227.4.2　线性化类层次  65527.5　建议  660第28章　元编程  66128.1　引言  66128.2　类型函数  66328.2.1　类型别名  66528.2.2　类型谓词  66628.2.3　选择函数  66828.2.4　萃取  66828.3　控制结构  67028.3.1　选择  67028.3.2　迭代和递归  67328.3.3　何时使用元编程  67428.4　条件定义：enable_if  67528.4.1　使用enable_if  67628.4.2　实现enable_if  67828.4.3　enable_if与概念  67828.4.4　更多enable_if例子  67928.5　一个编译时列表：tuple  68128.5.1　一个简单的输出函数  68328.5.2　元素访问  68428.5.3　make_tuple  68628.6　可变参数模板  68628.6.1　一个类型安全的printf()  68728.6.2　技术细节  68928.6.3　转发  69128.6.4　标准库tuple  69228.7　国际标准单位例子  69428.7.1　unit  69528.7.2　quantity  69628.7.3　unit字面值常量  69728.7.4　工具函数  69828.8　建议  700第29章　一个矩阵设计  70129.1　引言  70129.1.1　matrix的基本使用  70129.1.2　对matrix的要求  70329.2　matrix模板  70429.2.1　构造和赋值  70529.2.2　下标和切片  70629.3　matrix算术运算  70829.3.1　标量运算  70929.3.2　加法  71029.3.3　乘法  71129.4　matrix实现  71229.4.1　slice()  71329.4.2　matrix切片  71329.4.3　matrix_ref  71429.4.4　matrix列表初始化  71529.4.5　matrix访问  71729.4.6　零维matrix  71929.5　求解线性方程组  72029.5.1　经典高斯消去法  72129.5.2　旋转  72229.5.3　测试  72329.5.4　熔合运算  72329.6　建议  725
