EVENT-B建模:系统和软件工程 PDF下载 [法]简-埃蒙德·阿布瑞尔（Jean- 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711550899
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711550899
<p>书名:EVENT-B建模:系统和软件工程</p><p>作者:[法] 简-埃蒙德·阿布瑞尔（Jean-</p><p>页数:462</p><p>定价:¥129.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2018-03-01</p><p>ISBN:9787115508997</p><p><h2>本书特色</h2></p>[<p>
这本实用的教科书适用于形式化方法的入门课程或高级课程。本书以B形式化方法的一个扩展Event-B作为工具，展示了一种完成系统建模和设计的数学方法。 简-埃蒙德·阿布瑞尔（Jean-Raymond Abrial）是国际著名计算机科学家，曾任苏黎世联邦理工学院客座教授，他基于精化的思想提出了一种系统化的方法，教读者如何逐步构造出所期望的模型，并通过严格的证明完成对所构造模型做系统化的推理。本书将介绍如何根据实际需要去构造各种程序，以及如何更为普遍地构造各种离散系统的模型。本书提供了大量的示例，这些示例源自计算机系统开发的各个领域，包括顺序程序、并发程序和电子线路等。 本书还包含了大量具有不同难度的练习和开发项目。书中的每个例子都用Rodin平台工具集证明过。 本书适合作为高等院校计算机、软件工程、网络工程、信息安全等专业高年级本科生、研究生的教材，也可供相关领域的研究人员和技术人员参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>这本实用的教科书适用于形式化方法的入门课程或不错课程。本书以B形式化方法的一个扩展Event-B作为工具，展示了一种完成系统建模和设计的数学方法。
简-埃蒙德·阿布瑞尔（Jean-Raymond Abrial）是靠前有名计算机科学家，曾任苏黎世联邦理工学院客座教授，他基于精化的思想提出了一种系统化的方法，教读者如何逐步构造出所期望的模型，并通过严格的证明完成对所构造模型做系统化的推理。本书将介绍如何根据实际需要去构造各种程序，以及如何更为普遍地构造各种离散系统的模型。本书提供了大量的示例，这些示例源自计算机系统开发的各个领域，包括顺序程序、并发程序和电子线路等。
本书还包含了大量具有不同难度的练习和开发项目。书中的每个例子都用Rodin平台工具集证明过。
本书适合作为高等院校计算机、软件工程、网络工程、信息安全等专业高年级本科生、研究生的教材，也可供相关领域的研究人员和技术人员参考。</p>]<p><h2>作者简介</h2></p>[<p>简-埃蒙德·阿布瑞尔（Jean-Raymond Abrial） 法国计算机科学家，国际知名的形式化方法和软件工程专家，欧洲科学院院士。20世纪80年代，他先后开发了著名的Z语言和B方法。2000年以后，他开发了Event-B方法，并领导一个国际团队，在欧盟项目支持下，为Event-B开发了公开免费的Rodin平台。这些语言和方法被国际形式化方法领域广泛接受和使用，并被开发工作者应用于软件和其他系统的实际开发工作。阿布瑞尔教授长期致力于推动和参与形式化方法的工业应用，指导了B方法在轨道交通领域的最早开发工作，在相关领域做出了卓越的贡献。阿布瑞尔教授与国内一些高校和研究单位有长期而密切的合作关系，并于2016年获得了中华人民共和国国务院颁发的“中华人民 共和国国际科学技术合作奖”。</p>]<p><h2>目录</h2></p>
    第 1章　引言 11.1　动机 11.2　各章概览 21.3　如何用这本书 61.4　形式化方法 81.5　一个小迂回：蓝图 91.6　需求文档 101.6.1　生命周期 101.6.2　需求文档的困难 101.6.3　一种有用的比较 111.7　本书中使用的“形式化方法”的定义 121.7.1　复杂系统 121.7.2　离散系统 131.7.3　测试推理与模型（蓝图）推理 131.8　有关离散模型的非形式化概览 141.8.1　状态和迁移 141.8.2　操作性解释 141.8.3　形式化推理 151.8.4　管理闭模型的复杂性 151.8.5　精化 151.8.6　分解 161.8.7　泛型开发 161.9 参考资料 17第 2章　控制桥上的汽车 182.1　引言 182.2　需求文档 182.3　精化策略 202.4　初始模型：限制汽车的数量 202.4.1　引言 202.4.2　状态的形式化 212.4.3　事件的形式化 222.4.4　前-后谓词 232.4.5　证明不变式的保持性质 232.4.6　相继式 252.4.7　应用不变式保持性的规则 252.4.8　证明义务的证明 262.4.9　推理规则 272.4.10　元变量 292.4.11　证明 292.4.12　更多推理规则 302.4.13　改造两个事件：引进卫 312.4.14　改造的不变式保持规则 312.4.15　重新证明不变式的保持性 322.4.16　初始化 332.4.17　初始化事件init的不变式建立规则 332.4.18　应用不变式建立规则 342.4.19　证明初始化的证明义务：更多推理规则 342.4.20　无死锁 352.4.21　无死锁规则 352.4.22　应用无死锁证明义务规则 352.4.23　更多推理规则 362.4.24　证明无死锁的证明义务 372.4.25　对初始模型的总结 382.5　第 一次精化：引入单行桥 382.5.1　引言 382.5.2　状态的精化 392.5.3　精化抽象事件 402.5.4　重温前-后谓词 402.5.5　精化的非形式化证明 412.5.6　证明抽象事件的正确精化 422.5.7　应用精化规则 432.5.8　精化初始化事件init 452.5.9　初始化事件init精化正确性的证明义务规则 462.5.10　应用初始化精化的证明义务规则 462.5.11　引入新事件 462.5.12　空动作skip 472.5.13　证明两个新事件的正确性 472.5.14　证明新事件的收敛性 492.5.15　应用非收敛证明义务规则 502.5.16　相对无死锁 512.5.17　应用相对无死锁证明义务规则 512.5.18　更多推理规则 522.5.19　第 一个精化的总结 542.6　第二次精化：引入交通灯 552.6.1　精化状态 552.6.2　精化抽象事件 562.6.3　引进新事件 562.6.4　叠加：调整精化规则 572.6.5　证明事件的正确性 582.6.6　更多逻辑推理规则 582.6.7　试探性的证明和解 582.6.8　新事件的收敛性 642.6.9　相对无死锁 672.6.10　第二个精化的总结 682.7　第三次精化：引入车辆传感器 702.7.1　引言 702.7.2　精化状态 722.7.3　精化控制器里的抽象事件 752.7.4　在环境里增加新事件 772.7.5　新事件的收敛性 782.7.6　无死锁 78第3章　冲压机控制器 793.1　非形式描述 793.1.1　基本设备 793.1.2　基本命令和按钮 803.1.3　基本用户动作 803.1.4　用户工作期 803.1.5　危险：控制器的必要性 803.1.6　安全门 813.2　设计模式 813.2.1　动作和反应 823.2.2　第 一种情况：一个简单的动作反应模式，无反作用 833.2.3　第二种情况：一个简单的动作模式，一次重复动作和反应 863.3　冲压机的需求 903.4　精化策略 913.5　初始模型：连接控制器和电动机 923.5.1　引言 923.5.2　建模 923.5.3　事件的总结 943.6　第 一次精化：把电动机按钮连接到控制器 943.6.1　引言 943.6.2　建模 953.6.3　加入“假”事件 993.6.4　事件的总结 1003.7　第二次精化：连接控制器到离合器 1003.8　另一个设计模式：两个强反应的弱同步 1013.8.1　引言 1013.8.2　建模 1033.9　第三次精化：约束离合器和电动机 1083.10　第四次精化：连接控制器到安全门 1103.10.1　拷贝 1103.10.2　事件的总结 1103.11　第五次精化：约束离合器和安全门 1103.12　另一设计模式：两个强反应的强同步 1113.12.1　引言 1113.12.2　建模 1123.13　第六次精化：离合器和安全门之间的更多约束 1173.14　第七次精化：把控制器连接到离合器按钮 1183.14.1　拷贝 1183.14.2　事件的总结 118第4章　简单文件传输协议 1204.1　需求 1204.2　精化策略 1204.3　协议的初始模型 1214.3.1　状态 1224.3.2　一些数学表示法 1224.3.3　事件 1254.3.4　证明 1254.4　协议的第 一次精化 1274.4.1　非形式化的说明 1274.4.2　状态 1284.4.3　更多数学符号 1284.4.4　事件 1304.4.5　精化证明 1314.4.6　事件receive的收敛性证明 1344.4.7　相对无死锁证明 1354.5　协议的第二次精化 1354.5.1　状态和事件 1354.5.2　证明 1374.6　协议的第三次精化 1374.6.1　状态 1374.6.2　事件 1384.6.3　全称量化谓词的推理规则 1384.7　对开发的回顾 1394.7.1　动机和预期事件的引入 1394.7.2　初始模型 1404.7.3　第 一次精化 1404.7.4　第二次精化 1414.7.5　第三次精化 1414.8　参考资料 142第5章　Event-B建模语言和证明义务规则 1435.1　Event-B表示法 1435.1.1　引言：机器和上下文 1435.1.2　机器和上下文的关系 1435.1.3　上下文的结构 1445.1.4　上下文的例子 1455.1.5　机器的结构 1455.1.6　机器的例子 1465.1.7　事件 1475.1.8　动作 1475.1.9　事件的例子 1495.2　证明义务规则 1505.2.1　引言 1505.2.2　不变式保持证明义务规则：INV 1515.2.3　可行性证明义务规则：FIS 1535.2.4　卫加强证明义务规则：GRD 1535.2.5　卫归并证明义务规则：MRG 1545.2.6　模拟证明义务规则：SIM 1555.2.7　数值变动式证明义务规则：NAT 1585.2.8　有穷集变动式证明义务规则：FIN 1585.2.9　变动量证明义务规则：VAR 1595.2.10　非确定性见证证明义务规则：WFIS 1615.2.11　定理证明义务规则：THM 1625.2.12　良好定义证明义务规则：WD 162第6章　有界重传协议 1636.1　有界重传协议的非形式说明 1636.1.1　正常行为 1636.1.2　不可靠的通信 1636.1.3　协议流产 1646.1.4　交替位 1646.1.5　协议的*后情况 1646.1.6　BRP的伪代码描述 1656.1.7　有关伪代码的说明 1676.2　需求文档 1676.3　精化策略 1686.4　初始模型 1696.4.1　状态 1696.4.2　事件 1696.5　第 一次和第二次精化 1706.5.1　状态 1706.5.2　第 一次精化的事件 1706.5.3　第二次精化的事件 1716.6　第三次精化 1716.6.1　状态 1726.6.2　事件 1726.6.3　事件之间的同步 1736.7　第四次精化 1736.7.1　状态 1736.7.2　事件 1746.7.3　事件的同步 1756.8　第五次精化 1766.8.1　状态 1766.8.2　事件 1776.8.3　事件的同步 1806.9　第六次精化 1816.10　参考资料 181第7章　一个并发程序的开发1 1827.1　分布式和并发程序的比较 1827.1.1　分布式程序 1827.1.2　并发程序 1827.2　提出的实例 1837.2.1　非形式的说明 1837.2.2　非并发的场景展示 1857.2.3　定义原子性 1867.3　交错 1877.3.1　问题 1877.3.2　计算不同交错的数目 1887.3.3　结果 1897.4　并发程序的规范描述 1907.4.1　写和读的轨迹 1907.4.2　轨迹之间的关系 1907.4.3　不变式的总结 1937.4.4　事件 1937.5　精化策略 1947.5.1　*终精化的梗概 1947.5.2　精化的目标 1967.6　第 一次精化 1967.6.1　读者状态 1967.6.2　读事件 1977.6.3　写者状态 1987.6.4　写事件 1987.7　第二次精化 2007.7.1　状态 2007.7.2　事件和新增的不变式 2007.8　第三次精化 2037.8.1　状态 2037.8.2　事件 2037.9　第四次精化 2047.9.1　状态 2047.9.2　事件 2057.10　参考资料 206第8章　电路的开发 2078.1　引言 2078.1.1　同步电路 2078.1.2　电路与其环境的耦合 2088.1.3　耦合的动态观点 2088.1.4　耦合的静态观点 2098.1.5　协调性条件 2098.1.6　一个警告 2108.1.7　电路的*终构造 2108.1.8　一个非常小的示例 2138.2　第 一个例子 2148.2.1　非形式的规范描述 2148.2.2　初始模型 2158.2.3　精化电路以减少其非确定性 2188.2.4　通过改变数据空间来精化电路 2208.2.5　构造*后的电路 2228.3　第二个例子：仲裁器 2258.3.1　非形式的规范描述 2258.3.2　初始模型 2268.3.3　第 一次精化：让电路生成二进制输出 2298.3.4　第二次精化 2318.3.5　第三次精化：消除电路的非确定性 2338.3.6　第四次精化：构造*后的电路 2348.4　第三个例子：一种特殊的道路交通灯 2348.4.1　非形式的规范描述 2358.4.2　关注点分离的方法 2358.4.3　优先权电路：初始模型 2368.4.4　*后的Priority电路 2388.5　Light电路 2408.5.1　一个抽象：Upper电路 2418.5.2　精化：加入Lower电路 2428.6　参考资料 245第9章　数学语言 2469.1　相继式演算 2469.1.1　定义 2469.1.2　一个数学语言的相继式 2489.1.3　初始理论 2489.2　命题语言 2499.2.1　语法 2499.2.2　初始理论的扩充 2509.2.3　派生规则 2509.2.4　方法论 2529.2.5　命题语言的扩充 2529.3　谓词语言 2539.3.1　语法 2539.3.2　谓词和表达式 2549.3.3　全称量词的推理规则 2549.4　相等谓词 2569.5　集合论语言 2579.5.1　语法 2589.5.2　集合论公理 2589.5.3　基本集合运算符 2599.5.4　基本集合运算符的推广 2609.5.5　二元关系运算符 2619.5.6　函数运算符 2649.5.7　各种箭头的总结 2659.5.8　lambda抽象和函数调用 2659.6　布尔和算术语言 2669.6.1　语法 2669.6.2　皮阿诺公理和递归定义 2679.6.3　算术语言的扩充 2679.7　高级数据结构 2699.7.1　反自反的传递闭包 2699.7.2　强连通图 2709.7.3　无穷表 2719.7.4　有穷表 2749.7.5　环 2769.7.6　无穷树 2779.7.7　有穷深度树 2809.7.8　自由树 2819.7.9　良定义条件和有向无环图 283第 10章　环形网络上选领导 28410.1　需求文档 28410.2　初始模型 28610.3　讨论 28610.3.1　第 一个尝试 28610.3.2　第二个尝试 28710.3.3　第三个尝试 28710.3.4　解的非形式化展示 28710.4　第 一次精化 28810.4.1　状态：环的形式化 28810.4.2　状态：变量 28910.4.3　事件 28910.5　证明 28910.5.1　事件elect的证明 29010.5.2　事件accept的证明 29110.5.3　事件reject的证明 29310.5.4　新事件不发散的证明 29310.5.5　无死锁的证明 29310.6　参考资料 294第 11章　树形网络上的同步 29511.1　引言 29511.2　初始模型 29611.2.1　状态 29611.2.2　事件 29711.2.3　证明 29711.3　第 一次精化 29811.3.1　状态 29811.3.2　事件 30011.3.3　证明 30011.4　第二次精化 30111.5　第三次精化 30311.5.1　事件ascending的精化 30311.5.2　事件descending的精化 30411.5.3　证明定理thm3_4 30611.5.4　证明不变式inv3_3的保持性 30611.6　第四次精化 30811.7　参考资料 310第 12章　移动代理的路由算法 31112.1　问题的非形式化描述 31112.1.1　抽象的非形式化描述 31112.1.2　第 一个非形式化的精化 31212.1.3　第二个非形式化的精化 31212.1.4　第三个非形式化的精化：解 31412.2　初始模型 31512.2.1　状态 31512.2.2　事件 31612.2.3　证明 31712.3　第 一次精化 31812.3.1　状态 31812.3.2　事件 31912.3.3　证明 32012.4　第二次精化 32012.4.1　状态 32012.4.2　事件 32212.4.3　证明 32312.5　第三次精化：数据精化 32412.5.1　状态 32412.5.2　事件 32412.5.3　证明 32512.6　第四次精化 32512.7　参考资料 325第 13章　在连通图网络上选领导 32613.1　初始模型 32613.1.1　状态 32613.1.2　事件 32713.2　第 一次精化 32713.2.1　定义自由树 32713.2.2　扩充状态 32713.2.3　事件的第 一次精化 32813.2.4　第 一次精化的证明 32913.3　第二次精化 32913.3.1　第二次精化的状态 32913.3.2　事件 32913.3.3　证明 33013.4　第三次精化：竞争问题 33013.4.1　引言 33013.4.2　处理竞争的状态 33113.4.3　处理竞争的事件 33213.5　第四次精化：简化 33213.6　第五次精化：引入基数 333第 14章　证明义务的数学模型 33514.1　引言 33514.2　不变式保持性的证明义务规则 33514.3　观察离散迁移系统的演化：迹 33714.3.1　第 一个例子 33814.3.2　迹 33814.3.3　迹的特征 33914.3.4　演化图 33914.3.5　数学表示 33914.4　用迹表示简单精化 34014.4.1　第二个例子 34014.4.2　比较这两个例子 34114.4.3　简单精化：非形式化的方法 34214.4.4　简单精化：形式化定义 34214.4.5　考虑个别的事件 34314.4.6　外部变量和内部变量 34414.4.7　外部集合 34514.5　广义精化的集合论表示 34514.5.1　引言 34614.5.2　精化的形式化定义 34714.5.3　精化的充分条件：前向模拟 34714.5.4　精化的另一充分条件：反向模拟 35214.5.5　迹的精化 35214.6　打破抽象和具体事件之间的一对一关系 35314.6.1　分裂抽象事件 35314.6.2　合并几个抽象事件 35314.6.3　引进新事件 354第 15章　顺序程序的开发 35715.1　开发顺序程序的一种系统化方法 35715.1.1　顺序程序的组成部分 35715.1.2　把顺序程序分解为独立的事件 35815.1.3　方法梗概 35915.1.4　顺序程序的规范：前条件和后条件 35915.2　一个非常简单的例子 36015.2.1　规范 36015.2.2　精化 36115.2.3　推广 36215.3　合并规则 36215.4　例：排序数组里的二分检索 36315.4.1　初始模型 36315.4.2　第 一次精化 36415.4.3　第二次精化 36515.4.4　合并 36615.5　例：自然数数组中的*小值 36615.5.1　初始模型 36615.5.2　第 一次精化 36715.6　例：数组划分 36715.6.1　初始模型 36715.6.2　第 一次精化 36815.6.3　合并 37015.7　例：简单排序 37015.7.1　初始模型 37015.7.2　第 一次精化 37115.7.3　第二次精化 37115.7.4　合并 37315.8　例：数组反转 37315.8.1　初始模型 37315.8.2　第 一次精化 37415.9　例：链接表反转 37515.9.1　初始模型 37515.9.2　第 一次精化 37615.9.3　第二次精化 37715.9.4　第三次精化 37815.9.5　合并 37815.10　例：计算平方根的简单数值程序 37815.10.1　初始模型 37915.10.2　第 一次精化 37915.10.3　第二次精化 37915.11　例：内射数值函数的逆 38015.11.1　初始模型 38015.11.2　第 一次精化 38115.11.3　第二次精化 38215.11.4　实例化 38315.11.5　第 一次实例化 38315.11.6　第二次实例化 384第 16章　位置访问控制器 38516.1　需求文档 38516.2　讨论 38716.2.1　控制的共享 38716.2.2　闭模型的构造 38716.2.3　设备的行为 38816.2.4　处理安全问题 38816.2.5　同步问题 38816.2.6　边界的功能 38816.3　系统的初始模型 38916.4　第 一次精化 39016.4.1　状态和事件 39016.4.2　无死锁 39116.4.3　第 一个解 39216.4.4　第二个解 39316.4.5　无死锁的修正 39316.5　第二次精化 39416.5.1　状态和事件 39416.5.2　同步 39616.5.3　证明 39616.5.4　读卡器持续阻塞的危险 39616.5.5　避免持续阻塞的提议 39616.5.6　*后的决定 39716.6　第三次精化 39716.6.1　引进读卡器 39716.6.2　与通信网络有关的假设 39816.6.3　变量和不变式 39816.6.4　事件 39916.6.5　同步 40016.6.6　证明 40016.7　第四次精化 40016.7.1　与物理门有关的决策 40016.7.2　变量和不变式：绿色链 40116.7.3　变量和不变式：红色链 40116.7.4　事件 40216.7.5　同步 404第 17章　列车系统 40617.1　非形式的引言 40617.1.1　非形式描述的方法论约定 40717.1.2　行车调度员控制下的轨道网络 40717.1.3　网络的特殊组件：道岔和交叉点 40717.1.4　阻塞的概念 40917.1.5　通路的概念 40917.1.6　信号的概念 41117.1.7　通路和阻塞保持 41217.1.8　安全性条件 41417.1.9　运行条件 41517.1.10　列车的假设 41517.1.11　事故 41617.1.12　实例 41717.2　精化策略 42017.3　初始模型 42017.3.1　状态 42017.3.2　事件 42517.4　第 一次精化 42717.4.1　状态 42717.4.2　事件 42917.5　第二次精化 43117.5.1　状态 43217.5.2　事件 43217.6　第三次精化 43317.6.1　状态 43317.6.2　事件 43317.7　第四次精化 43417.8　总结 43617.9　参考资料 437第 18章　一些问题 43818.1　练习 43818.1.1　银行 43818.1.2　生日记录册 43818.1.3　有一行为0的数值矩阵 43918.1.4　有序矩阵检索 43918.1.5　名人问题 43918.1.6　在两个有交集的有穷数值集合里找公共元素 44018.1.7　简单的访问控制系统 44118.1.8　简单的图书馆 44118.1.9　简单的电路 44118.1.10　闹钟 44218.1.11　连续信号的分析 44218.2　项目 44318.2.1　旅馆的电子钥匙系统 44318.2.2　Earley分析器 44418.2.3　Schorr-Wait算法 44618.2.4　线性表封装 44718.2.5　队列的并发访问 44718.2.6　几乎线性的排序 44818.2.7　终止性检查 44918.2.8　分布式互斥 44918.2.9　电梯 45218.2.10　业务交易协议 45318.3　数学的开发 45418.3.1　良构集合和关系 45418.3.2　不动点 45618.3.3　递归 45718.3.4　传递闭包 45718.3.5　过滤器和超过滤器 45818.3.6　拓扑 45818.3.7　Cantor-Bernstein定理 46018.3.8　Zermelo定理 46018.4　参考资料 462
