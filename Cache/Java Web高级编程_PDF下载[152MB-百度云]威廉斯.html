Java Web高级编程 PDF下载 威廉斯 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730240095
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730240095
<p>书名:Java Web高级编程</p><p>作者:威廉斯</p><p>页数:797</p><p>定价:¥99.8</p><p>出版社:清华大学出版社</p><p>出版日期:2015-06-01</p><p>ISBN:9787302400950</p><p><h2>本书特色</h2></p>[<p>

	提升java编码技能


	　java成为世界上编程语言之一是有其优势的。熟悉java se的程序员可以轻松地进入到java ee开发中，构建出安全、可靠和具有扩展性的企业级应用程序。编写《java web高级编程——涵盖websockets、spring framework、jpa hibernate和spring security》一书的目的正是如此。


	　　本书面向的读者是已经了解java se、sql和基本的html，准备将他们的java编码技能提升到更高水平的程序员。软件开发者可以按顺序阅读本书或者在遇到特定的编程问题时将某个章节用作参考。


	主要内容


	◆ 为企业级web应用的java编码提供了自我指导、自我学习的方法


	◆ 帮助web应用架构师在开发团队的项目中或者开发过程中应用新的概念


	◆ 对java
ee平台7和其中的许多技术提供了详细的介绍


	◆ 讲解了servlet、jsp、websockets、spring
framework、amqp、jpa和o/rm、spring data、全文搜索、apache lucene和hibernate search、spring security和oauth


	◆ 重点介绍java se 8中新增加的常用功能，如lambda表达式和新的jsr 310 java 8 date and time api等


	

                                        </p>]<p><h2>作者简介</h2></p>[<p>
	　Nicholas S. Williams是Java和相关技术领域的一位著名专家。在2010年，他被授予中部田纳西州年度软件工程师的称号。Nick大量参与了开源社区工作，为Apache Log4J、Apache Tomcat、Jackon Mapper、Spring Framework和Spring Security等项目贡献了bug修复、新特性和文档。
</p>]<p><h2>目录</h2></p>
    目    录第ⅰ部分  创建企业级应用程序第1章  介绍java ee平台	31.1  java平台时间线	31.1.1  起始	31.1.2  企业级java的诞生	41.1.3  java se和java ee共同发展	51.1.4  了解*新的平台特性	71.1.5  持续发展	111.2  了解基本的web应用程序结构	111.2.1  servlet、过滤器、监听器和jsp	111.2.2  目录结构和war文件	121.2.3  部署描述符	131.2.4  类加载器架构	141.2.5  企业级应用程序归档文件	141.3  小结	15第2章  使用web容器	172.1  选择web容器	172.1.1  apache tomcat	182.1.2  glassfish	192.1.3  jboss和wildfly	192.1.4  其他容器和应用服务器	202.1.5  本书使用tomcat的原因	202.2  在个人计算机中安装tomcat	212.2.1  将tomcat安装为windows服务	212.2.2  将tomcat安装为命令行应用程序	212.2.3  配置自定义的jsp编译器	232.3  在tomcat中部署和卸载应用程序	242.3.1  手动部署和卸载	242.3.2  使用tomcat管理器	252.4  通过ide调试tomcat	262.4.1  使用intellij idea	272.4.2  使用eclipse	302.5  小结	34第3章  创建**个servlet	353.1  创建servlet类	363.1.1  选择要继承的servlet类	363.1.2  使用初始化方法和销毁方法	383.2  配置可部署的servlet	393.2.1  向描述符中添加servlet	393.2.2  将servlet映射到url	403.2.3  运行和调试servlet	423.3  了解doget、dopost和其他方法	443.3.1  在service方法执行的过程中	443.3.2  使用httpservletrequest	443.3.3  使用httpservletresponse	473.4  使用参数和接受表单提交	493.5  使用初始化参数配置应用程序	533.5.1  使用上下文初始化参数	533.5.2  使用servlet初始化参数	543.6  通过表单上传文件	563.6.1  介绍客户支持项目	563.6.2  配置servlet支持文件上传	563.6.3  接受文件上传	593.7  编写多线程安全的应用程序	603.7.1  理解请求、线程和方法执行	603.7.2  保护共享资源	613.8  小结	62第4章  使用jsp显示页面内容	634.1  使用替代output.println("")	644.1.1  使用jsp的原因	654.1.2  jsp在运行时的处理	664.2  创建**个jsp	674.2.1  了解文件结构	674.2.2  指令、声明、脚本和表达式	694.2.3  注释代码	704.2.4  在jsp中导入类	714.2.5  使用指令	724.2.6  使用标签	754.3  在jsp中使用java(以及不鼓励使用java的原因)	764.3.1  使用jsp中隐式的变量	764.3.2  不应该在jsp中使用java的原因	824.4  结合使用servlet和jsp	824.4.1  配置部署描述符中的jsp属性	824.4.2  将servlet中的请求转发给jsp	854.5  关于jsp文档(jspx)的注意事项	894.6  小结	91第5章  使用会话维持状态	935.1  需要会话的原因	935.1.1  维持状态	945.1.2  记住用户	945.1.3  启动应用程序工作流	945.2  使用会话cookie和url重写	955.2.1  了解会话cookie	965.2.2  url中的会话id	985.2.3  会话的漏洞	1005.3  在会话中存储数据	1025.3.1  在部署描述符中配置会话	1035.3.2  存储和获取数据	1055.3.3  删除数据	1095.3.4  在会话中存储更复杂的数据	1115.4  使用会话	1145.4.1  为客户支持应用程序添加登录功能	1145.4.2  使用监听器检测会话的变化	1185.4.3  维护活跃会话列表	1205.5  将使用会话的应用程序群集化	1245.5.1  在群集中使用会话id	1245.5.2  了解会话复制和故障恢复	1265.6  小结	127第6章  在jsp中使用表达式语言	1296.1  了解表达式语言	1296.1.1  表达式语言的用途	1306.1.2  了解基本语法	1306.1.3  添加el表达式	1326.2  使用el语法	1336.2.1  保留关键字	1336.2.2  操作符优先级	1346.2.3  对象属性和方法	1396.2.4  el函数	1406.2.5  静态字段和方法访问	1416.2.6  枚举	1426.2.7  lambda表达式	1426.2.8  集合	1436.3  在el表达式中使用作用域变量	1446.3.1  使用隐式的el作用域	1456.3.2  使用隐式的el变量	1486.4  使用流api访问集合	1516.4.1  了解中间操作	1516.4.2  使用终结操作	1536.4.3  使用流api	1546.5  使用表达式语言替换java代码	1556.6  小结	157第7章  使用java标准标签库	1597.1  jsp标签和jstl简介	1597.2  使用核心标签库(c命名空间)	1637.2.1  1637.2.2  1647.2.3  1657.2.4  、和1667.2.5  1677.2.6  1687.2.7  1687.2.8  1697.2.9  和1707.2.10  使用核心库标签	1707.3  使用国际化和格式化标签库(fmt命名空间)	1737.3.1  国际化和本地化组件	1737.3.2  1757.3.3  1767.3.4  和1767.3.5  1777.3.6  和1777.3.7  和1787.3.8  和1797.3.9  使用i18n和格式化库标签	1807.4  使用数据库访问标签库(sql命名空间)	1827.5  使用xml处理标签库(x命名空间)	1847.6  使用jsp标签替换java代码	1847.7  小结	186第8章  编写自定义标签和函数库	1898.1  了解tld、标签文件和标签处理器	1898.1.1  读取java标准标签库tld	1908.1.2  比较jsp指令和标签文件指令	1968.2  创建标签文件用作html模板	1988.3  创建日期格式化标签处理器	1998.4  创建el函数简写字符串	2038.5  使用自定义jsp标签替换java代码	2048.6  小结	210第9章  使用过滤器改进应用程序	2119.1  了解过滤器的目的	2119.1.1  日志过滤器	2129.1.2  验证过滤器	2129.1.3  压缩和加密过滤器	2129.1.4  错误处理过滤器	2129.2  创建、声明和映射过滤器	2139.2.1  了解过滤器链	2139.2.2  映射到url模式和servlet名称	2139.2.3  映射到不同的请求派发器类型	2149.2.4  使用部署描述符	2149.2.5  使用注解	2159.2.6  使用编程式配置	2159.3  过滤器排序	2169.3.1  url模式映射和servlet名称映射	2179.3.2  演示过滤器顺序	2189.3.3  使用过滤器处理异步请求	2209.4  调查过滤器的实际用例	2249.4.1  添加简单的日志过滤器	2259.4.2  使用过滤器压缩响应内容	2269.5  使用过滤器简化认证	2309.6  小结	231第10章  在应用程序中使用websocket进行交互	23310.1  演变：从ajax到websocket	23410.1.1  问题：从服务器获得新数据到浏览器	23410.1.2  解决方案1：频繁轮询	23510.1.3  解决方案2：长轮询	23610.1.4  解决方案3：分块编码	23710.1.5  解决方案4：applet和adobe flash	23810.1.6  websocket：一种无人知道但已经存在的解决方案	23910.2  了解websocket api	24210.2.1  html5(javascript)客户端api	24310.2.2  java websocket api	24510.3  使用websocket创建多人游戏	24710.3.1  实现基本的三连棋游戏策略	24710.3.2  创建服务器终端	24810.3.3  编写javascript游戏控制台	25210.3.4  websocket三连棋游戏试玩	25610.4  在群集中使用websocket进行通信	25710.4.1  使用两个servlet实例模拟简单的群集	25710.4.2  发送和接收二进制消息	25910.4.3  测试模拟群集应用程序	26110.5  在客户支持应用程序中添加“支持与客户聊天”功能	26210.5.1  使用编码器和解码器转换消息	26210.5.2  创建聊天服务器终端	26410.5.3  编写javascript聊天应用程序	26710.6  小结	269第11章  使用日志监控应用程序	27111.1  了解日志的概念	27211.1.1  记录日志的原因	27211.1.2  在日志中记录的内容	27311.1.3  日志的写入方式	27411.2  使用日志级别和分类	27611.2.1  使用不同日志级别的原因	27611.2.2  定义的日志级别	27611.2.3  日志分类的工作方式	27711.2.4  筛选的工作方式	27711.3  选择日志框架	27711.3.1  api和实现	27811.3.2  性能	27811.3.3  apache commons logging和slf4j	27911.3.4  log4j 2简介	28011.4  在应用程序中集成日志	28311.4.1  创建log4j 2配置文件	28411.4.2  在web过滤器中使用鱼标签	28711.4.3  在java代码中编写日志语句	28811.4.4  在jsp中使用日志标签库	29011.4.5  客户支持应用程序中的日志	29011.5  小结	291第ⅱ部分  添加spring framework第12章  介绍spring framework	29512.1  spring framework简介	29612.1.1  反转控制和依赖注入	29612.1.2  面向切面编程	29712.1.3  数据访问和事务管理	29712.1.4  应用程序消息	29712.1.5  web应用程序的模型-视图-控制器模式	29812.2  使用spring framework的原因	29812.2.1  逻辑代码分组	29812.2.2  使用同一代码库的多个用户界面	29812.3  了解应用上下文	29912.4  启动spring framework	30012.4.1  使用部署描述符启动spring	30112.4.2  在初始化器中使用编程的方式启动spring	30312.5  配置spring framework	30612.5.1  创建xml配置	30812.5.2  创建混合配置	31012.5.3  使用@configuration配置spring	31412.6  使用bean definition profile	31812.6.1  了解profile的工作原理	31912.6.2  考虑反模式和安全问题	32112.7  小结	322第13章  使用控制器替代servlet	32313.1  了解@requestmapping	32313.1.1  使用@requestmapping特性缩小请求匹配的范围	32413.1.2  指定控制器方法参数	32813.1.3  为控制器方法选择有效的返回类型	33513.2  使用spring framework的模型和视图模式	33713.2.1  使用显式的视图和视图名称	33813.2.2  使用含有模型特性的隐式视图	34013.2.3  返回响应实体	34113.3  使用表单对象简化开发	34613.3.1  在模型中添加表单对象	34713.3.2  使用spring framework标签	34713.3.3  获得被提交的表单数据	34913.4  更新客户支持应用程序	35013.4.1  启用multipart支持	35013.4.2  将servlet转换成spring mvc控制器	35113.4.3  创建自定义下载视图	35213.5  小结	353第14章  使用服务和仓库支持控制器	35514.1  了解模型-视图-控制器模式与控制器-服务-仓库模式	35514.1.1  识别程序逻辑的不同类型	35614.1.2  使用仓库提供持久化逻辑	35714.1.3  使用服务提供业务逻辑	35714.1.4  使用控制器提供用户界面逻辑	35814.2  使用根应用上下文替代web应用上下文	35914.2.1  在多用户界面中重用根应用上下文	35914.2.2  将业务逻辑从控制器移动到服务	36014.2.3  使用仓库存储数据	36414.3  使用异步和计划执行改进服务	36814.3.1  了解执行器和调度器	36914.3.2  配置调度器和异步支持	36914.3.3  创建和使用@async方法	37114.3.4  创建和使用@scheduled方法	37214.4  使用websocket实现逻辑层分离	37314.4.1  在spring应用上下文中添加由容器管理的对象	37314.4.2  使用spring websocket配置器	37514.4.3  记住：websocket只是业务逻辑的另一个界面	37614.5  小结	380第15章  使用spring framework i18n国际化应用程序	38115.1  使用spring framework i18n的原因	38115.1.1  使国际化变得更容易	38215.1.2  直接本地化错误消息	38215.2  使用基本的国际化和本地化api	38215.2.1  了解资源包和消息格式	38315.2.2  使用消息源进行挽救	38515.2.3  使用消息源国际化jsp	38615.3  在spring framework中配置国际化	38715.3.1  创建消息源	38715.3.2  了解区域设置解析器	38815.3.3  使用处理拦截器修改区域设置	39015.3.4  提供一个用户profile区域设置	39015.3.5  包含时区支持	39115.3.6  了解主题如何改进国际化	39215.4  国际化代码	39215.4.1  使用标签	39315.4.2  以更干净的方式处理应用程序错误	39515.4.3  更新客户支持应用程序	39815.4.4  直接使用消息源	39915.5  小结	402第16章  使用jsr 349、spring framework和hibernate validator执行bean验证	40316.1  bean验证的概念	40416.1.1  使用hibernate validator的原因	40516.1.2  了解注解元数据模型	40616.1.3  使用spring framework实现bean验证	40616.2  在spring framework容器中配置验证	40616.2.1  配置spring验证bean	40716.2.2  创建错误代码本地化	40916.2.3  使用方法验证bean后处理器	41016.2.4  在spring mvc中使用相同的验证bean	41116.3  在bean中添加约束验证注解	41116.3.1  了解内建的约束注解	41116.3.2  了解常见的约束特性	41216.3.3  使用约束	41316.3.4  使用@valid实现递归验证	41516.3.5  使用验证组	41616.3.6  在编译时检查约束合法性	41716.4  为方法验证配置spring bean	41816.4.1  标注接口，而非实现	41816.4.2  在方法参数上使用限制和递归验证	41916.4.3  验证方法返回值	42016.4.4  表示一个类是否适用于方法验证	42016.4.5  在spring mvc控制器中使用参数验证	42116.4.6  为用户显示验证错误	42316.5  编写自己的验证约束	42516.5.1  在自定义限制中继承其他限制	42516.5.2  创建限制验证器	42616.5.3  了解限制验证器的生命周期	42816.6  在客户支持应用程序中集成验证	42916.7  小结	431第17章  创建restful和soap web服务	43317.1  了解web服务	43317.1.1  *初的soap	43417.1.2  restful web服务提供了一种更简单的方式	43517.2  在spring mvc中配置restful web服务	44217.2.1  使用原型注解分离控制器	44217.2.2  创建单独的web和rest应用上下文	44317.2.3  处理restful web服务中的错误条件	44617.2.4  将restful请求映射到控制器方法	44917.2.5  使用索引终端改进发现机制	45317.3  测试web服务终端	45417.3.1  选择测试工具	45417.3.2  请求web服务	45517.4  使用spring web service创建soap web服务	45717.4.1  编写契约优先的xsd和wsdl	45817.4.2  添加soap派发器servlet配置	46017.4.3  创建soap终端	46217.5  小结	465第18章  使用消息传送和群集实现灵活性和可靠性	46718.1  识别需要消息传送和群集的时机	46718.1.1  应用程序消息传送的定义	46818.1.2  群集的定义	47018.1.3  消息传送和群集的协作方式	47418.2  为应用程序添加消息传送支持	47718.2.1  创建应用程序事件	47718.2.2  订阅应用程序事件	47818.2.3  发布应用程序事件	47918.3  在群集中分布消息传送	48118.3.1  更新事件以支持分布	48218.3.2  创建并配置一个自定义事件多播器	48318.3.3  使用websocket发送和接收事件	48518.3.4  通过多播数据包发现节点	48718.3.5  部署多个应用程序模拟群集	48918.4  使用amqp分布事件	49018.4.1  配置amqp代理	49118.4.2  创建amqp多播器	49218.4.3  运行使用了amqp的应用程序	49418.5  小结	495第ⅲ部分  使用jpa和hibernate      orm持久化数据第19章  介绍java persistence api和 hibernate orm	49919.1  数据持久化的定义	49919.1.1  平面文件实体存储	50019.1.2  结构化文件存储	50019.1.3  关系数据库系统	50119.1.4  面向对象数据库	50119.1.5  无模式数据库系统	50219.2  对象-关系映射的定义	50219.2.1  了解持久化实体的问题	50319.2.2  o/rm使实体持久化更简单	50419.2.3  jpa提供了一种标准o/rm api	50519.3  使用hibernate orm的原因	50719.4  hibernate orm简介	50719.4.1  使用hibernate映射文件	50719.4.2  了解会话api	50919.4.3  从sessionfactory中获得会话	51119.4.4  使用spring framework创建sessionfactory	51219.5  准备关系数据库	51319.5.1  安装mysql和mysql workbench	51319.5.2  安装mysql jdbc驱动	51519.5.3  在tomcat中创建连接资源	51619.5.4  注意maven依赖	51719.6  小结	517第20章  使用jpa注解将实体映射到表	51920.1  使用简单实体	52020.1.1  创建实体并将它映射到表	52120.1.2  指示jpa使用实体字段的方式	52320.1.3  映射代理键	52320.1.4  使用基本数据类型	52920.1.5  指定列名和其他细节	53220.2  创建和使用持久化单元	53420.2.1  设计数据库表	53420.2.2  了解持久化单元作用域	53620.2.3  创建持久化配置	53620.2.4  使用持久化api	53920.3  映射复杂数据类型	54320.3.1  使用枚举作为实体属性	54320.3.2  了解jpa如何处理日期和时间	54420.3.3  将大属性映射为clob和blob	54620.4  小结	548第21章  在spring framework仓库中使用jpa	54921.1  使用spring仓库和事务	55021.1.1  了解事务范围	55021.1.2  为事务和实体管理器使用线程	55121.1.3  使用异常转换	55221.2  在spring framework中配置持久化	55321.2.1  查找数据源	55321.2.2  在代码中创建持久化单元	55421.2.3  创建事务管理	55721.3  创建和使用jpa仓库	56021.3.1  注入持久化单元	56021.3.2  实现标准crud操作	56121.3.3  为所有的实体创建一个基础仓库	56321.3.4  在服务中标记事务范围	56821.3.5  使用事务服务方法	57221.4  在dto和实体之间转换数据	57321.4.1  为客户支持应用程序创建实体	574 	21.4.2  使用bcrypt保护用户密码	578 21.4.3  在服务中将数据传输到实体中	57921.5  小结	581第22章  使用spring data jpa消除公式化的仓库	58322.1  了解spring data的统一数据访问	58422.1.1  避免代码重复	58422.1.2  使用stock仓库接口	58722.1.3  为搜索实体创建查询方法	58822.1.4  提供自定义方法实现	59122.2  配置和创建spring data jpa仓库	59422.2.1  启用仓库自动生成	59522.2.2  编写和使用spring data jpa接口	60122.3  重构客户支持应用程序	60322.3.1  转换现有仓库	60322.3.2  在支持票据中添加评论	60522.4  小结	609第23章  使用jpa和hibernate search搜索数据	61123.1  搜索介绍	61223.1.1  了解索引的重要性	61223.1.2  采取三种不同的方式	61323.2  使用高级条件定位对象	61423.2.1  创建复杂条件查询	61423.2.2  在查询中使用or	62123.2.3  创建有用的索引改进性能	62223.3  使用jpa的全文索引	62323.3.1  在mysql表中创建全文索引	62423.3.2  创建和使用可搜索的仓库	62523.3.3  使全文搜索可迁移	63023.4  使用apache lucene和hibernate search索引任意数据	63023.4.1  了解lucene全文索引	63123.4.2  使用索引元数据标注实体	63223.4.3  结合使用hibernate search和jpa	63423.5  小结	637第24章  创建高级映射和自定义数据类型	63924.1  jpa的相关内容	63924.2  转换非标准数据类型	64024.2.1  了解特性转换器	64124.2.2  了解转换注解	64224.2.3  创建和使用特性转换器	64324.3  在实体中内嵌pojo	64524.3.1  表示嵌套的类型	64524.3.2  使属性成为可嵌入属性	64524.3.3  覆盖可内嵌列列名	64724.4  定义实体间的关系	64824.4.1  了解一对一关系	64824.4.2  使用一对多和多对一关系	65024.4.3  创建多对多关系	65324.5  处理其他常见的情况	65424.5.1  使用修订和时间戳版本化实体	65424.5.2  定义公共属性的抽象实体	65524.5.3  映射基本的和内嵌的集合	65624.5.4  持久化含有键值对的map	65924.5.5  在多个表中存储实体	66024.6  创建编程式触发器	66124.6.1  在crud操作之前或之后执行	66124.6.2  使用实体监听器	66324.7  简化客户支持应用程序	66424.7.1  映射附件的集合	66424.7.2  使用加载时织入延迟加载简单属性	66624.8  小结	669第ⅳ部分  使用spring security保护应用程序第25章  介绍spring security	67325.1  认证的概念	67325.1.1  集成认证	67425.1.2  了解授权	68225.2  选择spring security的原因	68525.2.1  了解spring security基础	68625.2.2  使用spring security的授权服务	68625.2.3  配置spring security	68725.3  小结	687第26章  使用spring security验证用户	68926.1  选择并配置认证提供者	69026.1.1  配置用户细节提供者	69026.1.2  使用ldap和活动目录提供者	70026.1.3  使用openid进行认证	70326.1.4  remember-me认证	70526.1.5  学习其他认证提供者	70626.2  编写自己的认证提供者	70726.2.1  以正确的顺序启动	70726.2.2  创建和配置提供者	71026.2.3  缓解跨站请求伪装攻击	71526.3  小结	718第27章  使用授权标签和注解	71927.1  通过声明进行授权	71927.1.1  在方法代码中检查权限	72027.1.2  采用url安全	72227.1.3  使用注解声明权限	72527.1.4  定义方法切点规则	73227.2  了解授权决策	73327.2.1  使用访问决策投票者	73327.2.2  使用访问决策管理器	73427.3  为对象安全创建访问控制列表	73627.3.1  了解spring security的acl	73627.3.2  配置访问控制列表	73827.3.3  为实体填充acl	74027.4  在客户支持应用程序中添加授权	74127.4.1  切换到自定义用户细节	74227.4.2  保护服务方法	74627.4.3  使用spring security的标签库	75027.5  小结	751第28章  使用oauth保护restful web服务	75328.1  了解web服务安全	75428.1.1  比较web gui和web服务安全	75428.1.2  选择认证机制	75428.2  介绍oauth	75628.2.1  了解关键参与者	75628.2.2  起始：oauth 1.0	75728.2.3  标准：oauth 1.0a	75728.2.4  演化：oauth 2.0	76228.3  使用spring security oauth	76928.3.1  创建oauth 2.0提供者	76928.3.2  创建oauth 2.0客户端	77328.4  完成客户端支持应用程序	77528.4.1  生成请求随机数和签名	77628.4.2  实现客户端服务	77728.4.3  实现随机数服务	78028.4.4  实现令牌服务	78228.4.5  自定义资源服务器过滤器	78528.4.6  重新配置spring security	78728.5  创建oauth客户端应用程序	79128.5.1  自定义rest模板	79228.5.2  配置spring security oauth客户端	79328.5.3  使用rest模板	79528.5.4  同时测试提供者和客户端	79628.6  小结	797   
