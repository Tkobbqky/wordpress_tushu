Oracle PL/SQL程序设计-(上.下册)-第6版 PDF下载 史蒂芬.弗伊尔斯坦 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711544875
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711544875
<p>书名:Oracle PL/SQL程序设计-(上.下册)-第6版</p><p>作者:史蒂芬.弗伊尔斯坦</p><p>页数:1086</p><p>定价:¥188.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-07-01</p><p>ISBN:9787115448750</p><p><h2>本书特色</h2></p>[<p>
《Oracle PL SQL程序设计（第6版）》基于Oracle数据库12C，从用PL SQL编程、PL SQL程序结构、PL SQL程序数据、PL SQL中的SQL、构造PL SQL应用程序、高级PL SQL主题这6个方面详细而系统地讨论了PL SQL以及如何有效地使用它。本书能够帮助你充分利用PL SQL来解决数据库开发中遇到的各种问题，引导你掌握各种构建应用的技巧和技术，以便使你编写出高效、可维护的代码。本书不但介绍了大量Oracle数据库12C的PL SQL新性能，还提供了许多优化PL SQL性能的新方法。
《Oracle PL SQL程序设计（第6版）》结构清晰，示例丰富，实践性强，适用于Oracle数据库开发人员、Oracle数据库管理员等相关数据库从业人员，也可以作为各大、中专院校相关专业师生的参考用书和相关培训机构的培训教材。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书在Oracle社区中被公认为是zui好的Oracle PL SQL程序设计权V指南。如果想要充分利用PL SQL，本书无疑是绝佳的资源。本书第6版全面讲解了PL SQL的特性和功能，涵盖了直到Oracle数据库12c R1版本发生的新变化。
在过去20多年，成千上万的PL SQL程序开发人员从本书中受益，这次的新版延续了之前的风格，提供了丰富的代码示例，穿插了程序开发人员才能看懂的小幽默。本书介绍了PL SQL语言的基础知识、高级编码技巧，并提供了zui佳实践来帮助大家解决真实世界中的问题。
本书讲解了如下内容：
借助于有关执行、跟踪、调试和管理代码的清晰指导，快速编写和运行PL SQL程序；
学习12.1版本的新特性，包括ACCESIBLE_BY子句、WITH FUNCTION和UDF杂注以及视图的BEQUEATH CURRENT_USER权限；
充分利用书中提供的大量代码示例（从易于遵循的示例到可重用的打包工具，不一而足）；
使用诸如PL Scope和PL SQL分层配置文件等Oracle工具，以及像函数结果缓存这样的特性，优化PL SQL的性能；
使用程序包、过程、函数和触发器来构建模块化、易维护的PL SQL应用程序。 </p>]<p><h2>作者简介</h2></p>[<p>Steven Feuerstein被尊为Oracle PL SQL语言的世界ji专家领袖。他是本书上一版、Oracle PL SQL Best Practices、Oracle PL SQL Programming: Guide to Oracle8i Features、Oracle PL SQL Developer’s Workbook、Oracle Built-in Package、Advanced Oracle PL SQL Programming with Packages以及多本口袋参考书（均由O’Reilly Media出版）的作者或合著者。Steven还是Quest Software的zi深技术顾问，从1980年就开始从事软件的开发工作，并于1987～1992年在Oracle公司工作。
Bill Pribyl是Learning Oracle PL SQL的主要作者、本书上一版以及配套口袋参考书（均由O’Reilly Media出版）的合著者。目前他在一家国际贸易公司内担任一个编程小组的负责人。Bill曾经使用PL SQL编写TCP IP网络客户端、tnsping呼出工具、近于实时的商品价格加载器以及超越函数等。Bill拥有Rice大学的物理学学位。在业余时间里，Bill的大部分精力都用来照顾罹患炎性乳腺癌的妻子。</p>]<p><h2>目录</h2></p>
    目录（上）

第1部分　用PL SQL编程
第1章　PL SQL介绍	3
1.1　什么是PL SQL	3
1.2　PL SQL的起源	4
1.2.1　早期的PL SQL	4
1.2.2　提高应用的可移植性	4
1.2.3　提高执行权限控制和交易
完整性	5
1.2.4　低调开始，持续改进	5
1.3　这就是PL SQL	6
1.3.1　与SQL的集成	6
1.3.2　控制和条件逻辑	7
1.3.3　出错处理	8
1.4　关于PL SQL版本	9
1.4.1　Oracle数据库12c中PL SQL
的新特性	10
1.5　可供PL SQL开发者使用的
资源	12
1.5.1　O’Reilly的PL SQL系列图书	13
1.5.2　网络上的PL SQL资源	14
1.6　一些建议	15
1.6.1　别急，慢慢来	15
1.6.2　不要畏惧寻求帮助	16
1.6.3　采用有创造性的甚至激进的
方法	17
第2章　创建和运行PL SQL
代码	18
2.1　在数据库中导航	18
2.2　创建和编辑源代码	19
2.3　SQL*Plus	19
2.3.1　启动SQL*Plus	21
2.3.2　运行SQL语句	22
2.3.3　运行PL SQL程序	22
2.3.4　运行一个脚本	24
2.3.5　什么是“当前目录”	24
2.3.6　其他SQL*Plus任务	25
2.3.7　SQL*Plus中的异常处理	29
2.3.8　为什么SQL*Plus让我们
又爱又恨	30
2.4　执行基本的PL SQL任务	30
2.4.1　创建存储程序	31
2.4.2　执行存储的程序	33
2.4.3　显示存储程序	34
2.4.4　存储程序的授权和别名	35
2.4.5　删除一个存储程序	36
2.4.6　隐藏存储程序的源代码	36
2.5　编辑PL SQL的环境	37
2.6　从其他语言中调用PL SQL	37
2.6.1　C语言，使用Oracle预编辑器
（Pro*C）	38
2.6.2　Java：使用JDBC	39
2.6.3　Perl：使用Perl DBI和DBD::
Oracle	40
2.6.4　PHP：使用Oracle扩展	41
2.6.5　PL SQL Server Pages	42
2.6.6　其他	43
第3章　语言基础	44
3.1　PL SQL块结构	44
3.1.1　匿名块	46
3.1.2　命名块	47
3.1.3　嵌套块	47
3.1.4　作用范围	48
3.1.5　规范SQL语句中对变量和
列的引用	49
3.1.6　可见性	51
3.2　PL SQL字符集	54
3.3　标识符	56
3.3.1　保留字	57
3.3.2　空白和关键字	58
3.4　直接量	59
3.4.1　NULL	60
3.4.2　在一个直接量字符串中嵌入
单引号	61
3.4.3　数字直接量	61
3.4.4　布尔直接量	62
3.5　分号分隔符	62
3.6　注释	63
3.6.1　单行注释语法	63
3.6.2　多行注释语法	63
3.7　PRAGMA关键字	64
3.8　标签	65
第2部分　PL SQL程序结构 
第4章　条件与顺序控制	69
4.1　IF语句	69
4.1.1　IF-THEN组合	69
4.1.2　IF-THEN-ELSE的组合	71
4.1.3　IF-THEN-ELSIF组合	73
4.1.4　避免IF语法陷阱	73
4.1.5　嵌套的IF语句	75
4.1.6　短路估算	75
4.2　CASE语句和表达式	77
4.2.1　简单的CASE语句	77
4.2.2　搜索CASE语句	79
4.2.3　嵌套CASE语句	81
4.2.4　CASE表达式	81
4.3　GOTO语句	83
4.4　NULL语句	84
4.4.1　提高程序的可读性	84
4.4.2　在标签后使用NULL	84
第5章　循环迭代处理	86
5.1　循环的基础知识	86
5.1.1　不同循环的示例	86
5.1.2　PL SQL循环的结构	88
5.2　简单循环	89
5.2.1　终止简单循环：EXIT
和EXIT WHEN	89
5.2.2　模仿REPEAT UNTIL循环	90
5.2.3　故意的无限循环	91
5.3　WHILE循环	92
5.4　数值型FOR循环	93
5.4.1　数值型FOR循环的规则	94
5.4.2　数值型FOR循环的示例	94
5.4.3　处理特殊增量	95
5.5　游标FOR循环	96
5.5.1　游标FOR循环的示例	97
5.6　循环标签	98
5.7　CONTINUE语句	99
5.8　迭代处理技巧	102
5.8.1　为循环索引使用可理解的
名称	102
5.8.2　以正确的方式说再见	102
5.8.3　获取FOR循环执行的信息	103
5.8.4　循环SQL语句	104
第6章　异常处理	106
6.1　异常处理概念和术语	106
6.2　定义异常	108
6.2.1　声明命名异常	108
6.2.2　关联异常名称与错误代码	109
6.2.3　命名的系统异常	112
6.2.4　异常作用范围	114
6.3　引发异常	115
6.3.1　RAISE语句	115
6.3.2　使用RAISE_APPLICATION_
ERROR	116
6.4　处理异常	117
6.4.1　内置错误函数	118
6.4.2　单一处理句柄中结合多个
异常	122
6.4.3　未处理异常	123
6.4.4　未处理异常的传播	123
6.4.5　继续过去的异常	125
6.4.6　编写WHEN OTHERS处理
代码	127
6.5　构建有效的错误管理架构	129
6.5.1　确定我们的异常管理策略	129
6.5.2　对不同类型异常进行标准化
处理	130
6.5.3　程序特定错误代码的组织
使用	133
6.5.4　使用标准的错误管理程序	133
6.5.5　使用自己的异常“对象”	135
6.5.6　创建常见错误处理的标准
模板	137
6.6　充分利用PL SQL错误
管理	138
第3部分　PL SQL程序数据
第7章　使用程序数据	141
7.1　程序数据的命名	141
7.2　PL SQL数据类型概述	143
7.2.1　字符数据	143
7.2.2　数字	144
7.2.3　日期、时间戳和时间间隔	145
7.2.4　布尔类型	145
7.2.5　二进制数据类型	146
7.2.6　ROWID	146
7.2.7　REF CURSOR	146
7.2.8　Internet数据类型	147
7.2.9  “Any”数据类型	147
7.2.10　用户自定义数据类型	147
7.3　程序数据的声明	147
7.3.1　声明一个变量	148
7.3.2　声明常量	148
7.3.3　NOT NULL语句	149
7.3.4　锚定声明	149
7.3.5　游标和表的锚	151
7.3.6　使用锚定声明的益处	152
7.3.7　NOT NULL数据类型的锚	153
7.4　程序员定义的子类型	153
7.5　数据类型转换	154
7.5.1　隐式类型转换	155
7.5.2　显式类型转换	156
第8章　字符串	162
8.1　字符串类型	162
8.1.1　VARCHAR2数据类型	163
8.1.2　CHAR数据类型	164
8.1.3　String子类型	164
8.2　使用字符串	165
8.2.1　指定字符串常量	165
8.2.2　不可打印字符	167
8.2.3　拼接字符串	168
8.2.4　处理大小写	169
8.2.5　传统的检索、提取和替换	172
8.2.6　填充	174
8.2.7　剪裁	176
8.2.8　正则表达式的检索、提取和
替换	177
8.2.9　使用空字符串	187
8.2.10　混用CHAR和
VARCHAR2	188
8.3　字符串函数快速参考	190
第9章　数字	199
9.1　数值型数字类型	199
9.1.1　NUMBER类型	200
9.1.2　PLS_INTEGER类型	204
9.1.3　BINARY_INTEGER类型	205
9.1.4　SIMPLE_INTEGER类型	205
9.1.5　BINARY_FLOAT和
BINARY_DOUBLE类型	207
9.1.6　SIMPLE_FLOAT和
SIMPLE_DOUBLE类型	212
9.1.7　数字子类型	212
9.2　数字转换	213
9.2.1　TO_NUMBER函数	213
9.2.2　TO_CHAR函数	216
9.2.3　CAST函数	221
9.2.4　隐式转换	222
9.3　数字运算符	224
9.4　数字函数	224
9.4.1　四舍五入和截断函数	224
9.4.2　三角函数	225
9.4.3　数字函数的快速参考	225
第10章　日期和时间戳	230
10.1　Datetime数据类型	230
10.1.1　声明日期时间变量	233
10.1.2　选择日期时间数据类型	233
10.2　获取当前日期和时间	234
10.3　INTERVAL数据类型	236
10.3.1　声明INTERVAL变量	237
10.3.2　什么时候使用INTERVAL	238
10.4　日期时间转换	240
10.4.1　从字符串到日期时间	240
10.4.2　从日期时间到字符串	242
10.4.3　使用时区	245
10.4.4　精确匹配需要格式掩码	247
10.4.5　让精确匹配更轻松	248
10.4.6　解释滑动窗口中两位数字的
年份	248
10.4.7　把时区转换成字符串	249
10.4.8　用填充模式把输出补齐	250
10.5　日期和时间戳直接量	251
10.6　时间间隔的转换	252
10.6.1　从数字到时间间隔的转换	252
10.6.2　把字符串转换成间隔	253
10.6.3　时间间隔的格式化显示	254
10.7　时间间隔直接量	254
10.8　CAST和EXTRACT	256
10.8.1　CAST函数	256
10.8.2　EXTRACT函数	258
10.9　日期时间的算法	258
10.9.1　时间间隔和日期时间的
算法	259
10.9.2　DATE数据类型的日期
算法	260
10.9.3　计算两个日期时间之间的
时间间隔	260
10.9.4　DATE和TIMESTAMP混合
计算	262
10.9.5　时间间隔的加减运算	263
10.9.6　时间间隔的乘除运算	264
10.9.7　使用不受限制的时间间隔
类型	264
10.10　日期 时间函数的快速
参考	266
第11章　记录类型	269
11.1　PL SQL中的记录	269
11.1.1　使用记录的好处	270
11.1.2　声明记录	271
11.1.3　程序员自定义的记录类型	273
11.1.4　使用记录类型	275
11.1.5　记录的比较	281
11.1.6　触发器伪记录	282
第12章　集合	284
12.1　集合概述	285
12.1.1　集合概念和术语	285
12.1.2　集合类型	287
12.1.3　集合示例	288
12.1.4　使用集合的场合	291
12.1.5　选择一个集合类型	296
12.2　集合方法（内置）	297
12.2.1　COUNT方法	298
12.2.2　DELETE方法	299
12.2.3　EXISTS方法	300
12.2.4　EXTEND方法	300
12.2.5　FIRST和LAST方法	301
12.2.6　LIMIT方法	302
12.2.7　PRIOR和NEXT方法	303
12.2.8　TRIM方法	304
12.3　使用集合	305
12.3.1　声明集合类型	306
12.3.2　集合变量的声明和初始化	310
12.3.3　用数据填充集合	313
12.3.4　访问集合内的数据	318
12.3.5　使用字符串索引的集合	319
12.3.6　复杂数据类型的集合	324
12.3.7　多级集合	327
12.3.8　在SQL中使用集合	335
12.4　嵌套表的多重集合操作	342
12.4.1　测试嵌套表是否相等及成员
归属	343
12.4.2　检查元素是否是嵌套表的
成员	344
12.4.3　执行高级别集合操作	345
12.4.4　嵌套表中的去重	346
12.5　schema级别集合的维护	347
12.5.1　必需的权限	347
12.5.2　集合和数据字典	348
第13章　其他数据类型	349
13.1　BOOLEAN类型	349
13.2　RAW数据类型	350
13.3　UROWID和ROWID数据
类型	351
13.3.1　获取ROWID	352
13.3.2　使用ROWID	352
13.4　LOB数据类型	353
13.5　使用LOB	354
13.5.1　理解LOB定位符	356
13.5.2　LOB的空和NULL	357
13.5.3　向LOB中写入数据	359
13.5.4　读取LOB数据	361
13.5.5　BFILE的不同之处	363
13.5.6　SecureFiles和BasicFiles	367
13.5.7　临时LOB	369
13.5.8　原生的LOB操作	372
13.5.9　LOB转换函数	376
13.6　预定义的对象类型	376
13.6.1　XMLType类型	376
13.6.2　URI类型	379
13.6.3　Any类型	381
第4部分　PL SQL中的SQL
第14章　DML和事务管理	387
14.1　PL SQL中的DML	388
14.1.1　DML简介	388
14.1.2　DML操作符的游标属性	391
14.1.3　从DML语句返回信息	392
14.1.4　DML和异常处理	393
14.1.5　DML和记录	394
14.2　事务管理	397
14.2.1　COMMIT语句	397
14.2.2　ROLLBACK语句	398
14.2.3　SAVEPOINT语句	399
14.2.4　SET TRANSACTION语句	399
14.2.5　LOCK TABLE语句	400
14.3　自治事务	400
14.3.1　定义自治事务	401
14.3.2　自治事务的规则和限制	402
14.3.3　事务的可见性	403
14.3.4　何时使用自治事务	403
14.3.5　创建自治日志记录机制	404
第15章　数据提取	407
15.1　游标基础	408
15.1.1　一些数据提取术语	408
15.1.2　典型的查询操作	410
15.1.3　游标属性介绍	411
15.1.4　在游标中引用PL SQL
变量	413
15.1.5　显式与隐式游标之间的
选择	414
15.2　使用隐式游标	414
15.2.1　隐式游标示例	415
15.2.2　隐式游标的异常处理	416
15.2.3　隐式SQL游标的属性	418
15.3　使用显式游标	419
15.3.1　声明显式游标	420
15.3.2　打开显式游标	423
15.3.3　从显式游标获取	424
15.3.4　显式游标中的列别名	425
15.3.5　关闭显式游标	426
15.3.6　显式游标属性	427
15.3.7　游标参数	429
15.4　SELECT…FOR UPDATE	432
15.4.1　COMMIT释放锁定	433
15.4.2　WHERE CURRENT
OF子句	434
15.5　游标变量和REF
CURSOR	435
15.5.1　为什么使用游标变量	436
15.5.2　与静态游标的相似之处	437
15.5.3　声明REF CURSOR类型	437
15.5.4　声明游标变量	438
15.5.5　打开游标变量	439
15.5.6　从游标变量中提取数据	440
15.5.7　游标变量的使用规则	442
15.5.8　将游标变量作为参数传递	445
15.5.9　游标变量的约束限制	447
15.6　游标表达式	447
15.6.1　使用游标表达式	448
15.6.2　游标表达式的约束限制	450
第16章　动态SQL和动态
PL SQL	451
16.1　NDS语句	452
16.1.1　EXECUTE IMMEDIATE
语句	452
16.1.2　OPEN FOR语句	455
16.1.3　4种动态SQL方法	460
16.2　绑定变量	462
16.2.1　参数模式	463
16.2.2　重复的占位符	465
16.2.3　传递NULL值	465
16.3　使用对象和集合	466
16.4　动态PL SQL	468
16.4.1　建立动态PL SQL块	469
16.4.2　用动态块替换重复代码	470
16.5　NDS建议	471
16.5.1　对共享程序使用调用者
权限	471
16.5.2　预测并处理动态错误	472
16.5.3　使用绑定而非拼接	474
16.5.4　减少代码注入的危险	475
16.6　何时使用DBMS_SQL	478
16.6.1　获得查询列信息	478
16.6.2　实现第四种方法的动态
SQL需求	479
16.6.3　*小化动态游标解析	485
16.6.4　Oracle数据库11g新动态
SQL特性	486
16.6.5　DBMS_SQL增强安全	490 

目录（下）
第5部分　构造PL SQL应用程序 
第17章　过程、函数和参数	497
17.1　代码模块化	497
17.2　过程	499
17.2.1　调用一个过程	501
17.2.2　过程头部	501
17.2.3　过程体	501
17.2.4　END标签	502
17.2.5　RETURN语句	502
17.3　函数	502
17.3.1　函数的结构	503
17.3.2　返回的数据类型	504
17.3.3　END标签	506
17.3.4　调用函数	506
17.3.5　不带参数的函数	507
17.3.6　函数头	508
17.3.7　函数体	508
17.3.8　RETURN语句	509
17.4　参数	510
17.4.1　定义参数	511
17.4.2　实参和形参	511
17.4.3　参数模式	512
17.4.4　在PL SQL中显式地关联
实参和形参	515
17.4.5　NOCOPY参数模式限定符	519
17.4.6　缺省值	519
17.5　局部或者嵌套模块	520
17.5.1　使用局部模块的益处	521
17.5.2　局部模块的作用范围	523
17.5.3　用局部模块使得代码更
整洁	524
17.6　模块的重载	524
17.6.1　重载的益处	525
17.6.2　重载的限制	528
17.6.3　数字类型的重载	528
17.7　前置声明	529
17.8　高级主题	530
17.8.1　在SQL内部调用我们的
函数	530
17.8.2　表函数	536
17.8.3　确定性函数	545
17.8.4　隐式游标结果（Oracle
数据库12c）	546
17.9　将模块化进行到底	547
第18章　程序包	548
18.1　为什么使用程序包	548
18.1.1　演示程序包的能力	549
18.1.2　与程序包相关的一些概念	552
18.1.3　图示私有性	553
18.2　构建程序包的规则	554
18.2.1　程序包说明	554
18.2.2　包体	555
18.2.3　包的初始化	557
18.3　包元素的调用规则	561
18.4　使用包数据	562
18.4.1　在一个Oracle会话内全局
可见	562
18.4.2　全局公有数据	563
18.4.3　包游标	563
18.4.4　包的串行化	568
18.5　何时使用包	570
18.5.1　封装对数据的访问	570
18.5.2　避免直接量的硬编码	573
18.5.3　提高内置特性的可用性	575
18.5.4　把逻辑上相关的功能组织
在一起	576
18.5.5　缓存静态的会话数据	576
18.6　包和对象类型	577
第19章　触发器	578
19.1　DML触发器	579
19.1.1　DML触发器的概念	580
19.1.2　创建DML触发器	581
19.1.3　DML触发器的例子：严禁
作弊！	586
19.1.4　同一类型的多个触发器	591
19.1.5　如何对触发顺序排序	592
19.1.6　突变表的错误	594
19.1.7　复合触发器：聚在一处	595
19.2　DDL触发器	598
19.2.1　创建DDL触发器	598
19.2.2　可用事件	600
19.2.3　可用属性	601
19.2.4　使用事件和属性	602
19.2.5　删除不可删除的	606
19.2.6　INSTEAD OFCREATE
触发器	606
19.3　数据库事件触发器	607
19.3.1　创建数据库事件触发器	608
19.3.2　STARTUP触发器	609
19.3.3　SHUTDOWN触发器	610
19.3.4　LOGON触发器	610
19.3.5　LOGOFF触发器	610
19.3.6　SERVERERROR触发器	611
19.4　INSTEAD OF触发器	615
19.4.1　创建INSTEAD OF触发器	615
19.4.2　INSTEAD OF INSERT
触发器	616
19.4.3　INSTEAD OF UPDATE
触发器	618
19.4.4　INSTEAD OF DELETE
触发器	619
19.4.5　填充表	619
19.4.6　嵌套表的lNSTEAD OF
触发器	620
19.5　AFTER SUSPEND触发器	621
19.5.1　建立AFTER SUSPEND
触发器	622
19.5.2　看看真实的触发器	623
19.5.3　ORA_SPACE_ERROR_lNFO
函数	624
19.5.4　DBMS_RESUMABLE包	625
19.5.5　捕获多个时间	626
19.5.6　是否该处理？	627
19.6　维护触发器	628
19.6.1　禁用、启用以及删除
触发器	628
19.6.2　创建一个禁用的触发器	628
19.6.3　查看触发器	629
19.6.4　检查触发器的有效性	630
第20章　管理PL SQL代码	631
20.1　管理数据库内的代码	632
20.1.1　数据字典视图概述	632
20.1.2　显示存储对象的信息	634
20.1.3　源代码的显示和搜索	635
20.1.4　根据程序的大小确定Pinning
需求	637
20.1.5　获得存储代码的属性	637
20.1.6　通过视图分析和更改触发器
状态	638
20.1.7　分析参数信息	639
20.1.8　分析标识符的使用（Oracle
数据库11g的PL Scope）	640
20.2　管理依赖关系及重编译
代码	643
20.2.1　通过数据字典视图分析依赖
关系	643
20.2.2　细粒度依赖（Oracle
数据库11g）	647
20.2.3　远程依赖	648
20.2.4　Oracle的远程调用模式的
限制	650
20.2.5　重编译无效的程序单元	651
20.3　编译时刻警告	655
20.3.1　一个快速示例	655
20.3.2　开启编译时刻告警	656
20.3.3　一些有用的警告	657
20.4　测试PL SQL程序	664
20.4.1　典型的、华而不实的测试
技术	665
20.4.2　PL SQL代码测试的一般
建议	668
20.4.3　PL SQL的自动测试选项	669
20.5　跟踪PL SQL的执行	670
20.5.1　DBMS_UTILITY.FORMAT_
CALL_STACK	671
20.5.2　UTL_CALL_STACK（Oracle 
数据库12c）	673
20.5.3　DBMS_APPLICATION_
INFO	676
20.5.4　使用opp_trace进行跟踪	677
20.5.5　DBMS_TRACE工具包	678
20.6　PL SQL程序的调试	681
20.6.1　错误的调试方法	682
20.6.2　调试技巧和策略	683
20.7　使用白名单来控制对程序
单元的访问	687
20.8　存储代码的保护	689
20.8.1　封装的约束和局限	690
20.8.2　使用封装程序	690
20.8.3　使用DBMS_DDL进行动态
封装	690
20.8.4　封装代码的使用指导	691
20.9　基于版本的重定义（Oracle
数据库11g R2版本）	692
第21章　PL SQL的性能优化	695
21.1　辅助优化的工具	696
21.1.1　内存使用分析	696
21.1.2　发现PL SQL代码中的瓶颈	697
21.1.3　计算花费时间	701
21.1.4　选择*快的程序	703
21.1.5　避免无限循环	704
21.1.6　性能相关的警告	706
21.2　优化编译器	706
21.2.1　优化器工作原理	707
21.2.2　循环Fetch操作的运行
时优化	710
21.3　数据缓存技术	710
21.3.1　基于包的缓存	711
21.3.2　确定性函数的缓存	716
21.3.3　函数结果缓存（Oracle
数据库11g）	718
21.3.4　缓存总结	731
21.4　重复的SQL的语句批
处理	732
21.4.1　通过BULK COLLECT加速
查询	733
21.4.2　使用FORALL加速DML	739
21.5　利用管道化的表函数提升
性能	749
21.5.1　用基于管道化函数的加载
方式替换基于行的插入	750
21.5.2　用管道函数调优Merge
操作	756
21.5.3　用并行管道函数进行异步
数据导出	758
21.5.4　并行管道函数中的分区和
流子句对性能的影响	761
21.5.5　管道函数和基于成本的
优化器	763
21.5.6　用管道函数优化负载的数据
加载	768
21.5.7　管道函数结束语	775
21.6　专用的优化技术	775
21.6.1　使用NOCOPY参数模式
提示符	775
21.6.2　使用正确的数据类型	778
21.6.3　SQL（12.1及更高版本）的
函数性能优化	779
21.7　性能回顾	780
第22章　I O操作和PL SQL	781
22.1　显示信息	781
22.1.1　启用DBMS_OUTPUT	782
22.1.2　向缓存中写入行	782
22.1.3　从缓存中读取内容	783
22.2　文件的读写	784
22.2.1　UTL_FILE_DIR参数	784
22.2.2　使用Oracle目录	786
22.2.3　打开文件	787
22.2.4　文件已经打开了吗？	789
22.2.5　关闭文件	789
22.2.6　读取文件	790
22.2.7　向文件中写	792
22.2.8　复制文件	795
22.2.9　删除文件	795
22.2.10　改名和移动文件	796
22.2.11　提取文件属性	797
22.3　发送邮件	798
22.3.1　Oracle的前提条件	798
22.3.2　设置网络安全	799
22.3.3　发送一个短的（小于32767字
节）的纯文本消息	799
22.3.4　在邮件地址中加上“界面友
好的”的名字	801
22.3.5　发送任意长度的纯文本
消息	802
22.3.6　发送带有小附件（小于32767
字节）的消息	803
22.3.7　以附件形式发送一个小文件
（小于32767字节）	805
22.3.8　任意大小的附件	805
22.4　使用基于Web的数据
（HTTP）	808
22.4.1 “分片”获得一个Web页面	808
22.4.2　把页面提取到一个LOB中	809
22.4.3　使用HTTP的用户名 密码
验证	810
22.4.4　获取一个SSL加密的Web页面
（使用HTTPS）	811
22.4.5　通过GET或者POST向Web页
面提交数据	812
22.4.6　禁用cookie或者使cookie
持久化	816
22.4.7　从FTP服务器获取数据	816
22.4.8　使用代理服务器	817
22.5　PL SQL中可用的其他I O
类型	817
22.5.1　数据库管道、队列、告警	817
22.5.2　TCPSocket	818
22.5.3　Oracle的内置Web服务器	818

第6部分　高级PL SQL主题 
第23章　应用系统安全与
PL SQL	821
23.1　安全概述	821
23.2　加密	822
23.2.1　密钥长度	823
23.2.2　算法	824
23.2.3　填补和连接	825
23.2.4　DBMS_CRYPTO包	825
23.2.5　数据加密	827
23.2.6　LOB的加密	830
23.2.7　安全文件	830
23.2.8　数据解密	831
23.2.9　生成密钥	832
23.2.10　密钥的管理	833
23.2.11　加密哈希	838
23.2.12　使用消息验证码	839
23.2.13　使用透明数据加密
（TDE）	841
23.2.14　透明的表空间加密	843
23.3　行级安全	844
23.3.1　为什么要学习RLS	846
23.3.2　一个简单的RLS示例	847
23.3.3　静态与动态策略	850
23.3.4　使用列敏感的RLS	854
23.3.5　RLS调试	857
23.4　应用程序上下文	861
23.4.1　使用应用程序上下文	862
23.4.2　上下文的安全	863
23.4.3　把上下文用作RLS的谓词
条件	863
23.4.4　识别出非数据库的用户	867
23.5　细粒度审计	868
23.5.1　为什么要学习FGA	869
23.5.2　一个简单的FGA示例	870
23.5.3　访问多少列	872
23.5.4　查看审计跟踪信息	873
23.5.5　使用绑定变量	874
23.5.6　使用句柄模块	875
第24章　PL SQL架构	877
24.1　DIANA	877
24.2　Oracle如何执行PL SQL
代码	878
24.2.1　一个示例	879
24.2.2　编译器的限制	881
24.3　PL SQL的缺省包	882
24.4　执行权限模型	884
24.4.1　定义者权限模型	885
24.4.2　调用者权限模型	889
24.4.3　组合权限模型	891
24.4.4　给PL SQL程序单元授予角色
（Oracle数据库12c）	892
24.4.5 “谁调用了我？”函数
（Oracle数据库12c）	895
24.4.6　视图的BEQUEATH CURRENT_
USER子句（Oracle数据库
12c）	895
24.4.7　调用者权限优点的限制
（Oracle数据库12c）	897
24.5　条件编译	898
24.5.1　条件编译的示例	899
24.5.2　查询指令	900
24.5.3　$IF指令	903
24.5.4　$ERROR指令	904
24.5.5　将代码与包常量同步	905
24.5.6　用查询指令实现程序专有
设置	906
24.5.7　使用预处理后的代码	907
24.6　PL SQL和数据库实例
内存	908
24.6.1　SGA、PGA和UGA	908
24.6.2　游标、内存及其他	909
24.6.3　减少内存使用的技巧	910
24.6.4　内存用光了怎么办	920
24.7　原生式编译	922
24.7.1　什么时候使用解释模式	922
24.7.2　什么时候使用原生模式	922
24.7.3　原生编译和数据库版本	923
24.8　一些须知	923
第25章　PL SQL的全球化和
本地化	925
25.1　概述和术语	926
25.2　Unicode入门	928
25.2.1　国家字符集的数据类型	929
25.2.2　字符编码	929
25.2.3　和全球化支持相关的参数	930
25.2.4　Unicode函数	931
25.3　字符语义	938
25.4　字符串排序顺序	941
25.4.1　二进制排序	942
25.4.2　单语言排序	943
25.4.3　多语言排序	945
25.5　多语言信息检索	946
25.5.1　信息检索和PL SQL	948
25.6　日期 时间	950
25.6.1　时间戳数据类型	951
25.6.2　日期 时间格式	952
25.7　货币转换	955
25.8　PL SQL的全球化开发
工具箱	957
25.8.1　UTL_I18N工具包	957
25.8.2　UTL_LMS异常处理包	960
25.8.3　GDK实现选项	961
第26章　PL SQL的面向对象
特性	963
26.1　Oracle对象特性的介绍	963
26.2　对象类型示例	965
26.2.1　创建一个基类	966
26.2.2　创建子类型	967
26.2.3　方法	968
26.2.4　在Oracle数据库11g及以后
版本中调用父类的方法	972
26.2.5　保存、提取、使用持久化
对象	974
26.2.6　演变和创建	981
26.2.7　回到指针吗？	983
26.2.8　泛化数据：ANY类型	989
26.2.9　我们自己做	993
26.2.10　对象的比较	996
26.3　对象视图	1001
26.3.1　一个关系型系统的示例	1002
26.3.2　带有集合属性的对象视图	1003
26.3.3　对象子视图	1006
26.3.4　带有反关系的对象视图	1008
26.3.5　INSTEAD OF触发器	1008
26.3.6　对象视图和对象表的区别	1010
26.4　维护对象类型和对象视图	1012
26.4.1　数据字典	1012
26.4.2　权限	1013
26.5　来自一个关系开发者的总结
思考（C551, E1200）	1015
第27章　从PL SQL中调用
Java	1017
27.1　Oracle和Java	1017
27.2　准备好在Oracle中使用
Java	1018
27.2.1　安装Java	1019
27.2.2　创建和编译我们的Java
代码	1019
27.2.3　设置Java开发和执行的
权限	1020
27.3　一个简单的演示	1022
27.3.1　查找Java功能	1023
27.3.2　创建一个自定义Java类	1023
27.3.3　编译和加载到Oracle	1025
27.3.4　创建一个PL SQL的
包装器	1026
27.3.5　从PL SQL删除文件	1027
27.4　使用loadjava	1028
27.5　使用dropjava	1030
27.6　管理数据库中的Java	1030
27.6.1　Oracle中的Java命名空间	1030
27.6.2　检查加载的Java元素	1031
27.7　使用DBMS_JAVA	1032
27.7.1　LONGNAME：转换Java
长名字	1032
27.7.2　GET_、SET_和RESET_
COMPILER_OPTION：
得到和设置（一些）
编译器选项	1033
27.7.3　SET_OUTPUT：允许从
Java中输出	1034
27.7.4　EXPORT_SOURCE、EXPORT_
RESOURCE和EXPORT_
CLASS：导出模式对象	1034
27.8　在PL SQL中发布与
使用Java	1036
27.8.1　调用规范	1036
27.8.2　一些调用规范的规则	1037
27.8.3　映射数据类型	1038
27.8.4　在SQL中调用Java方法	1039
27.8.5　Java的异常处理	1040
27.8.6　扩展文件I O功能	1042
27.8.7　其他示例	1046
第28章　外部过程	1049
28.1　外部过程介绍	1050
28.1.1　示例：调用一个系统命令	1050
28.1.2　外部过程的架构	1052
28.2　Oracle网络配置	1053
28.2.1　定义监听配置	1053
28.2.2　配置的安全特性	1055
28.3　设置多线程模式	1056
28.4　创建一个Oracle库	1058
28.5　编写调用规范	1059
28.5.1　调用规范：整体语法	1060
28.5.2　参数映射：示例重温	1061
28.5.3　参数映射：完整的内容	1063
28.5.4　更多的语法：参数子句	1064
28.5.5　参数属性	1065
28.6　从调用的C程序中引发
一个异常	1068
28.7　非默认的代理	1071
28.8　维护外部过程	1073
28.8.1　删除库	1073
28.8.2　数据字典	1074
28.8.3　规则和警示	1074
附录A　正则表达式元字符和函数
参数	1075
附录B　数字格式模型	1080
附录C　日期格式模型	1083
