Go语言从入门到进阶实践:视频教学版 PDF下载 徐波 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711159824
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711159824
<p>书名:Go语言从入门到进阶实践:视频教学版</p><p>作者:徐波</p><p>页数:398</p><p>定价:¥99.0</p><p>出版社:机械工业出版社</p><p>出版日期:2018-06-12</p><p>ISBN:9787111598244</p><p><h2>本书特色</h2></p>[<p>
本书采用“理论 实例”的形式编写，作者通过大量实例，并结合多年的一线开发实战经验，全面介绍了Go语言的语法及应用开发。作者特意为本书精心录制了同步配套教学视频，这将极大地提升读者的学习效率。本书分为13章，主要介绍了Go语言的特性与环境搭建、基本语法与使用、容器（存储和组织数据的方式）、流程控制、函数、结构体、接口（interface）、包（package）、并发、反射、编译与工具和开发技巧等内容，后的实战演练部分剖析了作者的开源网络库cellnet的架构及设计思想，并且实现了Socket聊天功能。本书对于Go语言的特色功能——并发，有全面、深入的讲解，需要读者重点学习。本书特别适合Go语言初学者入门和进阶阅读，另外也适合社会培训学校作为教材使用，还适合大中专院校的相关专业作为教学参考书。
                                        </p>]<p><h2>目录</h2></p>
    目录配套学习资源前言第1章  初识Go语言11.1  Go语言特性11.2  使用Go语言的项目91.3  怎样安装Go语言开发包101.3.1  Windows版安装111.3.2  Linux版安装131.4  搭建开发环境141.4.1  集成开发环境——Jetbrains GoLand141.4.2  方便定义功能的编辑器——Visual Studio Code15第2章  Go语言基本语法与使用192.1  变量192.1.1  声明变量192.1.2  初始化变量202.1.3  多个变量同时赋值232.1.4  匿名变量——没有名字的变量242.2  数据类型242.2.1  整型252.2.2  浮点型252.2.3  示例：输出正弦函数（Sin）图像262.2.4  布尔型282.2.5  字符串292.2.6  字符312.2.7  切片——能动态分配的空间322.3  转换不同的数据类型332.4  指针342.4.1  认识指针地址和指针类型352.4.2  从指针获取指针指向的值362.4.3  使用指针修改值372.4.4  示例：使用指针变量获取命令行的输入信息392.4.5  创建指针的另一种方法——new()函数402.5  变量生命期——变量能够使用的代码范围402.5.1  什么是栈412.5.2  什么是堆422.5.3  变量逃逸（Escape Analysis）——自动决定变量分配方式，提高运行效率432.6  字符串应用462.6.1  计算字符串长度462.6.2  遍历字符串——获取每一个字符串元素472.6.3  获取字符串的某一段字符482.6.4  修改字符串492.6.5  连接字符串492.6.6  格式化502.6.7  示例：Base64编码——电子邮件的基础编码格式512.6.8  示例：从INI配置文件中查询需要的值522.7  常量——恒定不变的值572.7.1  枚举——一组常量值582.7.2  将枚举值转换为字符串592.8  类型别名（Type Alias）602.8.1  区分类型别名与类型定义612.8.2  非本地类型不能定义方法622.8.3  在结构体成员嵌入时使用别名63第3章  容器：存储和组织数据的方式653.1  数组——固定大小的连续空间653.1.1  声明数组663.1.2  初始化数组663.1.3  遍历数组——访问每一个数组元素673.2  切片（slice）——动态分配大小的连续空间673.2.1  从数组或切片生成新的切片683.2.2  声明切片703.2.3  使用make()函数构造切片713.2.4  使用append()函数为切片添加元素713.2.5  复制切片元素到另一个切片733.2.6  从切片中删除元素743.3  映射（map）——建立事物关联的容器763.3.1  添加关联到map并访问关联和数据763.3.2  遍历map的“键值对”——?访问每一个map中的关联关系773.3.3  使用delete()函数从map中删除键值对793.3.4  清空map中的所有元素793.3.5  能够在并发环境中使用的map——?sync.Map793.4  列表（list）——可以快速增删的非连续空间的容器813.4.1  初始化列表833.4.2  在列表中插入元素833.4.3  从列表中删除元素843.4.4  遍历列表——访问列表的每一个元素85第4章  流程控制874.1  条件判断（if）874.2  构建循环（for）884.2.1  for中的初始语句——开始循环时执行的语句894.2.2  for中的条件表达式——控制是否循环的开关894.2.3  for中的结束语句——每次循环结束时执行的语句904.3  示例：九九乘法表904.4  键值循环（for range）——直接获得对象的索引和数据914.4.1  遍历数组、切片——获得索引和元素924.4.2  遍历字符串——获得字符924.4.3  遍历map——获得map的键和值924.4.4  遍历通道（channel）——接收通道数据934.4.5  在遍历中选择希望获得的变量934.5  分支选择（switch）——拥有多个条件分支的判断944.5.1  基本写法954.5.2  跨越case的fallthrough——兼容C语言的case设计964.6  跳转到指定代码标签（goto）964.6.1  使用goto退出多层循环964.6.2  使用goto集中处理错误974.6.3  统一错误处理984.7  跳出指定循环（break）——可以跳出多层循环994.8  继续下一次循环（continue）100第5章  函数（function）1015.1  声明函数1015.1.1   普通函数的声明形式1015.1.2  参数类型的简写1025.1.3  函数的返回值1025.1.4  调用函数1045.1.5  示例：将“秒”解析为时间单位1045.1.6  示例：函数中的参数传递效果测试1055.2  函数变量——把函数作为值保存到变量中1085.3  示例：字符串的链式处理——操作与数据分离的设计技巧1095.4  匿名函数——没有函数名字的函数1125.4.1  定义一个匿名函数1125.4.2  匿名函数用作回调函数1135.4.3  使用匿名函数实现操作封装1135.5  函数类型实现接口——把函数作为接口来调用1155.5.1  结构体实现接口1155.5.2  函数体实现接口1165.5.3  HTTP包中的例子1175.6  闭包（Closure）——引用了外部变量的匿名函数1185.6.1  在闭包内部修改引用的变量1195.6.2  示例：闭包的记忆效应1195.6.3  示例：闭包实现生成器1215.7  可变参数——参数数量不固定的函数形式1225.7.1  fmt包中的例子1225.7.2  遍历可变参数列表——获取每一个参数的值1235.7.3  获得可变参数类型——获得每一个参数的类型1245.7.4  在多个可变参数函数中传递参数1255.8  延迟执行语句（defer）1275.8.1  多个延迟执行语句的处理顺序1275.8.2  使用延迟执行语句在函数退出时释放资源1275.9  处理运行时发生的错误1315.9.1  net包中的例子1315.9.2  错误接口的定义格式1325.9.3  自定义一个错误1325.9.4  示例：在解析中使用自定义错误1335.10  宕机（panic）——程序终止运行1355.10.1  手动触发宕机1355.10.2  在运行依赖的**资源缺失时主动触发宕机1365.10.3  在宕机时触发延迟执行语句1365.11   宕机恢复（recover）——防止程序崩溃1375.11.1  让程序在崩溃时继续执行1375.11.2  panic和recover的关系139第6章  结构体（struct）1416.1  定义结构体1416.2  实例化结构体——为结构体分配内存并初始化1426.2.1  基本的实例化形式1426.2.2  创建指针类型的结构体1436.2.3  取结构体的地址实例化1436.3  初始化结构体的成员变量1446.3.1  使用“键值对”初始化结构体1456.3.2  使用多个值的列表初始化结构体1466.3.3  初始化匿名结构体1476.4  构造函数——结构体和类型的一系列初始化操作的函数封装1486.4.1  多种方式创建和初始化结构体——模拟构造函数重载1496.4.2  带有父子关系的结构体的构造和初始化——模拟父级构造调用1496.5  方法1506.5.1  为结构体添加方法1516.5.2  接收器——方法作用的目标1526.5.3  示例：二维矢量模拟玩家移动1556.5.4  为类型添加方法1606.5.5  示例：使用事件系统实现事件的响应和处理1656.6  类型内嵌和结构体内嵌1706.6.1  声明结构体内嵌1706.6.2  结构内嵌特性1726.6.3  使用组合思想描述对象特性1736.6.4  初始化结构体内嵌1746.6.5  初始化内嵌匿名结构体1756.6.6  成员名字冲突1776.7  示例：使用匿名结构体分离JSON数据178第7章  接口（interface）1817.1  声明接口1817.1.1  接口声明的格式1817.1.2  开发中常见的接口及写法1827.2  实现接口的条件1827.2.1  接口被实现的条件一：接口的方法与实现接口的类型方法格式一致1827.2.2  条件二：接口中所有方法均被实现1857.3  理解类型与接口的关系1867.3.1  一个类型可以实现多个接口1867.3.2  多个类型可以实现相同的接口1877.4  示例：便于扩展输出方式的日志系统1897.5  示例：使用接口进行数据的排序1957.5.1  使用sort.Interface接口进行排序1957.5.2  常见类型的便捷排序1977.5.3  对结构体数据进行排序1997.6  接口的嵌套组合——将多个接口放在一个接口内2027.7  在接口和类型间转换2057.7.1  类型断言的格式2057.7.2  将接口转换为其他接口2057.7.3  将接口转换为其他类型2087.8  空接口类型（interface{}）——能保存所有值的类型2087.8.1  将值保存到空接口2097.8.2  从空接口获取值2097.8.3  空接口的值比较2107.9  示例：使用空接口实现可以保存任意值的字典2117.10  类型分支——批量判断空接口中变量的类型2147.10.1  类型断言的书写格式2147.10.2  使用类型分支判断基本类型2157.10.3  使用类型分支判断接口类型2157.11  示例：实现有限状态机（FSM）217第8章  包（package）2278.1  工作目录（GOPATH）2278.1.1  使用命令行查看GOPATH信息2278.1.2  使用GOPATH的工程结构2288.1.3  设置和使用GOPATH2298.1.4  在多项目工程中使用GOPATH2308.2  创建包package——编写自己的代码扩展2318.3  导出标识符——让外部访问包的类型和值2318.3.1  导出包内标识符2318.3.2  导出结构体及接口成员2328.4  导入包（import）——在代码中使用其他的代码2328.4.1  默认导入的写法2338.4.2  导入包后自定义引用的包名2348.4.3  匿名导入包——只导入包但不使用包内类型和数值2358.4.4  包在程序启动前的初始化入口：init2358.4.5  理解包导入后的init()函数初始化顺序2358.5  示例：工厂模式自动注册——管理多个包的结构体237第9章  并发2419.1  轻量级线程（goroutine）——根据需要随时创建的“线程”2419.1.1  使用普通函数创建goroutine2419.1.2  使用匿名函数创建goroutine2449.1.3  调整并发的运行性能（GOMAXPROCS）2459.1.4  理解并发和并行2459.1.5  Go语言的协作程序（goroutine）和普通的协作程序（coroutine）2469.2  通道（channel）——在多个goroutine间通信的管道2469.2.1  通道的特性2479.2.2  声明通道类型2479.2.3  创建通道2489.2.4  使用通道发送数据2489.2.5  使用通道接收数据2499.2.6  示例：并发打印2529.2.7  单向通道——通道中的单行道2549.2.8  带缓冲的通道2559.2.9  通道的多路复用——同时处理接收和发送多个通道的数据2579.2.10  示例：模拟远程过程调用（RPC）2589.2.11  示例：使用通道响应计时器的事件2619.2.12  关闭通道后继续使用通道2649.3  示例：Telnet回音服务器——TCP服务器的基本结构2669.4  同步——保证并发环境下数据访问的正确性2739.4.1  竞态检测——检测代码在并发环境下可能出现的问题2739.4.2  互斥锁（sync.Mutex）——保证同时只有一个goroutine可以访问共享资源2759.4.3  读写互斥锁（sync.RWMutex）——在读比写多的环境下比互斥锁更高效2779.4.4  等待组（sync.WaitGroup）——保证在并发环境中完成指定数量的任务277第10章  反射28010.1  反射的类型对象（reflect.Type）28010.1.1  理解反射的类型（Type）与种类（Kind）28110.1.2  指针与指针指向的元素28310.1.3  使用反射获取结构体的成员类型28410.1.4  结构体标签（Struct Tag）——对结构体字段的额外信息标签28710.2  反射的值对象（reflect.Value）28810.2.1  使用反射值对象包装任意值28810.2.2  从反射值对象获取被包装的值28910.2.3  使用反射访问结构体的成员字段的值29010.2.4  反射对象的空和有效性判断29210.2.5  使用反射值对象修改变量的值29310.2.6  通过类型创建类型的实例29710.2.7  使用反射调用函数29810.3  示例：将结构体的数据保存为JSON格式的文本数据299第11章  编译与工具30611.1  编译（go build）30611.1.1  go build 无参数编译30611.1.2  go build 文件列表30711.1.3  go build  包30811.1. 4  go build编译时的附加参数31011.2  编译后运行（go run）31011.3  编译并安装（go install）31111.4  一键获取代码、编译并安装（go get）31211.4.1  远程包的路径格式31211.4.2  go get   远程包31211.4.3  go get使用时的附加参数31311.5  测试（go test）31311.5.1  单元测试——测试和验证代码的框架31311.5.2  基准测试——获得代码内存占用和运行效率的性能数据31611.6  性能分析（go pprof）——发现代码性能问题的调用位置31911.6.1  安装第三方图形化显式分析数据工具（Graphviz）31911.6.2  安装第三方性能分析来分析代码包31911.6.3  性能分析代码319第12章 “避坑”与技巧32312.1  合理地使用并发特性32312.1.1  了解goroutine的生命期时再创建goroutine32312.1.2  避免在不必要的地方使用通道32612.2  反射：性能和灵活性的双刃剑33012.3  接口的nil判断33512.4  map的多键索引——多个数值条件可以同时查询33612.4.1  基于哈希值的多键索引及查询33712.4.2  利用map特性的多键索引及查询34112.4.3  总结34212.5  优雅地处理TCP粘包342第13章  实战演练——剖析cellnet网络库设计并实现Socket聊天功能35413.1  了解cellet网络库特性、流程及架构35413.1.1  cellnet网络库的特性35413.1.2  cellnet网络库的流程及架构35613.2  管理TCP Socket连接35613.2.1  理解Socket的事件类型35713.2.2  管理事件回调35913.2.3  连接器（Connector）36113.2.4  会话管理（SessionManager）36313.2.5  接受器（Acceptor）36613.3  组织接收和发送数据流程的Socket会话（Session）36713.3.1  在会话开始时启动goroutine和派发事件36813.3.2  会话中的接收数据循环36913.3.3  会话中的发送数据循环37013.4  排队处理事件的事件队列（EventQueue）37213.4.1  实现事件队列37213.4.2  使用不同的事件队列模式处理数据37413.5  消息编码（codec）——让cellnet支持消息的多种编码格式37713.6  消息元信息（MessageMeta）——消息ID、消息名称和消息类型的关联关系37913.6.1  理解消息元信息38013.6.2  注册消息元信息38013.6.3  示例：使用消息元信息38113.6.4  实现消息的编码（EncodeMessage()）和解码（DecodeMessage()）函数38213.7  接收和发送封包（packet）38313.7.1  接收可变长度封包38413.7.2  了解封包数据读取器（PacketReader）38513.7.3  了解封包数据写入器（PacketWriter）38713.7.4  读取自定义封包及数据38713.7.5  写入自定义封包及数据38913.7.6  响应消息处理事件39013.8  使用cellnet网络库实现聊天功能39213.8.1  定义聊天协议39313.8.2  实现客户端功能39413.8.3  实现服务器功能39613.8.4  运行聊天服务器和客户端398
