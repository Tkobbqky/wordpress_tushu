C++并发编程实战 PDF下载 威廉姆斯 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711538732
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711538732
<p>书名:C++并发编程实战</p><p>作者:威廉姆斯</p><p>页数:487</p><p>定价:¥89.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2015-06-01</p><p>ISBN:9787115387325</p><p><h2>相关资料</h2></p>[<p>“有思想、有深度的指南，从专业人士那儿来的第一手资料。”<br/>
——neil horlock，credit suisse<br/>
“简化了c++多线程的黑魔法”。<br/>
—rick wagner，red hat<br/>
 “读这本书让我头痛，但痛定思痛”。<br/>
—joshua heyer，ingersoll rand<br/>
“作者展示了如何将并发变为现实。”<br/>
—roger orr，or/2 limited</p>]<p><h2>本书特色</h2></p>[<p>
《c++并发编程实战》是一本基于c++11新标准的并发和多线程编程深度指南。内容包括从std::thread、std::mutex、std::future和std::async等基础类的使用，到内存模型和原子操作、基于锁和无锁数据结构的构建，再扩展到并行算法、线程管理，*后还介绍了多线程代码的测试工作。本书的附录部分还对c++11新语言特性中与多线程相关的项目进行了简要的介绍，并提供了c++11线程库的完整参考。
　　《c++并发编程实战》适合于需要深入了解c++多线程开发的读者，以及使用c++进行各类软件开发的开发人员、测试人员。对于使用第三方线程库的读者，也可以从本书后面的章节中了解到相关的指引和技巧。同时，本书还可以作为c++11线程库的参考工具书。
                                        </p>]<p><h2>内容简介</h2></p>[<p>基于c++11新标准的并发和多线程编程深度指南，帮助你循序渐进地学习用c++11编写健壮且优雅的多线程应用程序。
　　针对c++11新标准编写代码；针对多核多处理器编写程序；用于学习的小例子，用于实践的大例子。
　　如果你打算用c++编写多线程代码，你就应该阅读本书。如果你正要使用c++标准库中新的多线程工具，这本书是**的指南。如果你正使用替代的线程库，后面几章中的指引和技巧应该也是有用的。
　　具有多核的多处理器现已成为标配。c++语言的c++11版本为多线程应用程序提供了强大的支持，你需要掌握其原理、技巧以及新的并发语言特性，才能独领风骚。
　　本书帮助你循序渐进地学习用c++11编写健壮且优雅的多线程应用程序。你将学习线程内存模型、新的线程支持库，以及基础的线程启动和同步功能。与此同时，你还将学到如何解决并发应用程序中的棘手问题。
　　本书具有以下特色：
　　针对c++11新标准编写代码；
　　针对多核多处理器编写程序；
　　用于学习的小例子，用于实践的大例子。
　　本书适合新接触并发编程的c++程序员，以及曾经使用别的语言、api或平台编写过多线程代码的程序员阅读。</p>]<p><h2>作者简介</h2></p>[<p>周全，软件工程师，毕业于中国科学技术大学信息学院，现任职于中国人民银行合肥中心支行科技处。从事.NET开发多年，有较为丰富的系统集成和运维经验，对虚拟化也有较深入的研究。可以通过email: spadeq@live.com与他联系。
宋真真，网络工程师，2008年毕业于合肥工业大学计算机与信息学院，现任职于中国人民银行合肥中心支行科技处，参与软件开发、项目管理等工作，爱好数据库、编程等研究。可以通过email: hfut_szz@sina.com与她联系。
梁娟娟，2010年毕业于中国科学技术大学信息技术学院，现就职于中国人民银行合肥中心支行。
许敏，软件工程师，2005年获得软件测试工程师证书。现任职于中国人民银行合肥中心支行科技处，负责项目管理工作。可以通过Email: xu_min@sina.com与她联系。</p>]<p><h2>目录</h2></p>
    第1章 你好，c++并发世界 　1.1 什么是并发 　1.1.1 计算机系统中的并发 　1.1.2 并发的途径 　1.2 为什么使用并发 　1.2.1 为了划分关注点而使用并发 　1.2.2 为了性能而使用并发 　1.2.3 什么时候不使用并发 　1.3 在c++中使用并发和多线程 　1.3.1 c++多线程历程 　1.3.2 新标准中的并发支持 　1.3.3 c++线程库的效率 　1.3.4 平台相关的工具 　1.4 开始入门 　1.5 小结 第2章 管理线程 　2.1 基本线程管理 　2.1.1 启动线程 　2.1.2 等待线程完成 　2.1.3 在异常环境下的等待 　2.1.4 在后台运行线程 　2.2 传递参数给线程函数 　2.3 转移线程的所有权 　2.4 在运行时选择线程数量 　2.5 标识线程 　2.6 小结 第3章 在线程间共享数据 　3.1 线程之间共享数据的问题 　3.1.1 竞争条件 　3.1.2 避免有问题的竞争条件 　3.2 用互斥元保护共享数据 　3.2.1 使用c++中的互斥元 　3.2.2 为保护共享数据精心组织代码 　3.2.3 发现接口中固有的竞争条件 　3.2.4 死锁：问题和解决方案 　3.2.5 避免死锁的进一步指南 　3.2.6 用std::unique_lock灵活锁定 　3.2.7 在作用域之间转移锁的所有权 　3.2.8 锁定在恰当的粒度 　3.3 用于共享数据保护的替代工具 　3.3.1 在初始化时保护共享数据 　3.3.2 保护很少更新的数据结构 　3.3.3 递归锁 　3.4 小结 第4章 同步并发操作 　4.1 等待事件或其他条件 　4.1.1 用条件变量等待条件 　4.1.2 使用条件变量建立一个线程安全队列 　4.2 使用future等待一次性事件 　4.2.1 从后台任务中返回值 　4.2.2 将任务与future相关联 　4.2.3 生成(std::)promise 　4.2.4 为future保存异常 　4.2.5 等待自多个线程 　4.3 有时间限制的等待 　4.3.1 时钟 　4.3.2 时间段 　4.3.3 时间点 　4.3.4 接受超时的函数 　4.4 使用操作同步来简化代码 　4.4.1 带有future的函数式编程 　4.4.2 具有消息传递的同步操作 　4.5 小结 第5章 c++内存模型和原子　类型上操作 　5.1 内存模型基础 　5.1.1 对象和内存位置 　5.1.2 对象、内存位置以及并发 　5.1.3 修改顺序 　5.2 c++中的原子操作及类型 　5.2.1 标准原子类型 　5.2.2 std::atomic_flag上的操作 　5.2.3 基于std::atomic的操作 　5.2.4 std::atomic上的操作：指针算术运算 　5.2.5 标准原子整型的操作 　5.2.6 std::atomic<>初级类模板 　5.2.7 原子操作的自由函数 　5.3 同步操作和强制顺序 　5.3.1 synchronizes-with关系 　5.3.2 happens-before关系 　5.3.3 原子操作的内存顺序 　5.3.4 释放序列和synchronizes-with 　5.3.5 屏障 　5.3.6 用原子操作排序非原子操作 　5.4 小结 第6章 设计基于锁的并发数据结构 　6.1 为并发设计的含义是什么 　6.2 基于锁的并发数据结构 　6.2.1 使用锁的线程安全栈 　6.2.2 使用锁和条件变量的线程安全队列 　6.2.3 使用细粒度锁和条件变量的线程安全队列 　6.3 设计更复杂的基于锁的数据结构 　6.3.1 编写一个使用锁的线程安全查找表 　6.3.2 编写一个使用锁的线程安全链表 　6.4 小结 第7章 设计无锁的并发数据结构 　7.1 定义和结果 　7.1.1 非阻塞数据结构的类型 　7.1.2 无锁数据结构 　7.1.3 无等待的数据结构 　7.1.4 无锁数据结构的优点与缺点 　7.2 无锁数据结构的例子 　7.2.1 编写不用锁的线程安全栈 　7.2.2 停止恼人的泄漏：在无锁数据结构中管理内存 　7.2.3 用风险指针检测不能被回收的结点 　7.2.4 使用引用计数检测结点 　7.2.5 将内存模型应用至无锁栈 　7.2.6 编写不用锁的线程安全队列 　7.3 编写无锁数据结构的准则 　7.3.1 准则：使用std::memory_order_seq_cst作为原型 　7.3.2 准则：使用无锁内存回收模式 　7.3.3 准则：当心aba问题 　7.3.4 准则：识别忙于等待的循环以及辅助其他线程 　7.4 小结 第8章 设计并发代码 　8.1 在线程间划分工作的技术 　8.1.1 处理开始前在线程间划分数据 　8.1.2 递归地划分数据 　8.1.3 以任务类型划分工作 　8.2 影响并发代码性能的因素 　8.2.1 有多少个处理器 　8.2.2 数据竞争和乒乓缓存 　8.2.3 假共享 　8.2.4 数据应该多紧密 　8.2.5 过度订阅和过多的任务切换 　8.3 为多线程性能设计数据结构 　8.3.1 为复杂操作划分数组元素 　8.3.2 其他数据结构中的数据访问方式 　8.4 为并发设计时的额外考虑 　8.4.1 并行算法中的异常安全 　8.4.2 可扩展性和阿姆达尔定律 　8.4.3 用多线程隐藏延迟 　8.4.4 用并发提高响应性 　8.5 在实践中设计并发代码 　8.5.1 std::for_each的并行实现 　8.5.2 std::find的并行实现 　8.5.3 std::partial_sum的并行实现 　8.6 总结 第9章 高级线程管理 　9.1 线程池 　9.1.1 *简单的线程池 　9.1.2 等待提交给线程池的任务 　9.1.3 等待其他任务的任务 　9.1.4 避免工作队列上的竞争 　9.1.5 工作窃取 　9.2 中断线程 　9.2.1 启动和中断另一个线程 　9.2.2 检测一个线程是否被中断 　9.2.3 中断等待条件变量 　9.2.4 中断在std::condition_variable_ any上的等待 　9.2.5 中断其他阻塞调用 　9.2.6 处理中断 　9.2.7 在应用退出时中断后台任务 　9.3 总结 第10章 多线程应用的测试与调试 　10.1 并发相关错误的类型 　10.1.1 不必要的阻塞 　10.1.2 竞争条件 　10.2 定位并发相关的错误的技巧 　10.2.1 审阅代码以定位潜在的错误 　10.2.2 通过测试定位并发相关的错误 　10.2.3 可测试性设计 　10.2.4 多线程测试技术 　10.2.5 构建多线程的测试代码 　10.2.6 测试多线程代码的性能 　10.3 总结 附录a 附录a c++11部分语言特性简明参考 附录b 并发类库	 
