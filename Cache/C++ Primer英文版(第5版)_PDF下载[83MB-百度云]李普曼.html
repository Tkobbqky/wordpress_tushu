C++ Primer英文版(第5版) PDF下载 李普曼 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712120038
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712120038
<p>书名:C++ Primer英文版(第5版)</p><p>作者:李普曼</p><p>页数:938</p><p>定价:¥128.0</p><p>出版社:电子工业出版社</p><p>出版日期:2013-05-01</p><p>ISBN:9787121200380</p><p><h2>相关资料</h2></p>[<p>
                                    
                                        
　　在c++的著作当中，这本书的地位是无可替代的。要成为合格的c++开发者，就必须掌握c++标准库，而要掌握c++标准库，这本书可以说是不二法门。这本书最了不起的地方，就在于面对庞大复杂的c++标准库，能够抽丝剥茧，化难为易，引导读者循序渐进，深入浅出地掌握c++标准库。
——孟岩
stl堪称是c++泛型的极致实现，里面不但封装了最高效的算法，也用到了c++泛型最高级的技术。对我来说，学习stl并不仅仅是学习stl的用法和特性，而是学习stl的设计方法。本书作为stl入门级的经典图书，虽然很夸张地有上千页，但是读起并没有那么吃力，因为里面有很多的代码示例，从而使得本书更容易阅读。本书在内容编排上也类似于c++速查手册，可以让你很容易地查到stl以及c++11的相关知识点。
——陈皓（@左耳朵耗子） 大有所悟，相见恨晚，对stl编程思想有绝对的裨益。 交叉索引的协助十分便利，c++学习之路必备秘籍之一。
——china-pub读者“qinhanlei”
无论如何c++程序员必须有的一本书。一个不会c++标准库的程序员不是一个真正的c++程序员，不是一个完整的c++程序员。
——china-pub读者“ttklboy”
本书详尽地介绍了c++标准库，即可作为自学教材又可作为查阅手册，讲解通俗、清晰、详细，对于学习和使用c++，本书为必备图书。
——亚马逊中国读者“jzzlee”                                    </p>]<p><h2>本书特色</h2></p>[<p>

这本久负盛名的c++经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的--c++大师stanleyb.
lippman的丰富实践经验，c++标准委员会原负责人joséelajoie对c++标准的深入理解，以及c++先驱barbara
e.moo在c++教学方面的真知灼见外，更是基于全新的c++11标准进行了全面而彻底的内容更新。非常难能可贵的是，书中所有示例均全部采用c++11标准改写，这在经典升级版中极其罕见--充分体现了c++语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让《c++primer英文版（第5版）》这本书在c++领域的权威地位更加不可动摇。无论是初学者入门，或是中、高级程序员提升，《c++primer英文版（第5版）》均为不容置疑的首选。
                                        </p>]<p><h2>内容简介</h2></p>[<p>
	　　*新标准c++11发布，距上一版本已10年；《c++
primer英文版（第5版）》是唯一持续更新的全球顶级c++读本。
　　多位深孚众望的大师组合堪称绝无仅有；经过前四个版本积累，第5版的体例堪称完美。
　　这一版本作者历时3年完成，极力避免在原版上升级，而是将c++ 11的新特性真正融入各章节；更将所有代码示例用c++
11的简化写法完成，而不是仅单独增加内容。


	推荐购买：


	c++
primer中文版（第5版）（顶级畅销书重磅升级 全面采用*新 c++
11标准）


	
	
		essential c++中文版 （c++捷径 首屈一指的必读经典）
	
	
		effective c++

	
	
		more effective c++
	
	
		
	


</p>]<p><h2>作者简介</h2></p>[<p>　　Stanley B. Lippman，目前是微软公司 Visual C++
团队的架构师。他从1984年开始在贝尔实验室与C++的设计者Bjarne
Stroustrup一起从事C++的设计与开发。他在迪士尼和梦工厂从事动画制作，还担任过JPL的高级顾问。

　　Josée Lajoie，曾经是IBM加拿大研究中心C/C++编译器开发团队的成员，在ISO
C++标准委员会工作了7年，担任过ISO核心语言工作组的主席和C++ Report杂志的专栏作家。

　　Barbara E.
Moo，拥有25年软件经验的独立咨询顾问。在AT&amp;T，她与Stroustrup、Lippman一起管理过复杂的C++开发项目。</p>]<p><h2>目录</h2></p>
preface xxiiichapter 1 getting started1.1 writing a simple c++program1.1.1 compiling and executing our program1.2 afirstlookat input/output1.3 awordaboutcomments1.4 flowofcontrol1.4.1 the whilestatement1.4.2 the forstatement1.4.3 readinganunknownnumberof inputs1.4.4 the ifstatement1.5 introducingclasses1.5.1 the sales_itemclass1.5.2 afirstlookatmemberfunctions1.6 thebookstoreprogramchaptersummarydefinedtermspart i the basicschapter 2 variables and basic types2.1 primitivebuilt-intypes2.1.1 arithmetictypes2.1.2 typeconversions2.1.3 literals2.2 variables2.2.1 variabledefinitions2.2.2 variabledeclarations anddefinitions2.2.3 identifiers2.2.4 scopeof aname2.3 compoundtypes2.3.1 references2.3.2 pointersviiviii contents2.3.3 understandingcompoundtypedeclarations2.4 constqualifier2.4.1 references to const2.4.2 pointers and const2.4.3 top-level const2.4.4 constexprandconstantexpressions2.5 dealingwithtypes2.5.1 typealiases2.5.2 the autotypespecifier2.5.3 the decltypetypespecifier2.6 definingourowndatastructures2.6.1 defining the sales_datatype2.6.2 using the sales_dataclass2.6.3 writing our own header fileschaptersummarydefinedtermschapter 3 strings， vectors， and arrays3.1 namespace usingdeclarations3.2 library stringtype3.2.1 defining and initializing strings3.2.2 operations on strings3.2.3 dealing with the characters in a string3.3 library vectortype3.3.1 defining and initializing vectors3.3.2 adding elements to a vector3.3.3 other vectoroperations3.4 introducingiterators3.4.1 usingiterators3.4.2 iteratorarithmetic3.5 arrays3.5.1 definingandinitializingbuilt-inarrays3.5.2 accessingtheelementsof anarray3.5.3 pointers andarrays3.5.4 c-stylecharacterstrings3.5.5 interfacingtooldercode3.6 multidimensionalarrayschaptersummarydefinedtermschapter 4 expressions4.1 fundamentals4.1.1 basicconcepts4.1.2 precedenceandassociativity4.1.3 orderofevaluation4.2 arithmeticoperators4.3 logical andrelationaloperatorscontents ix4.4 assignmentoperators4.5 increment anddecrementoperators4.6 thememberaccessoperators4.7 theconditionaloperator4.8 thebitwiseoperators4.9 the sizeofoperator4.10 commaoperator4.11 typeconversions4.11.1 thearithmeticconversions4.11.2 other implicitconversions4.11.3 explicitconversions4.12 operatorprecedencetablechaptersummarydefinedtermschapter 5 statements5.1 simple statements5.2 statementscope5.3 conditional statements5.3.1 the ifstatement5.3.2 the switchstatement5.4 iterativestatements5.4.1 the whilestatement5.4.2 traditional forstatement5.4.3 range forstatement5.4.4 the do whilestatement5.5 jumpstatements5.5.1 the breakstatement5.5.2 the continuestatement5.5.3 the gotostatement5.6 tryblocks andexceptionhandling5.6.1 a throwexpression5.6.2 the tryblock5.6.3 standardexceptionschaptersummarydefinedtermschapter 6 functions6.1 functionbasics6.1.1 localobjects6.1.2 functiondeclarations6.1.3 separatecompilation6.2 argumentpassing6.2.1 passingargumentsbyvalue6.2.2 passingargumentsbyreference6.2.3 constparametersandarguments6.2.4 arrayparametersx contents6.2.5 main：handlingcommand-lineoptions6.2.6 functionswithvaryingparameters6.3 return types and the returnstatement6.3.1 functionswithnoreturnvalue6.3.2 functionsthatreturnavalue6.3.3 returningapointer toanarray6.4 overloadedfunctions6.4.1 overloadingandscope6.5 features forspecializeduses6.5.1 defaultarguments6.5.2 inline and constexprfunctions6.5.3 aids for debugging6.6 functionmatching6.6.1 argumenttypeconversions6.7 pointers tofunctionschaptersummarydefinedtermschapter 7 classes7.1 definingabstractdatatypes7.1.1 designing the sales_dataclass7.1.2 defining the revised sales_dataclass7.1.3 definingnonmemberclass-relatedfunctions7.1.4 constructors7.1.5 copy，assignment， anddestruction7.2 accesscontrol andencapsulation7.2.1 friends7.3 additionalclassfeatures7.3.1 classmembersrevisited7.3.2 functions that return *this7.3.3 classtypes7.3.4 friendshiprevisited7.4 classscope7.4.1 namelookupandclassscope7.5 constructorsrevisited7.5.1 constructor initializerlist7.5.2 delegatingconstructors7.5.3 theroleof thedefaultconstructor7.5.4 implicitclass-typeconversions7.5.5 aggregateclasses7.5.6 literalclasses7.6 staticclassmemberschaptersummarydefinedtermscontents xipart ii the c++ librarychapter 8 the io library8.1 the ioclasses8.1.1 nocopyorassignfor ioobjects8.1.2 conditionstates8.1.3 managingtheoutputbuffer8.2 file input and output8.2.1 using file stream objects8.2.2 file modes8.3 stringstreams8.3.1 using an istringstream8.3.2 using ostringstreamschaptersummarydefinedtermschapter 9 sequential containers9.1 overviewof the sequentialcontainers9.2 containerlibraryoverview9.2.1 iterators9.2.2 containertypemembers9.2.3 begin and endmembers9.2.4 definingandinitializingacontainer9.2.5 assignment and swap9.2.6 containersizeoperations9.2.7 relationaloperators9.3 sequentialcontaineroperations9.3.1 addingelements toasequentialcontainer9.3.2 accessingelements9.3.3 erasingelements9.3.4 specialized forward_listoperations9.3.5 resizingacontainer9.3.6 containeroperationsmayinvalidateiterators9.4 how a vectorgrows9.5 additional stringoperations9.5.1 other ways to construct strings9.5.2 other ways to change a string9.5.3 stringsearchoperations9.5.4 the comparefunctions9.5.5 numericconversions9.6 containeradaptorschaptersummarydefinedtermsxii contentschapter 10 generic algorithms10.1 overview10.2 afirstlookat thealgorithms10.2.1 read-onlyalgorithms10.2.2 algorithmsthatwritecontainerelements10.2.3 algorithmsthatreordercontainerelements10.3 customizingoperations10.3.1 passingafunctiontoanalgorithm10.3.2 lambdaexpressions10.3.3 lambdacapturesandreturns10.3.4 bindingarguments10.4 revisiting iterators10.4.1 insert iterators10.4.2 iostream iterators10.4.3 reverse iterators10.5 structureofgenericalgorithms10.5.1 thefive iteratorcategories10.5.2 algorithmparameterpatterns10.5.3 algorithmnamingconventions10.6 container-specificalgorithmschaptersummarydefinedtermschapter 11 associative containers11.1 usinganassociativecontainer11.2 overviewof theassociativecontainers11.2.1 defininganassociativecontainer11.2.2 requirements onkeytype11.2.3 the pairtype11.3 operations onassociativecontainers11.3.1 associativecontainer iterators11.3.2 addingelements11.3.3 erasingelements11.3.4 subscripting a map11.3.5 accessingelements11.3.6 awordtransformationmap11.4 theunorderedcontainerschaptersummarydefinedtermschapter 12 dynamicmemory12.1 dynamicmemoryandsmartpointers12.1.1 the shared_ptrclass12.1.2 managingmemorydirectly12.1.3 using shared_ptrs with new12.1.4 smartpointers andexceptions12.1.5 unique_ptrcontents xiii12.1.6 weak_ptr12.2 dynamicarrays12.2.1 newandarrays12.2.2 the allocatorclass12.3 usingthelibrary：atext-queryprogram12.3.1 designof thequeryprogram12.3.2 definingthequeryprogramclasseschaptersummarydefinedtermspart iii tools for class authorschapter 13 copy control13.1 copy，assign， anddestroy13.1.1 thecopyconstructor13.1.2 thecopy-assignmentoperator13.1.3 thedestructor13.1.4 theruleofthree/five13.1.5 using = default13.1.6 preventingcopies13.2 copycontrol andresourcemanagement13.2.1 classesthatactlikevalues13.2.2 definingclassesthatactlikepointers13.3 swap13.4 acopy-controlexample13.5 classesthatmanagedynamicmemory13.6 movingobjects13.6.1 rvaluereferences13.6.2 moveconstructor andmoveassignment13.6.3 rvaluereferencesandmemberfunctionschaptersummarydefinedtermschapter 14 overloaded operations and conversions14.1 basicconcepts14.2 input andoutputoperators14.2.1 overloading the output operator <<14.2.2 overloading the input operator >>14.3 arithmetic andrelationaloperators14.3.1 equalityoperators14.3.2 relationaloperators14.4 assignmentoperators14.5 subscriptoperator14.6 increment anddecrementoperators14.7 memberaccessoperators14.8 function-calloperatorxiv contents14.8.1 lambdasarefunctionobjects14.8.2 library-definedfunctionobjects14.8.3 callable objects and function14.9 overloading，conversions， andoperators14.9.1 conversionoperators14.9.2 avoidingambiguousconversions14.9.3 functionmatchingandoverloadedoperatorschaptersummarydefinedtermschapter 15 object-oriented programming15.1 oop：anoverview15.2 definingbaseandderivedclasses15.2.1 definingabaseclass15.2.2 definingaderivedclass15.2.3 conversions andinheritance15.3 virtualfunctions15.4 abstractbaseclasses15.5 accesscontrol andinheritance15.6 classscopeunder inheritance15.7 constructors andcopycontrol15.7.1 virtualdestructors15.7.2 synthesizedcopycontrol andinheritance15.7.3 derived-classcopy-controlmembers15.7.4 inheritedconstructors15.8 containers andinheritance15.8.1 writing a basketclass15.9 textqueriesrevisited15.9.1 anobject-orientedsolution15.9.2 the query_base and queryclasses15.9.3 thederivedclasses15.9.4 the evalfunctionschaptersummarydefinedtermschapter 16 templates and generic programming16.1 definingatemplate16.1.1 functiontemplates16.1.2 classtemplates16.1.3 templateparameters16.1.4 membertemplates16.1.5 controlling instantiations16.1.6 efficiency and flexibility16.2 templateargumentdeduction16.2.1 conversions andtemplatetypeparameters16.2.2 function-templateexplicitarguments16.2.3 trailing return types and type transformationcontents xv16.2.4 functionpointers andargumentdeduction16.2.5 templateargumentdeductionandreferences16.2.6 understanding std：：move16.2.7 forwarding16.3 overloadingandtemplates16.4 variadictemplates16.4.1 writingavariadicfunctiontemplate16.4.2 packexpansion16.4.3 forwardingparameterpacks16.5 template specializationschaptersummarydefinedtermspart iv advanced topicschapter 17 specialized library facilities17.1 the tupletype17.1.1 defining and initializing tuples17.1.2 using a tuple toreturnmultiplevalues17.2 the bitsettype17.2.1 defining and initializing bitsets17.2.2 operations on bitsets17.3 regularexpressions17.3.1 usingtheregularexpressionlibrary17.3.2 thematchandregex iteratortypes17.3.3 usingsubexpressions17.3.4 using regex_replace17.4 randomnumbers17.4.1 random-numberengines anddistribution17.4.2 otherkinds ofdistributions17.5 the iolibraryrevisited17.5.1 formattedinput andoutput17.5.2 unformattedinput/outputoperations17.5.3 randomaccess toastreamchaptersummarydefinedtermschapter 18 tools for large programs18.1 exceptionhandling18.1.1 throwinganexception18.1.2 catchinganexception18.1.3 function tryblocks andconstructors18.1.4 the noexceptexceptionspecification18.1.5 exceptionclasshierarchies18.2 namespaces18.2.1 namespacedefinitionsxvi contents18.2.2 usingnamespacemembers18.2.3 classes，namespaces，andscope18.2.4 overloadingandnamespaces18.3 multiple andvirtual inheritance18.3.1 multiple inheritance18.3.2 conversions andmultiplebaseclasses18.3.3 classscopeundermultiple inheritance18.3.4 virtual inheritance18.3.5 constructors andvirtual inheritancechaptersummarydefinedtermschapter 19 specialized tools and techniques19.1 controlling memory allocation19.1.1 overloading new and delete19.1.2 placement newexpressions19.2 run-timetypeidentification19.2.1 the dynamic_castoperator19.2.2 the typeidoperator19.2.3 usingrtti19.2.4 the type_infoclass19.3 enumerations19.4 pointer toclassmember19.4.1 pointers todatamembers19.4.2 pointers tomemberfunctions19.4.3 usingmemberfunctions ascallableobjects19.5 nestedclasses19.6 union：aspace-savingclass19.7 localclasses19.8 inherentlynonportablefeatures19.8.1 bit-fields19.8.2 volatilequalifier19.8.3 linkage directives： extern “c”chaptersummarydefinedtermsappendix a the librarya.1 librarynames andheadersa.2 abrieftourof thealgorithmsa.2.1 algorithms tofindanobjecta.2.2 otherread-onlyalgorithmsa.2.3 binarysearchalgorithmsa.2.4 algorithmsthatwritecontainerelementsa.2.5 partitioningandsortingalgorithmsa.2.6 generalreorderingoperationsa.2.7 permutationalgorithmsa.2.8 setalgorithms forsortedsequencescontents xviia.2.9 minimumandmaximumvaluesa.2.10 numericalgorithmsa.3 randomnumbersa.3.1 randomnumberdistributionsa.3.2 randomnumberenginesindexnew features in c++2.1.1 long longtype2.2.1 list initialization2.3.2 nullptrliteral2.4.4 constexprvariables2.5.1 typealiasdeclarations2.5.2 the autotypespecifier2.5.3 the decltypetypespecifier2.6.1 in-class initializers3.2.2 using auto or decltype fortypeabbreviation3.2.3 range forstatement3.3 defining a vector of vectors3.3.1 list initialization for vectors3.4.1 container cbegin and cendfunctions3.5.3 library begin and endfunctions3.6 using auto or decltype to simplifydeclarations4.2 roundingrules fordivision4.4 assignment fromabracedlistofvalues4.9 sizeofappliedtoaclassmember5.4.3 range forstatement6.2.6 library initializer_listclass6.3.2 list initializingareturnvalue6.3.3 declaring a trailing return type6.3.3 using decltype to simplify return type declarations6.5.2 constexprfunctions7.1.4 using = default togenerateadefaultconstructor7.3.1 in-class initializers formembersofclasstype7.5.2 delegatingconstructors7.5.6 constexprconstructors8.2.1 using strings for file names9.1 the array and forward_listcontainers9.2.3 container cbegin and cendfunctions9.2.4 list initializationforcontainers9.2.5 container nonmember swapfunctions9.3.1 return type for container insertmembers9.3.1 container emplacemembersxixxx new features in c++9.4 shrink_to_fit9.5.5 numeric conversion functions for strings10.3.2 lambdaexpressions10.3.3 trailing return type in lambda expressions10.3.4 the library bindfunction11.2.1 list initializationof anassociativecontainer11.2.3 list initializing pairreturntype11.3.2 list initialization of a pair11.4 theunorderedcontainers12.1 smartpointers12.1.1 the shared_ptrclass12.1.2 list initializationofdynamicallyallocatedobjects12.1.2 autoanddynamicallocation12.1.5 the unique_ptrclass12.1.6 the weak_ptrclass12.2.1 range for doesn‘t apply to dynamically allocatedarrays12.2.1 list initializationofdynamicallyallocatedarrays12.2.1 autocan’tbeusedtoallocateanarray12.2.2 allocator：：constructcanuseanyconstructor13.1.5 using = default forcopy-controlmembers13.1.6 using = delete topreventcopyingclassobjects13.5 movinginsteadofcopyingclassobjects13.6.1 rvaluereferences13.6.1 the library movefunction13.6.2 moveconstructor andmoveassignment13.6.2 move constructors usually should be noexcept13.6.2 moveiterators13.6.3 referencequalifiedmemberfunctions14.8.3 the functionclasstemplate14.9.1 explicitconversionoperators15.2.2 overridespecifier forvirtualfunctions15.2.2 preventing inheritance by defining a class as final15.3 override and final specifiers for virtual functions15.7.2 deletedcopycontrol andinheritance15.7.4 inheritedconstructors16.1.2 declaringatemplatetypeparameteras afriend16.1.2 templatetypealiases16.1.3 defaulttemplatearguments fortemplatefunctions16.1.5 explicitcontrolof instantiation16.2.3 template functions and trailing return types16.2.5 referencecollapsingrules16.2.6 static_cast fromanlvaluetoanrvalue16.2.7 the library forwardfunction16.4 variadictemplates16.4 the sizeof...operator16.4.3 variadictemplates andforwardingnew features in c++11 xxi17.1 the library tupleclasstemplate17.2.2 new bitsetoperations17.3 theregularexpressionlibrary17.4 therandomnumberlibrary17.5.1 floating-point formatcontrol18.1.4 the noexceptexceptionspecifier18.1.4 the noexceptoperator18.2.1 inlinenamespaces18.3.1 inheritedconstructors andmultiple inheritance19.3 scoped enums19.3 specifying the type used to hold an enum19.3 forward declarations for enums19.4.3 the library mem_fnclasstemplate19.6 unionmembersofclasstypes
