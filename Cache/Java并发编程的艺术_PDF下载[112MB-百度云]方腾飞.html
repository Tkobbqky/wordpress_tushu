Java并发编程的艺术 PDF下载 方腾飞 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711150824
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711150824
<p>书名:Java并发编程的艺术</p><p>作者:方腾飞</p><p>页数:239</p><p>定价:¥59.0</p><p>出版社:机械工业出版社</p><p>出版日期:2015-07-01</p><p>ISBN:9787111508243</p><p><h2>本书特色</h2></p>[<p>
第1章介绍java并发编程的挑战，会向读者说明可能会遇到哪些问题，以及如何解决。第2章java并发编程的底层实现原理，从cpu和jvm2个层面剖析。第3章详细深入介绍了java的内存模型。第4章从介绍多线程技术带来的好处开始，讲述了如何启动和终止线程以及线程的状态，详细阐述了多线程之间进行通信的基本方式和等待/通知经典范式。第5章介绍java并发包中与锁相关的api和组件，以及这些api和组件的使用方式和实现细节。第6章介绍了java中的大部分并发容器及其实现原理。第7章介绍了java中的原子操作类，并给出一些实例。第8章介绍了java中提供的很多并发工具类。第9章介绍了java中的线程池实现原理和使用建议。第10章介绍了executor框架的整体结构和成员组件。第11章介绍几个并发编程的实战与并发编程问题排查。
                                        </p>]<p><h2>目录</h2></p>
	前言第1章并发编程的挑战1.1上下文切换1.1.1多线程一定快吗1.1.2测试上下文切换次数和时长1.1.3如何减少上下文切换1.1.4减少上下文切换实战1.2死锁1.3资源限制的挑战1.4本章小结 第2章java并发机制的底层实现原理2.1volatile的应用2.2synchronized的实现原理与应用2.2.1java对象头2.2.2锁的升级与对比2.3原子操作的实现原理2.4本章小结 第3章java内存模型3.1java内存模型的基础3.1.1并发编程模型的两个关键问题3.1.2java内存模型的抽象结构3.1.3从源代码到指令序列的重排序3.1.4并发编程模型的分类3.1.5happensbefore简介3.2重排序3.2.1数据依赖性3.2.2asifserial语义3.2.3程序顺序规则3.2.4重排序对多线程的影响3.3顺序一致性3.3.1数据竞争与顺序一致性3.3.2顺序一致性内存模型3.3.3同步程序的顺序一致性效果3.3.4未同步程序的执行特性3.4volatile的内存语义3.4.1volatile的特性3.4.2volatile写读建立的happensbefore关系3.4.3volatile写读的内存语义3.4.4volatile内存语义的实现3.4.5jsr133为什么要增强volatile的内存语义3.5锁的内存语义3.5.1锁的释放获取建立的happensbefore关系3.5.2锁的释放和获取的内存语义3.5.3锁内存语义的实现3.5.4concurrent包的实现3.6final域的内存语义3.6.1final域的重排序规则3.6.2写final域的重排序规则3.6.3读final域的重排序规则3.6.4final域为引用类型3.6.5为什么final引用不能从构造函数内"溢出"3.6.6final语义在处理器中的实现3.6.7jsr133为什么要增强f?inal的语义3.7happensbefore3.7.1jmm的设计3.7.2happensbefore的定义3.7.3happensbefore规则3.8双重检查锁定与延迟初始化3.8.1双重检查锁定的由来3.8.2问题的根源3.8.3基于volatile的解决方案3.8.4基于类初始化的解决方案3.9java内存模型综述3.9.1处理器的内存模型3.9.2各种内存模型之间的关系3.9.3jmm的内存可见性保证3.9.4jsr133对旧内存模型的修补3.10本章小结 第4章java并发编程基础4.1线程简介4.1.1什么是线程4.1.2为什么要使用多线程4.1.3线程优先级4.1.4线程的状态4.1.5daemon线程4.2启动和终止线程4.2.1构造线程4.2.2启动线程4.2.3理解中断4.2.4过期的suspend()、resume()和stop()4.2.5安全地终止线程4.3线程间通信4.3.1volatile和synchronized关键字4.3.2等待/通知机制4.3.3等待/通知的经典范式4.3.4管道输入/输出流4.3.5thread.join()的使用4.3.6threadlocal的使用4.4线程应用实例4.4.1等待超时模式4.4.2一个简单的数据库连接池示例4.4.3线程池技术及其示例4.4.4一个基于线程池技术的简单web服务器4.5本章小结 第5章java中的锁5.1lock接口5.2队列同步器5.2.1队列同步器的接口与示例5.2.2队列同步器的实现分析5.3重入锁5.4读写锁5.4.1读写锁的接口与示例5.4.2读写锁的实现分析5.5locksupport工具5.6condition接口5.6.1condition接口与示例5.6.2condition的实现分析5.7本章小结 第6章java并发容器和框架6.1concurrenthashmap的实现原理与使用6.1.1为什么要使用concurrenthashmap6.1.2concurrenthashmap的结构6.1.3concurrenthashmap的初始化6.1.4定位segment6.1.5concurrenthashmap的操作6.2concurrentlinkedqueue6.2.1concurrentlinkedqueue的结构6.2.2入队列6.2.3出队列6.3java中的阻塞队列6.3.1什么是阻塞队列6.3.2java里的阻塞队列6.3.3阻塞队列的实现原理6.4fork/join框架6.4.1什么是fork/join框架6.4.2工作窃取算法6.4.3fork/join框架的设计6.4.4使用fork/join框架6.4.5fork/join框架的异常处理6.4.6fork/join框架的实现原理6.5本章小结 第7章java中的13个原子操作类7.1原子更新基本类型类7.2原子更新数组7.3原子更新引用类型7.4原子更新字段类7.5本章小结 第8章java中的并发工具类8.1等待多线程完成的countdownlatch8.2同步屏障cyclicbarrier8.2.1cyclicbarrier简介8.2.2cyclicbarrier的应用场景8.2.3cyclicbarrier和countdownlatch的区别8.3控制并发线程数的semaphore8.4线程间交换数据的exchanger8.5本章小结 第9章java中的线程池9.1线程池的实现原理9.2线程池的使用9.2.1线程池的创建9.2.2向线程池提交任务9.2.3关闭线程池9.2.4合理地配置线程池9.2.5线程池的监控9.3本章小结 第10章executor框架10.1executor框架简介10.1.1executor框架的两级调度模型10.1.2executor框架的结构与成员10.2threadpoolexecutor详解10.2.1fixedthreadpool详解10.2.2singlethreadexecutor详解10.2.3cachedthreadpool详解10.3scheduledthreadpoolexecutor详解10.3.1scheduledthreadpoolexecutor的运行机制10.3.2scheduledthreadpoolexecutor的实现10.4futuretask详解10.4.1futuretask简介10.4.2futuretask的使用10.4.3futuretask的实现10.5本章小结 第11章java并发编程实践11.1生产者和消费者模式11.1.1生产者消费者模式实战11.1.2多生产者和多消费者场景11.1.3线程池与生产消费者模式11.2线上问题定位11.3性能测试11.4异步任务池11.5本章小结	 
