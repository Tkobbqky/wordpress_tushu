Android C++高级编程-使用NDK PDF下载 辛纳 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730234301
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730234301
<p>书名:Android C++高级编程-使用NDK</p><p>作者:辛纳</p><p>页数:未知</p><p>定价:¥59.8</p><p>出版社:清华大学出版社</p><p>出版日期:2014-01-01</p><p>ISBN:9787302343011</p><p><h2>本书特色</h2></p>[<p>

	不管你是想将已经存在的原生代码应用移植到android平台上还是准备开始在android平台上进行软件开发，使用《android c++高级编程——使用ndk》一书提供的技术可以构建更出色的应用。本书将展示构建性能更好的复杂原生应用的方法。


	　 《android c++高级编程——使用ndk》提供了java原生接口(jni)的概述、bionic api、posix 线程和套接字、c++支持、原生图形和声音api以及neon/simd优化，在一个游戏应用案例的帮助下，你将学到很多关键技能。


	主要内容


	● 使用jni将原生代码连接到java中


	● 使用swig自动生成jni代码


	● 使用posix线程实现多线程应用


	● 使用posix套接字实现网络应用


	● 使用logging、gdb和eclipse调试器进行调试


	● 使用valgrind分析内存


	● 使用gprof 测试应用性能


	● 使用neon/simd优化代码


	● 使用eclipse ide开发原生代码


	　 《android c++高级编程——使用ndk》提供了移植、开发以及利用android平台上的c++和其他原生代码所需要的知识和技能，以便于运行图形化的高级应用和更复杂的原生应用。


	 


	 

                                        </p>]<p><h2>内容简介</h2></p>[<p>
	微软android平台skype客户端高级产品经理onur cinar*新作品，国内首本基于c++开发android应用书籍，书中源码免费提供下载
</p>]<p><h2>作者简介</h2></p>[<p>
	Onur Cinar有超过17年的移动和通信领域大规模复杂软件项目的设计、开发和管理经验。他的专业技能包括VoIP、视频通信、移动应用程序、网格计算和不同平台上的网络技术。从Android平台问世他就一直积极从事这方面的工作。他是Apress出版的Android Apps with Eclipse一书的作者。他在美国宾州费城Drexel大学获得计算机科学理学学士学位。现就职于微软Skype分部，任Android平台的Skype客户端高级产品工程经理。


	
</p>]<p><h2>目录</h2></p>
	目    录	第1章  android平台上的c++入门 1	1.1  microsoft windows  1	1.1.1  在windows平台上下载并安装jdk开发包 2	1.1.2  在windows平台上下载并安装apache ant 5	1.1.3  在windows平台上下载并安装android sdk    7	1.1.4  在windows平台上下载并安装cygwin 8	1.1.5  在windows平台上下载并安装android ndk    11	1.1.6  在windows平台上下载并安装eclipse    13	1.2  apple mac os x 14	1.2.1  在mac平台上安装xcode    14	1.2.2  验证mac平台的java开发包 15	1.2.3  验证mac平台上的apache ant   15	1.2.4  验证gnu make 16	1.2.5  在mac平台上下载并安装android sdk    16	1.2.6  在mac平台上下载并安装android ndk    18	1.2.7  在mac平台上下载并安装eclipse    19	1.3  ubuntu linux   20	1.3.1  检查gnu c库版本 20	1.3.2  激活在64位系统上支持32位的功能 21	1.3.3  在linux平台上下载并安装java开发工具包(jdk) 21	1.3.4  在linux平台上下载并安装apache ant   22	1.3.5  在linux平台上下载并安装gnu make 22	1.3.6  在linux平台上下载并安装android sdk  23	1.3.7  在linux平台上下载并安装android ndk  24	1.3.8  在linux平台上下载并安装eclipse  25	1.4  下载并安装adt  26	1.4.1  安装android平台包   29	1.4.2  配置模拟器   30	1.5  小结   33	第2章  深入了解androidndk 35	2.1  android ndk提供的组件  35	2.2  android ndk的结构  36	2.3  以一个示例开始 36	2.3.1  指定android ndk的位置   37	2.3.2  导入示例项目 37	2.3.3  向项目中添加原生支持 39	2.3.4  运行项目 40	2.3.5  用命令行对项目进行构建   41	2.3.6  检测android ndk项目的结构   42	2.4  构建系统   42	2.4.1  android.mk   43	2.4.2  application.mk   53	2.5  使用ndk-build脚本 54	2.6  排除构建系统故障   55	2.7  小结   56	第3章  用jni实现与原生代码通信 57	3.1  什么是jni  57	3.2  以一个示例开始 57	3.2.1  原生方法的声明   58	3.2.2  加载共享库   58	3.2.3  实现原生方法 59	3.3  数据类型   64	3.3.1  基本数据类型 64	3.3.2  引用类型 64	3.4  对引用数据类型的操作   65	3.4.1  字符串操作   65	3.4.2  数组操作 67	3.4.3  nio 操作 68	3.4.4  访问域   69	3.4.5  调用方法 71	3.4.6  域和方法描述符   72	3.5  异常处理   75	3.5.1  捕获异常 75	3.5.2  抛出异常 75	3.6  局部和全局引用 76	3.6.1  局部引用 76	3.6.2  全局引用 76	3.6.3  弱全局引用   77	3.7  线程   78	3.7.1  同步 78	3.7.2  原生线程 79	3.8  小结   79	第4章  使用swig自动生成jni代码   81	4.1  什么是swig 81	4.2  安装   82	4.2.1  windows平台上swig的安装 82	4.2.2  在mac os x下安装    83	4.2.3  在ubuntu linux下安装    85	4.3  通过示例程序试用swig   86	4.3.1  接口文件 86	4.3.2  在命令行方式下调用swig   89	4.3.3  将swig集成到android构建过程中  90	4.3.4  更新activity 92	4.3.5  执行应用程序 93	4.3.6  剖析生成的代码   93	4.4  封装c语言代码 94	4.4.1  全局变量 94	4.4.2  常量 95	4.4.3  只读变量 96	4.4.4  枚举 97	4.4.5  结构体   100	4.4.6  指针 101	4.5  封装c++代码    101	4.5.1  指针、引用和值   102	4.5.2  默认参数 103	4.5.3  重载函数 104	4.5.4  类   104	4.6  异常处理   106	4.7  内存管理   107	4.8  从原生代码中调用java   108	4.8.1  异步通信 108	4.8.2  启用directors    109	4.8.3  启用rtti 109	4.8.4  重写回调方法 109	4.8.5  更新hellojni activity    110	4.9  小结   110	第5章  日志、调试及故障处理    111	5.1  日志   111	5.1.1  框架 111	5.1.2  原生日志api  112	5.1.3  受控制的日志 114	5.1.4  控制台日志   118	5.2  调试   119	5.2.1  预备知识 119	5.2.2  调试会话建立 120	5.2.3  建立调试示例 121	5.2.4  启动调试器   121	5.3  故障处理   126	5.3.1  堆栈跟踪分析 127	5.3.2  对jni的扩展检查 128	5.3.3  内存问题 130	5.3.4  strace   133	5.4  小结   134	第6章  bionic api入门  135	6.1  回顾标准库 135	6.2  还有另一个c库 136	6.2.1  二进制兼容性 136	6.2.2  提供了什么   136	6.2.3  缺什么   137	6.3  内存管理   137	6.3.1  内存分配 137	6.3.2  c语言的动态内存管理  138	6.3.3  c++的动态内存管理    139	6.4  标准文件i/o    141	6.4.1  标准流   141	6.4.2  使用流i/o    141	6.4.3  打开流   142	6.4.4  写入流   143	6.4.5  流的读取 145	6.4.6  搜索位置 148	6.4.7  错误检查 149	6.4.8  关闭流   149	6.5  与进程交互 150	6.5.1  执行shell命令   150	6.5.2  与子进程通信 150	6.6  系统配置   151	6.6.1  通过名称获取系统属性值   152	6.6.2  通过名称获取系统属性 152	6.7  用户和组   153	6.7.1  获取应用程序用户和组id   153	6.7.2  获取应用程序用户名   154	6.8  进程间通信 154	6.9  小结   154	第7章  原生线程    155	7.1  创建线程示例项目   155	7.1.1  创建android项目 155	7.1.2  添加原生支持 157	7.1.3  声明字符串资源   157	7.1.4  创建简单的用户界面   157	7.1.5  实现main activity    159	7.1.6  生成c/c++头文件  162	7.1.7  实现原生函数 163	7.1.8  更新android.mk构建脚本  165	7.2  java 线程  165	7.2.1  修改示例应用程序使之能够使用java线程    165	7.2.2  执行java threads示例    166	7.2.3  原生代码使用java线程的优缺点    167	7.3  posix线程  168	7.3.1  在原生代码中使用posix线程   168	7.3.2  用pthread_create创建线程    168	7.3.3  更新示例应用程序以使用posix线程 169	7.3.4  执行posix线程示例   174	7.4  从posix线程返回结果   174	7.5  posix线程同步  176	7.5.1  用互斥锁同步posix线程   176	7.5.2  使用信号量同步posix线程 180	7.6  posix线程的优先级和调度策略    180	7.6.1  posix的线程调度策略  181	7.6.2  posix thread优先级   181	7.7  小结   181	第8章  posix socket api：面向连接的通信    183	8.1  echo socket示例应用    183	8.1.1  echo android应用项目 184	8.1.2  抽象echo activity    184	8.1.3  echo应用程序字符串资源   188	8.1.4  原生echo模块    188	8.2  用tcp sockets实现面向连接的通信   191	8.2.1  echo server activity的布局   192	8.2.2  echo server activity 193	8.2.3  实现原生tcp server   194	8.2.4  echo客户端activity布局  206	8.2.5  echo客户端activity  208	8.2.6  实现原生tcp客户端   210	8.2.7  更新android manifest 213	8.2.8  运行tcp sockets示例 214	8.3  小结   217	第9章  posix socket api：无连接的通信  219	9.1  将udp server方法添加到	echoserver activity中  219	9.2  实现原生udp server 220	9.2.1  创建udp socket：socket   220	9.2.2  从socket接收数据报：recvfrom    221	9.2.3  向socket发送数据报：sendto  223	9.2.4  原生udp server方法  224	9.3  将原生udp client方法加入	echoclient activity中  225	9.4  实现原生udp client 226	9.5  运行udp sockets示例   228	9.5.1  连通udp的模拟器 228	9.5.2  启动echo udp client  229	9.6  小结   229	第10章  posix socket api：本地通信 231	10.1  echo local activity布局   231	10.2  echo local activity   232	10.3  实现原生本地socket server 237	10.3.1  创建本地socket：socket  237	10.3.2  将本地socket与name绑定：bind  238	10.3.3  接受本地socket：accept  240	10.3.4  原生本地socket server   240	10.4  将本地echo activity添加到manifest中 242	10.5  运行本地 sockets示例  243	10.6  异步i/o   243	10.7  小结  244	第11章  支持c++    245	11.1  支持的c++运行库   245	11.1.1  gabi++ c++运行库    246	11.1.2  stlport c++运行库   246	11.1.3  gnu stl c++运行库   246	11.2  指定c++运行库 246	11.3  静态运行库与动态运行库    247	11.4  c++异常支持   247	11.5  c++ rtti支持  248	11.6  c++标准库入门 249	11.6.1  容器    249	11.6.2 迭代器  250	11.6.3  算法    251	11.7  c++运行库的线程安全   251	11.8  c++运行库调试模式 251	11.8.1  gnu stl调试模式 251	11.8.2  stlport调试模式 252	11.9  小结  253	第12章  原生图形api    255	12.1  原生图形api的可用性  255	12.2  创建一个avi视频播放器    256	12.2.1  将avilib作为ndk的一个导入模块 256	12.2.2  创建avi播放器android应用程序  258	12.2.3  创建avi player的main activity  258	12.2.4  创建abstract player activity    262	12.3  使用jni图形api进行渲染  269	12.3.1  启用jni graphics api    269	12.3.2  使用jni graphics api    270	12.3.3  用bitmap渲染来更新avi player   271	12.3.4  运行使用bitmap渲染的avi player 278	12.4  使用opengl es渲染    279	12.4.1  使用opengl es api   279	12.4.2  启用opengl es 1.x api   279	12.4.3  启用opengl es 2.0 api   280	12.4.4  用opengl es渲染来更新avi player    280	12.5  使用原生window api进行渲染   290	12.5.1  启用原生window api  290	12.5.2  使用原生window api  291	12.5.3  用原生window渲染器来更新avi player 293	12.5.4  egl图形库   301	12.6  小结  301	第13章  原生音频api    303	13.1  使用opensl es api 303	13.1.1  与opensl es标准的兼容性    304	13.1.2  音频许可    304	13.2  创建wave音频播放器   304	13.2.1  将wavelib作为ndk导入模块  304	13.2.2  创建wave播放器android应用程序 306	13.2.3  创建wave播放器主activity   306	13.2.4  实现wave aduio播放 310	13.3  运行wave audio player 327	13.4  小结  328	第14章  程序概要分析和neon优化 329	14.1  用gnu profiler度量性能   329	14.1.1  安装android ndk profiler    329	14.1.2  启用android ndk profiler    330	14.1.3  使用gnu profiler分析gmon.out文件  331	14.2  使用arm neon intrinsics进行优化  332	14.2.1  arm neon技术概述    333	14.2.2  给avi player添加一个亮度过滤器 333	14.2.3  为avi播放器启用android ndk profiler    336	14.2.4  avi player程序概要分析  337	14.2.5  使用neon intrinsics优化brightness filter   338	14.3  自动向量化    342	14.3.1  启用自动向量化  343	14.3.2  自动向量化问题的发现和排除  344	14.4  小结  344	 
