Java函数式编程 PDF下载 皮埃尔.伊夫斯.索蒙特 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712133021
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712133021
<p>书名:Java函数式编程</p><p>作者:皮埃尔.伊夫斯.索蒙特</p><p>页数:516</p><p>定价:¥119.0</p><p>出版社:电子工业出版社</p><p>出版日期:2018-01-01</p><p>ISBN:9787121330216</p><p><h2>节选</h2></p>[<p>为什么要函数式编程 
函数式编程中没有赋值语句，因此变量一旦有了值，就不会再改变了。更通俗地说，函数式编程完全没有副作用。除了计算结果，调用函数没有其他作用。这样便消除了 bug的一个主要来源，也使得执行顺序变得无关紧要 —因为没有能够改变表达式值的副作用，可以在任何时候对它求值。这样便把程序员从处理控制流程的负担中解脱出来。由于能够在任何时候对表达式求值，所以可以用变量的值来自由替换表达式，反之亦然 —程序是“引用透明”的。这样的自由度让函数式的程序比它们的一般对手在数学上更易驾驭。  
—John Hug 
</p>]<p><h2>内容简介</h2></p>[<p>《Java函数式编程》并不是一本关于Java的书，而是一本关于函数式编程的书。作者由浅入深地介绍了函数式编程的思维方式，并引导读者通过易于掌握的例子、练习和图表来学习和巩固函数式编程的基本原则和*佳实践。读者甚至可以在阅读的同时编写出自己的函数式类库！本书非常适合对Java有所了解的程序员，无须任何基础的数学理论或是函数式编程经验即可快速上手！</p>]<p><h2>作者简介</h2></p>[<p>Pierre-Yves Saumont是一名拥有三十年设计和构建企业级软件的Java开发者。他目前是Alcatel-Lucent Submarine Networks公司的一名软件研发工程师。高清华***软件研发工程师。工作十多年来，在简洁代码、自动化测试、持续交付、DevOps 等方面都有着丰富的经验。《DevOps 实践》译者之一。技术博客：http://qinghua.github.io/，希望能以通俗易懂的语言普及IT 技术。</p>]<p><h2>目录</h2></p>
    目录 

第1章　什么是函数式编程．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 1 

1．1　函数式编程是什么 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．2 

1．2　编写没有副作用的程序 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．4 

1．3　引用透明如何让程序更安全 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．6 

1．4　函数式编程的优势 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．7 

1．5　用代换模型来推断程序 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．8 

1．6　将函数式原则应用于一个简单的例子 ．．．．．．．．．．．．．9 

1．7　抽象到极致 ．15 

1．8　总结 ．．．．．．．．．．．．．16 

第2章　在Java中使用函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．17 

2．1　什么是函数 ．18 

2．1．1　现实世界里的函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．18 

2．2　Java中的函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．24 

2．2．1　函数式的方法 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．24 

2．2．2　Java的函数式接口与匿名类 ．．．．．．．．．．．．．．．30 

2．2．3　复合函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．31 

2．2．4　多态函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．32 

2．2．5　通过 lambda简化代码 ．．．．．．．．．．．．．．．．．．．．．．．．．．33 

2．3　高级函数特性 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．36 

2．3．1　多参函数怎么样 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．36 

2．3．2　应用柯里化函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．37 

2．3．3　高阶函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．38 

2．3．4　多态高阶函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．39 

2．3．5　使用匿名函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．43 

2．3．6　局部函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．45 

2．3．7　闭包 ．46 

2．3．8　部分函数应用和自动柯里化 ．．．．．．．．．．．．．．．48 

2．3．9　交换部分应用函数的参数 ．．．．．．．．．．．．．．．．．．．53 

2．3．10　递归函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．54 

2．3．11　恒等函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．56 

2．4　Java 8的函数式接口 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．58 

2．5　调试lambda ．．59 

2．6　总结 ．．．．．．．．．．．．．62 

第3章　让Java更加函数式 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．63 

3．1　使标准控制结构具有函数式风格 ．．．．．．．．．．．．．．．．．．．64 

3．2　抽象控制结构 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．65 

3．2．1　清理代码 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．69 

3．2．2　if … else的另一种方式 ．．．．．．．．．．．．．．．．．．．．．．．．73 

3．3　抽象迭代 ．．．．．78 

3．3．1　使用映射抽象列表操作 ．．．．．．．．．．．．．．．．．．．．．．．79 

3．3．2　创建列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．80 

3．3．3　使用 head和 tail操作．．．．．．．．．．．．．．．．．．．．．．．．．．．81 

3．3．4　函数式地添加列表元素 ．．．．．．．．．．．．．．．．．．．．．．．83 

3．3．5　化简和折叠列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．83 

3．3．6　复合映射和映射复合 ．．．．．．．．．．．．．．．．．．．．．．．．．．．90 

3．3．7　对列表应用作用 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．91 

3．3．8　处理函数式的输出 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．92 

3．3．9　构建反递归列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．93 

3．4　使用正确的类型 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．97 

3．4．1　标准类型的问题 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．97 

3．4．2　定义值类型 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．99 

3．4．3　值类型的未来 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．103 

3．5　总结 ．．．．．．．．．．．103 

第4章　递归、反递归和记忆化 ．．．．．．．．．．．．．．．．．．． 104 

4．1　理解反递归和递归 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．105 

4．1．1　探讨反递归和递归的加法例子 ．．．．．．．．．105 

4．1．2　在 Java中实现递归 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．106 

4．1．3　使用尾调用消除 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．107 

4．1．4　使用尾递归方法和函数 ．．．．．．．．．．．．．．．．．．．．．107 

4．1．5　抽象递归 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．108 

4．1．6　为基于栈的递归方法使用一个直接替代品 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．112 

4．2　使用递归函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．115 

4．2．1　使用局部定义的函数 ．．．．．．．．．．．．．．．．．．．．．．．．．115 

4．2．2　使函数成为尾递归 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．116 

4．2．3　双递归函数：斐波那契数列示例 ．．．．．117 

4．2．4　让列表的方法变成栈安全的递归 ．．．．．120 

4．3　复合大量函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．123 

4．4　使用记忆化 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．127 

4．4．1　命令式编程中的记忆化 ．．．．．．．．．．．．．．．．．．．．．127 

4．4．2　递归函数的记忆化 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．128 

4．4．3　自动记忆化 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．130 

4．5　总结 ．．．．．．．．．．．136 

第5章　用列表处理数据 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 138 

5．1　如何对数据集合进行分类 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．138 

5．1．1　不同的列表类型 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．139 

5．1．2　对列表性能的相对期望 ．．．．．．．．．．．．．．．．．．．．．140 

5．1．3　时间与空间，时间与复杂度的取舍 ．141 

5．1．4　直接修改 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．142 

5．1．5　持久化数据结构 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．143 

5．2　一个不可变、持久化的单链表实现 ．．．．．．．．．．．．．144 

5．3　在列表操作中共享数据 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．148 

5．3．1　更多列表操作 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．150 

5．4　使用高阶函数递归折叠列表 ．．．．．．．．．．．．．．．．．．．．．．．．．155 

5．4．1　基于堆的 foldRight递归版 ．．．．．．．．．．．．．．．．162 

5．4．2　映射和过滤列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．164 

5．5　总结 ．．．．．．．．．．．167 

第6章　处理可选数据 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 168 

6．1　空指针的问题 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．169 

6．2　空引用的替代方案 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．171 

6．3　Option数据类型 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．174 

6．3．1　从 Option中取值 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．176 

6．3．2　将函数应用于可选值 ．．．．．．．．．．．．．．．．．．．．．．．．．178 

6．3．3　复合 Option处理 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．179 

6．3．4　Option的用例 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．181 

6．3．5　复合 Option的其他方法 ．．．．．．．．．．．．．．．．．．．．186 

6．3．6　复合 Option和 List ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．189 

6．4　Option的其他实用程序 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．191 

6．4．1　检查是 Some还是 None ．．．．．．．．．．．．．．．．．．．．．191 

6．4．2　equals和 hashcode ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．192 

6．5　如何及何时使用Option ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．193 

6．6　总结 ．．．．．．．．．．．195 

第7章　处理错误和异常 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 197 

7．1　待解决的问题 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．197 

7．2　Either类型 ．．199 

7．2．1　复合 Either ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．200 

7．3　Result类型 ．203 

7．3．1　为 Result类添加方法 ．．．．．．．．．．．．．．．．．．．．．．．．．204 

7．4　Result模式 ．206 

7．5　Result处理进阶 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．213 

7．5．1　应用断言 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．214 

7．5．2　映射 Failure ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．215 

7．5．3　增加工厂方法 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．218 

7．5．4　应用作用 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．220 

7．5．5　Result复合进阶 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．222 

7．6　总结 ．．．．．．．．．．．226 

第8章　列表处理进阶 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 228 

8．1　length的问题 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．229 

8．1．1　性能问题 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．229 

8．1．2　记忆化的优点 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．230 

8．1．3　记忆化的缺点 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．230 

8．1．4　实际性能 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．232 

8．2　复合List和Result ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．233 

8．2．1　List中返回 Result的方法 ．．．．．．．．．．．．．．．．．．233 

8．2．2　将 List＜Result＞转换为 Result＜List＞ 235 

8．3　抽象常见列表用例 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．238 

8．3．1　压缩和解压缩列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．238 

8．3．2　通过索引访问元素 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．241 

8．3．3　拆分列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．244 

8．3．4　搜索子列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．248 

8．3．5　使用列表的其他函数 ．．．．．．．．．．．．．．．．．．．．．．．．．249 

8．4　自动并行处理列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．254 

8．4．1　并非所有的计算都可以并行化 ．．．．．．．．．254 

8．4．2　将列表拆分为子列表 ．．．．．．．．．．．．．．．．．．．．．．．．．254 

8．4．3　并行处理子列表 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．256 

8．5　总结 ．．．．．．．．．．．258 

第9章　使用惰性．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 259 

9．1　理解严格和惰性 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．259 

9．1．1　Java是一门严格的语言 ．．．．．．．．．．．．．．．．．．．．．260 

9．1．2　严格带来的问题 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．261 

9．2　实现惰性 ．．．263 

9．3　只有惰性才能做到的事 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．264 

9．4　为何不要用Java 8中的Stream ．．．．．．．．．．．．．．．．．．．．．．．．265 

9．5　创建一个惰性列表数据结构 ．．．．．．．．．．．．．．．．．．．．．．．．．266 

9．5．1　记忆已计算的值 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．268 

9．5．2　对流的操作 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．271 

9．6　惰性的真正本质 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．274 

9．6．1　折叠流 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．277 

9．7　处理无限流 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．282 

9．8　避免null引用和可变字段 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．285 

9．9　总结 ．．．．．．．．．．．287 

第10章　用树进行更多数据处理．．．．．．．．．．．．．．．．．． 289 

10．1　二叉树 ．．．．．290 

10．1．1　平衡树和非平衡树 ．．．．．．．．．．．．．．．．．．．．．．．．．291 

10．1．2　大小、高度和深度 ．．．．．．．．．．．．．．．．．．．．．．．．．291 

10．1．3　叶树 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．292 

10．1．4　有序二叉树或二叉搜索树 ．．．．．．．．．．．．．292 

10．1．5　插入顺序 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．293 

10．1．6　树的遍历顺序 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．294 

10．2　实现二叉搜索树 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．297 

10．3　从树中删除元素 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．303 

10．4　合并任意树 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．304 

10．5　折叠树 ．．．．．310 

10．5．1　用两个函数折叠 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．311 

10．5．2　用一个函数折叠 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．313 

10．5．3　选择哪种折叠的实现 ．．．．．．．．．．．．．．．．．．．．．314 

10．6　映射树 ．．．．．316 

10．7　平衡树 ．．．．．317 

10．7．1　旋转树 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．317 

10．7．2　使用 DSW算法平衡树 ．．．．．．．．．．．．．．．．．．320 

10．7．3　自动平衡树 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．322 

10．7．4　解决正确的问题 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．323 

10．8　总结 ．．．．．．．．．324 

第11章　用高级树来解决真实问题．．．．．．．．．．．．．．． 325 

11．1　性能更好且栈安全的自平衡树 ．．．．．．．．．．．．．．．．．．．．326 

11．1．1　树的基本结构 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．326 

11．1．2　往红黑树中插入元素 ．．．．．．．．．．．．．．．．．．．．．331 

11．2　红黑树的用例：map ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．337 

11．2．1　实现 map ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．337 

11．2．2　扩展 map ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．340 

11．2．3　使用键不可比较的 map ．．．．．．．．．．．．．．．．．341 

11．3　实现函数式优先队列 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．344 

11．3．1　优先队列访问协议 ．．．．．．．．．．．．．．．．．．．．．．．．．344 

11．3．2　优先队列使用案例 ．．．．．．．．．．．．．．．．．．．．．．．．．344 

11．3．3　实现需求 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．345 

11．3．4　左倾堆数据结构 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．345 

11．3．5　实现左倾堆 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．346 

11．3．6　实现像队列一样的接口 ．．．．．．．．．．．．．．．．．351 

11．4　元素不可比较的优先队列 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．352 

11．5　总结 ．．．．．．．．．．358 

第12章　用函数式的方式处理状态改变 ．．．．．．．． 359 

12．1　一个函数式的随机数发生器 ．．．．．．．．．．．．．．．．．．．．．．．360 

12．1．1　随机数发生器接口 ．．．．．．．．．．．．．．．．．．．．．．．．．361 

12．1．2　实现随机数发生器 ．．．．．．．．．．．．．．．．．．．．．．．．．362 

12．2　处理状态的通用API ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．366 

12．2．1　使用状态操作 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．367 

12．2．2　复合状态操作 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．368 

12．2．3　递归状态操作 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．370 

12．3　通用状态处理 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．372 

12．3．1　状态模式 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．374 

12．3．2　构建一个状态机 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．375 

12．3．3　何时使用状态和状态机 ．．．．．．．．．．．．．．．．．381 

12．4　总结 ．．．．．．．．．381 

第13章　函数式输入/输出．．．．．．．．．．．．．．．．．．．．．．．．．． 382 

13．1　在上下文中应用作用 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．383 

13．1．1　作用是什么 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．384 

13．1．2　实现作用 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．384 

13．1．3　用于失败情况的更强大的作用 ．．．．．387 

13．2　读取数据 ．390 

13．2．1　从控制台读取 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．390 

13．2．2　从文件中读取 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．395 

13．2．3　检查输入 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．396 

13．3　真正的函数式输入/输出 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．398 

13．3．1　怎样才能让输入 /输出是完全函数式的 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．398 

13．3．2　实现纯函数式的输入 /输出 ．．．．．．．．．．399 

13．3．3　合并 IO．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．400 

13．3．4　用 IO处理输入．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．402 

13．3．5　扩展 IO类型．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．404 

13．3．6　使 IO类型栈安全．．．．．．．．．．．．．．．．．．．．．．．．．．．407 

13．4　总结 ．．．．．．．．．413 

第14章　通过actor共享可变状态．．．．．．．．．．．．．．．．． 414 

14．1　actor模型 ．415 

14．1．1　异步消息 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．416 

14．1．2　处理并行 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．416 

14．1．3　处理 actor状态变化 ．．．．．．．．．．．．．．．．．．．．．．．417 

14．2　构建actor框架 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．418 

14．2．1　actor框架的限制 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．418 

14．2．2　设计 actor框架接口 ．．．．．．．．．．．．．．．．．．．．．．．418 

14．2．3　AbstractActor的实现 ．．．．．．．．．．．．．．．．．．．．．420 

14．3　开始使用actor ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．422 

14．3．1　实现乒乓示例 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．422 

14．3．2　一个更严谨的例子：并行运行一个计算 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．424 

14．3．3　重新排序结果 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．430 

14．3．4　解决性能问题 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．433 

14．4　总结 ．．．．．．．．．439 

第15章　以函数式的方式解决常见问题 ．．．．．．．． 440 

15．1　使用断言来校验数据 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．441 

15．2　从文件中读取属性 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．446 

15．2．1　载入属性文件 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．446 

15．2．2　将属性读取为字符串 ．．．．．．．．．．．．．．．．．．．．．447 

15．2．3　生成更好的错误消息 ．．．．．．．．．．．．．．．．．．．．．448 

15．2．4　像列表那样读取属性 ．．．．．．．．．．．．．．．．．．．．．451 

15．2．5　读取枚举值 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．453 

15．2．6　读取任意类型的属性 ．．．．．．．．．．．．．．．．．．．．．454 

15．3　转换命令式程序：XML读取器 ．．．．．．．．．．．．．．．．．．．457 

15．3．1　列出必需的函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．459 

15．3．2　复合函数并应用作用 ．．．．．．．．．．．．．．．．．．．．．460 

15．3．3　实现函数 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．461 

15．3．4　让程序更加函数式 ．．．．．．．．．．．．．．．．．．．．．．．．．462 

15．3．5　修复参数类型问题 ．．．．．．．．．．．．．．．．．．．．．．．．．466 

15．3．6　以处理元素的函数为参数 ．．．．．．．．．．．．．467 

15．3．7　处理元素名称错误 ．．．．．．．．．．．．．．．．．．．．．．．．．468 

15．4　总结 ．．．．．．．．．470 

附录A　使用Java 8的函数式特性 ．．．．．．．．．．．．．．．． 471 

附录B　Monad．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 479 

附录C　敢问路在何方 ．．．．．．．．．．．．．．．．．．．．．．．．．．．．．．． 485
