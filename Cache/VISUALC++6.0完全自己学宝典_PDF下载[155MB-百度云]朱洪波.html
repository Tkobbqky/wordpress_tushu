VISUALC++6.0完全自己学宝典 PDF下载 朱洪波 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730217596
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730217596
<p>书名:VISUALC++6.0完全自己学宝典</p><p>作者:朱洪波</p><p>页数:610 页</p><p>定价:¥68.0</p><p>出版社:清华大学出版社</p><p>出版日期:2008-07-01</p><p>ISBN:9787302175964</p><p><h2>节选</h2></p>[<p>Visual C++ 6.0是微软公司为程序人员提供的Visual Studio 6.0工具套件中的重要组成部分。本书由浅入深地介绍使用Visual C++ 6.0进行Windows应用程序开发的一般过程和方法，既包含相关的理论讲解，又安排相应的实例作为补充，以期从理论和实践两个方面帮助读者了解相关的知识，并掌握相关的技能。全书分为5篇，其中第1篇介绍使用Visual C++ 6.0进行Windows应用程序开发所应该具备的基础知识。第2篇和第3篇是本书的主要内容，分别介绍常见的应用程序开发和高级的应用程序开发。第4篇作为补充性的内容，介绍Visual C++ 6.0常用的数据结构，此外还介绍常用的调试技巧和编程技巧等。*后一篇是实例篇，通过一个非常完整的实例，复习前面所学知识，并锻炼读者的动手和思考能力。与同类书籍相比，本书的内容十分丰富，除了涵盖常见知识点，本书还尽可能地穿插介绍一些有益于读者掌握的Windows编程知识。此外，本书介绍了一些在工程中经常使用的工具、编程技巧等。全书将理论和实践有机地结合起来穿插在全书的各个章节进行讲解，以帮助读者更好地掌握相关知识。本书适合Visual C++ 6.0初学者、C++自学者和一些想学习C++的其他开发人员阅读，也可作为高级开发人员的参考资料。</p>]<p><h2>目录</h2></p>
    第1篇  C++程序设计语言入门第1章  C++程序设计语言概述 21.1  C++和C#、Java的区别 21.1.1  面向对象还是面向过程 21.1.2  内存管理是否自动释放 21.1.3  是否跨平台 31.1.4  C++与其他语言的主要区别 31.2  C++语言的主要应用领域 41.3  C++的开发工具以及Visual C++ 6.0 51.3.1  Visual C++ 6.0开发工具简介 51.3.2  Visual C++ 6.0的开发过程 6第2章  Visual C++ 6.0入门 72.1  安装Visual C++ 6.0 72.1.1  对硬件的要求 72.1.2  安装Visual C++ 6.0 82.1.3  安装MSDN Library 92.1.4  安装源代码管理器 112.1.5  完成安装 112.1.6  安装Visual C++ 6.0开发插件 122.1.7  编写宏文件 122.1.8  使用宏文件 152.2  Visual C++ 6.0开发环境介绍 172.2.1  熟悉Visual C++ 6.0开发环境 172.2.2  建立一个工程 182.2.3  工程菜单 212.2.4  编译菜单 222.2.5  Tools菜单 232.2.6  工具条 232.3  创建**个Visual C++程序 242.3.1  编写代码 242.3.2  编译程序 252.3.3  运行程序 252.4  使用源代码管理器 252.4.1  基本概念 262.4.2  创建数据库 262.4.3  根据现有工程在服务端创建文件夹 272.4.4  代码入库和出库 272.4.5  版本控制（Label） 292.5  常见问题 292.5.1  必须安装和Visual C++ 6.0配套发行的MSDN Library吗 292.5.2  可以在Visual C++ 6.0下使用其他的C++编译器吗 29第3章  C++基础语法 303.1  变量和常量 303.2  C++基础数据类型 313.2.1  整值类型 313.2.2  浮点值类型 323.2.3  布尔类型 333.2.4  字符串类型 333.3  C++高级数据类型 343.3.1  枚举类型 343.3.2  结构类型 363.3.3  联合类型 373.3.4  数组类型 383.4  指针和引用 403.4.1  指针变量的声明与初始化 413.4.2  指针运算符：& 433.4.3  指针运算符：* 443.4.4  指针运算符：:: 453.4.5  指针运算 473.4.6  指针与常量限定符 483.4.7  指针与数组 493.4.8  引用 503.5  表达式和运算符 523.5.1  表达式的定义 523.5.2  基本运算符 523.5.3  逻辑运算操作符 533.5.4  ==、>、>=、3.5.5  ++、--操作符 533.5.6  位操作符 543.5.7  new/delete操作符 543.6  程序控制结构 563.6.1  switch/case结构 563.6.2  if/else/else if结构 583.6.3  goto语句 593.6.4  for循环语句 593.6.5  while与do/while循环语句 613.6.6  break语句 623.6.7  continue语句 633.7  函数 643.7.1  函数的定义 643.7.2  函数的返回类型 653.7.3  函数的参数 653.7.4  参数传递 663.7.5  函数的默认参数 683.8  常见问题 693.8.1  new/delete操作符和malloc/free函数有何区别 693.8.2  应该使用const修饰符还是宏 70第4章  C++面向对象编程 724.1  类的基本概念和特性 724.1.1  类和结构 724.1.2  类的数据成员 734.1.3  类的成员函数 744.1.4  类成员访问级别 754.1.5  类声明、类定义和类实现 764.1.6  类的内联函数和非内联函数 784.1.7  构造函数 784.1.8  析构函数 814.1.9  this指针 824.1.10  友元 824.1.11  静态成员 844.2  类的派生和继承 874.2.1  public继承 874.2.2  protected继承 984.2.3  private继承 1004.3  常见问题 1004.3.1  析构函数是否可以定义为虚函数，有何用处 1014.3.2  在C++中struct被赋予了哪些类的特征 102第5章  异常及其处理 1045.1  异常的产生 1045.2  异常的处理 1065.3  深入了解异常 1095.3.1  异常的再抛出 1095.3.2  异常的参数传递 1105.4  Visual C++ 6.0中的异常 1125.4.1  关键字_try/_except/_finally 1125.4.2  TRY/CATCH宏 1125.5  常见问题 1135.5.1  应该怎样设计异常 1135.5.2  如何避免使用异常 114第2篇  使用Visual C++ 6.0进行常用开发第6章  Visual C++ 6.0开发起步 1166.1  Windows消息机制 1166.1.1  什么是消息 1166.1.2  消息的分类 1176.1.3  消息的处理过程 1186.2  Win32 API介绍 1186.2.1  API的分类 1186.2.2  API的用途 1196.2.3  在Visual C++ 6.0中使用Win32 API 1196.3  MFC介绍 1196.3.1  MFC的来源和用途 1206.3.2  MFC的基本框架结构 1206.3.3  使用MFC 1216.4  常见问题 1226.4.1  如何自定义消息 1226.4.2  Win32 API定义了哪些数据类型 1236.4.3  Visual C++、Win32 API和MFC之间的关系 1246.4.4  使用C++开发Windows应用程序必须使用Win32 API或者MFC吗 124第7章  开发基于对话框的应用程序 1267.1  使用向导生成应用程序框架 1267.1.1  建立基于对话框的应用程序框架 1267.1.2  控件 1287.2  基于对话框的程序基本框架 1287.2.1  应用程序的入口函数 1297.2.2  MFC应用程序的入口点 1307.2.3  CDemo1App类解析 1317.2.4  CDemo1Dlg类框架解析 1327.2.5  CDemo1Dlg类解析 1347.3  实现数据交互 1367.3.1  使用类向导编辑控件属性 1377.3.2  使用类向导实现数据交互 1377.4  实现消息映射 1397.4.1  消息的分类 1407.4.2  消息的处理 1407.4.3  处理【OK】按钮单击事件 1417.4.4  程序实现 1437.4.5  自定义控件 1457.5  实战：简易计算器 1487.5.1  程序界面设计 1487.5.2  简易计算器的业务逻辑 1497.5.3  简易计算器的状态 1507.5.4  简易计算器的实现 1517.6  常见问题 1597.6.1  如何响应自定义消息 1597.6.2  如何在窗体中使用定时器 160第8章  文档/视图结构 1638.1  基础知识 1638.1.1  单文档视图和多文档视图结构 1638.1.2  文件类型 1648.1.3  使用向导生成一个简单的记事本 1648.2  单文档/视图结构 1668.2.1  CDocViewApp应用程序类解析 1668.2.2  修改CDocViewApp类使得程序支持多种文件类型 1688.2.3  CMainFrame框架类解析 1718.2.4  CDocViewDoc文档类解析 1738.2.5  CDocViewView视图类解析 1748.3  多文档/视图结构 1748.4  实战：使用单文档/视图结构实现八数码游戏 1758.4.1  需求分析 1768.4.2  设计并实现操作接口的主框架 1768.4.3  设计并实现棋盘数据结构 1788.4.4  在CEightDoc类中添加棋盘类的对象 1828.4.5  在CMainFrame类中实现对棋盘的控制 1828.4.6  在CEightView类中实现对棋盘的控制 1848.4.7  在CEightView类中实现对棋盘的绘制 1858.4.8  实现智能解题 1888.5  常见问题 1948.5.1  CFrameWnd、CView、CDocument是如何协作的 1948.5.2  MFC中包含了哪些CView的派生类 195第9章  使用Visual C++ 6.0开发动态链接库 1969.1  动态链接库基础 1969.1.1  创建静态链接库 1969.1.2  使用静态链接库 1979.1.3  创建简单的动态链接库 1999.1.4  使用动态链接库 2019.1.5  动态链接库和静态链接库的比较 2039.1.6  规则DLL和扩展DLL 2039.2  开发Win32动态链接库 2049.2.1  动态链接库的初始化和反初始化 2049.2.2  导出、导入函数和数据 2069.3  开发基于MFC的动态链接库 2089.3.1  创建链接MFC的规则DLL 2089.3.2  MFC扩展 DLL 2109.4  实战：使用动态链接库实现界面和功能实现的分离 2129.5  常见问题 2179.5.1  AFX_MANAGE_STATE宏有何作用，何时需要使用该宏 2179.5.2  MFCDLL能导出C++类、成员函数吗 2189.5.3  如何只导出部分类成员 2189.5.4  LoadLibrary和FreeLibrary函数的用途有哪些，什么是显式加载动态链接库 2199.5.5  DEPENDS工具的用处有哪些 2209.5.6  Windows操作系统用来定位DLL的搜索路径是怎样的 220第3篇  使用Visual C++ 6.0进行高级开发第10章  多线程开发 22210.1  为什么需要多线程 22210.2  基础知识 22210.2.1  进程与线程 22210.2.2  关于“同时执行”、“并发处理” 22310.3  线程的创建与结束 22410.3.1  Sleep函数 22410.3.2  CreateThread/ExitThread函数 22510.3.3  _beginthreadex/_endthreadex函数 22710.3.4  AfxBeginThread/AfxEndThread函数 22810.3.5  选择哪种函数创建线程 23110.4  线程的调度 23310.4.1  优先权类别 23310.4.2  优先权层级 23410.5  核心对象 23410.5.1  什么是核心对象 23510.5.2  CloseHandle函数 23510.6  线程同步 23610.6.1  同步机制简介 23610.6.2  临界区域（Critical Section） 23610.6.3  使用临界区域保证数据访问的安全性 23810.6.4  安全退出临界区域 24010.6.5  互斥器（Mutexes） 24210.6.6  使用互斥器设计线程安全的数据结构 24410.6.7  信号量（Semaphores） 24910.6.8  事件（Event Objects） 25110.6.9  使用事件通知线程安全地退出 25310.6.10  WaitForSingleObject系列函数 25410.7  再论线程的创建和退出 25510.7.1  回顾 25510.7.2  创建线程的一个习惯用法 25610.7.3  协作式退出线程 25710.8  实战：多线程实现百米赛跑模拟 25810.8.1  设计界面 25910.8.2  设计相关数据结构 25910.8.3  实现自定义消息响应 26210.9  常见问题 26510.9.1  在多线程情况下，使用STL（标准模板库）应该注意什么 26510.9.2  临界区域（Critical Section）相比本章介绍的相关核心对象有何优缺点 265第11章  数据库应用开发 266
