Scala程序设计-第2版 PDF下载 万普勒 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711541681
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711541681
<p>书名:Scala程序设计-第2版</p><p>作者:万普勒</p><p>页数:473</p><p>定价:¥109.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2016-03-01</p><p>ISBN:9787115416810</p><p><h2>本书特色</h2></p>[<p>
本书通过大量的代码示例，全面介绍scala这门针对jvm的编程语言，向读者展示了如何高效地利用scala语言及其生态系统，同时解释了为何scala是开发高扩展性、以数据为中心的应用程序的理想语言。本书既适合scala初学者入门，也适合经验丰富的scala开发者参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书全面介绍scala这门针对jvm的编程语言，它集成了现代对象模型、函数式编程和先进类型系统的所有优势。通过大量的代码示例，本书向读者展示了如何高效地利用scala语言及其生态系统，同时解释了为何scala是开发高扩展性、以数据为中心的应用程序的理想语言。第2版还介绍了scala的新特性，新增了模式匹配和高级函数式编程的章节。此外，读者还可以学到scala的命令行工具、第三方工具、库等。 </p>]<p><h2>作者简介</h2></p>[<p>Dean Wampler博士是Typesafe公司的大数据产品架构师。Typesafe使用Scala、函数式编程、Spark、Hadoop以及Akka技术编写以数据为中心的工具和服务。Dean是《面向Java开发者的函数式编程》的作者，同时也与他人合著了《Hive编程指南》一书。Alex Payne是Twitter的平台组长。在Alex开发的服务基础上，其他的程序开发者构造了一套备受欢迎的社交消息服务。此前，Alex还为政治竞选、公益性组织以及初创企业编写过一些Web应用。</p>]<p><h2>目录</h2></p>
    第1章　零到六十：scala简介　　11.1　为什么选择scala　　11.1.1　富有魅力的scala　　21.1.2　关于java 8　　31.2　安装scala　　31.2.1　使用sbt　　51.2.2　执行scala命令行工具　　61.2.3　在ide中运行scala repl　　81.3　使用scala　　81.4　并发　　171.5　本章回顾与下一章提要　　27第2章　更简洁，更强大　　282.1　分号　　282.2　变量声明　　292.3　range　　312.4　偏函数　　322.5　方法声明　　332.5.1　方法默认值和命名参数列表　　332.5.2　方法具有多个参数列表　　342.5.3　future简介　　352.5.4　嵌套方法的定义与递归　　382.6　推断类型信息　　402.7　保留字　　442.8　字面量　　462.8.1　整数字面量　　462.8.2　浮点数字面量　　472.8.3　布尔型字面量　　482.8.4　字符字面量　　482.8.5　字符串字面量　　482.8.6　符号字面量　　502.8.7　函数字面量　　502.8.8　元组字面量　　502.9　option、some 和none：避免使用null　　522.10　封闭类的继承　　532.11　用文件和名空间组织代码　　542.12　导入类型及其成员　　552.12.1　导入是相对的　　562.12.2　包对象　　572.13　抽象类型与参数化类型　　572.14　本章回顾与下一章提要　　59第3章　要点详解　　603.1　操作符重载?　　603.2　无参数方法　　633.3　优先级规则　　643.4　领域特定语言　　653.5　scala中的if语句　　663.6　scala中的for推导式　　673.6.1　for循环　　673.6.2　生成器表达式　　673.6.3　保护式：筛选元素　　673.6.4　yielding　　683.6.5　扩展作用域与值定义　　693.7　其他循环结构　　703.7.1　scala的while循环　　713.7.2　scala中的do-while循环　　713.8　条件操作符　　713.9　使用try、catch和final子句　　723.10　名字调用和值调用　　753.11　惰性赋值　　783.12　枚举　　793.13　可插入字符串　　813.14　trait：scala语言的接口和“混入”　　833.15　本章回顾与下一章提要　　85第4章　模式匹配　　864.1　简单匹配　　864.2　match中的值、变量和类型　　874.3　序列的匹配　　904.4　元组的匹配　　944.5　case中的guard语句　　944.6　case类的匹配　　954.6.1　unapply方法　　964.6.2　unapplyseq方法　　1004.7　可变参数列表的匹配　　1014.8　正则表达式的匹配　　1034.9　再谈case语句的变量绑定　　1044.10　再谈类型匹配　　1044.11　封闭继承层级与全覆盖匹配　　1054.12　模式匹配的其他用法　　1074.13　总结关于模式匹配的评价　　1114.14　本章回顾与下一章提要　　111第5章　隐式详解　　1125.1　隐式参数　　1125.2　隐式参数适用的场景　　1155.2.1　执行上下文　　1155.2.2　功能控制　　1155.2.3　限定可用实例　　1165.2.4　隐式证据　　1205.2.5　绕开类型擦除带来的限制　　1225.2.6　改善报错信息　　1245.2.7　虚类型　　1245.2.8　隐式参数遵循的规则　　1275.3　隐式转换　　1285.3.1　构建独有的字符串插入器　　1325.3.2　表达式问题　　1345.4　类型类模式　　1355.5　隐式所导致的技术问题　　1375.6　隐式解析规则　　1395.7　scala内置的各种隐式　　1395.8　合理使用隐式　　1465.9　本章回顾与下一章提要　　146第6章　scala函数式编程　　1476.1　什么是函数式编程　　1486.1.1　数学中的函数　　1486.1.2　不可变变量　　1496.2　scala中的函数式编程　　1516.2.1　匿名函数、lambda与闭包　　1526.2.2　内部与外部的纯粹性　　1546.3　递归　　1546.4　尾部调用和尾部调用优化　　1556.5　偏应用函数与偏函数　　1576.6　curry化与函数的其他转换　　1586.7　函数式编程的数据结构　　1626.7.1　序列　　1626.7.2　映射表　　1666.7.3　集合　　1686.8　遍历、映射、过滤、折叠与归约　　1686.8.1　遍历　　1696.8.2　映射　　1706.8.3　扁平映射　　1726.8.4　过滤　　1736.8.5　折叠与归约　　1746.9　向左遍历与向右遍历　　1786.10　组合器：软件*佳组件抽象　　1836.11　关于复制　　1866.12　本章回顾与下一章提要　　188第7章　深入学习for推导式　　1897.1　内容回顾：for推导式组成元素　　1897.2　for推导式：内部机制　　1927.3　for推导式的转化规则　　1947.4　option以及其他的一些容器类型　　1977.4.1　option容器　　1977.4.2　either：option类型的逻辑扩展　　2007.4.3　try类型　　2057.4.4　scalaz提供的validation类　　2067.5　本章回顾与下一章提要　　209第8章　scala面向对象编程　　2108.1　类与对象初步　　2118.2　引用与值类型　　2138.3　价值类　　2148.4　父类　　2178.5　scala的构造器　　2178.6　类的字段　　2218.6.1　统一访问原则　　2238.6.2　一元方法　　2248.7　验证输入　　2248.8　调用父类构造器（与良好的面向对象设计）　　2268.9　嵌套类型　　2308.10　本章回顾与下一章提要　　232第9章　特征　　 2339.1　java 8中的接口　　2339.2　混入trait　　2349.3　可堆叠的特征　　2389.4　构造trait　　2439.5　选择类还是trait　　2449.6　本章回顾与下一章提要　　245第10章　scala对象系统（i）　　24610.1　参数化类型：继承转化　　24610.1.1　hood下的函数　　24710.1.2　可变类型的变异　　25010.1.3　scala和java中的变异　　25210.2　scala的类型层次结构　　25310.3　闲话nothing（以及null）　　25410.4　product、case类和元组　　25810.5　predef对象　　26010.5.1　隐式转换　　26010.5.2　类型定义　　26210.5.3　条件检查方法　　26310.5.4　输入输出方法　　26310.5.5　杂项方法　　26510.6　对象的相等　　26510.6.1　equals方法　　26610.6.2　== 和!=方法　　26610.6.3　eq 和ne方法　　26710.6.4　数组相等和sameelements方法　　26710.7　本章回顾与下一章提要　　268第11章　scala对象系统（ii）　　26911.1　覆写类成员和trait成员　　26911.2　尝试覆写final声明　　27211.3　覆写抽象方法和具体方法　　27211.4　覆写抽象字段和具体字段　　27411.5　覆写抽象类型　　28011.6　无须区分访问方法和字段：统一访问原则　　28011.7　对象层次结构的线性化算法　　28211.8　本章回顾与下一章提要　　287第12章　scala集合库　　28812.1　通用、可变、不可变、并发以及并行集合　　28812.1.1　scala.collection包　　28912.1.2　collection.concurrent包　　29012.1.3　collection.convert包　　29112.1.4　collection.generic包　　29112.1.5　collection.immutable包　　29112.1.6　scala.collection.mutable包　　29212.1.7　scala.collection.parallel包　　29412.2　选择集合　　29512.3　集合库的设计惯例　　29612.3.1　builder　　29612.3.2　canbuildfrom　　29712.3.3　like特征　　29812.4　值类型的特化　　29812.5　本章回顾与下一章提要　　300第13章　可见性规则　　30113.1　默认可见性：公有可见性　　30113.2　可见性关键字　　30213.3　public可见性　　30313.4　protected可见性　　30413.5　private可见性　　30513.6　作用域内私有和作用域内受保护可见性　　30613.7　对可见性的想法　　31213.8　本章回顾与下一章提要　　313第14章　scala类型系统（i）　　31414.1　参数化类型　　31514.1.1　变异标记　　31514.1.2　类型构造器　　31514.1.3　类型参数的名称　　31514.2　类型边界　　31514.2.1　类型边界上限　　31614.2.2　类型边界下限　　31614.3　上下文边界　　32014.4　视图边界　　32014.5　理解抽象类型　　32214.6　自类型标记　　32514.7　结构化类型　　32914.8　复合类型　　33214.9　存在类型　　33414.10　本章回顾与下一章提要　　335第15章　scala类型系统（ii）　　33615.1　路径相关类型　　33615.1.1　c.this　　33715.1.2　c.super　　33715.1.3　path.x　　33815.2　依赖方法类型　　33915.3　类型投影　　34015.4　值的类型　　34315.4.1　元组类型　　34315.4.2　函数类型　　34315.4.3　中缀类型　　34315.5　higher-kinded类型　　34415.6　类型lambda　　34815.7　自递归类型：f-bounded多态　　35015.8　本章回顾与下一章提要　　351第16章　高级函数式编程　　35216.1　代数数据类型　　35216.1.1　加法类型与乘法类型　　35216.1.2　代数数据类型的属性　　35416.1.3　代数数据类型的*后思考　　35516.2　范畴理论　　35516.2.1　关于范畴　　35616.2.2　functor范畴　　35616.2.3　monad范畴　　36016.2.4　monad的重要性　　36216.3　本章回顾与下一章提要　　363第17章　并发工具　　36517.1　scala.sys.process包　　36517.2　future类型　　36717.3　利用actor模型构造稳固且可扩展的并发应用　　37117.4　akka：为scala设计的actor系统　　37217.5　pickling和spores　　38317.6　反应式编程　　38417.7　本章回顾与下一章提要　　385第18章　scala与大数据　　38618.1　大数据简史　　38618.2　用scala改善mapreduce　　38718.3　超越mapreduce　　39218.4　数学范畴　　39318.5　scala数据工具列表　　39418.6　本章回顾与下一章提要　　394第19章　scala动态调用　　39619.1　一个较为激进的示例：ruby on rails框架中的activerecord库　　39619.2　使用动态特征实现scala 中的动态调用　　39719.3　关于dsl的一些思考　　40219.4　本章回顾与下一章提要　　402第20章　scala的领域特定语言　　40320.1　dsl 示例：scala中xml和json dsl　　40420.2　内部dsl　　40620.3　包含解析组合子的外部dsl　　41020.3.1　关于解析组合子　　41020.3.2　计算工资单的外部dsl　　41020.4　内部dsl与外部dsl：*后的思考　　41320.5　本章回顾与下一章提要　　413第21章　scala工具和库　　41421.1　命令行工具　　41421.1.1　命令行工具：scalac　　41421.1.2　scala命令行工具　　41821.1.3　scalap和javap命令行工具　　42121.1.4　scaladoc 命令行工具　　42221.1.5　fsc命令行工具　　42221.2　构建工具　　42221.2.1　sbt：scala标准构建工具　　42321.2.2　其他构建工具　　42521.3　与ide或文本编辑器集成　　42521.4　在scala中应用测试驱动开发　　42621.5　第三方库　　42721.6　本章回顾与下一章提要　　429第22章　与java的互操作　　43022.1　在scala代码中使用java名称　　43022.2　java泛型与scala泛型　　43022.3　javabean的性质　　43222.4　anyval类型与java原生类型　　43322.5　java代码中的scala名称　　43322.6　本章回顾与下一章提要　　434第23章　应用程序设计　　43523.1　回顾之前的内容　　43523.2　注解　　43723.3　trait即模块　　44123.4　设计模式　　44223.4.1　构造型模式　　44323.4.2　结构型模式　　44323.4.3　行为型模式　　44423.5　契约式设计带来更好的设计　　44623.6　帕特农神庙架构　　44823.7　本章回顾与下一章提要　　453第24章　元编程：宏与反射　　45424.1　用于理解类型的工具　　45524.2　运行时反射　　45524.2.1　类型反射　　45524.2.2　classtag、typetag与manifest　　45724.3　scala 的高级运行时反射api　　45824.4　宏　　46124.4.1　宏的示例：强制不变性　　46324.4.2　关于宏的*后思考　　46624.5　本章回顾与下一章提要　　466附录a　参考文献　　468作者简介　　473关于封面　　473
