Oracle编程艺术深入理解数据库体系结构-(第3版)-凯特 PDF下载 朱龙春 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711541957
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711541957
<p>书名:Oracle编程艺术深入理解数据库体系结构-(第3版)-凯特</p><p>作者:朱龙春</p><p>页数:694</p><p>定价:¥149.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2016-04-01</p><p>ISBN:9787115419576</p><p><h2>相关资料</h2></p>[<p>“在数据为王的时代，数据库在软件领域受到了前所未有的关注。这本书是oracle数据库大师的经典之作，对以数据库为核心的软件设计和开发进行了全面深入的解析，经过oracle中国数据库专家们的专业翻译，相信对广大的开发者将有非常大的帮助。”——苏冬林，oracle公司解决方案中心总经理
 
“oracle database
12c是全新的面向云设计的数据库，并针对企业云计算应用做出了多项技术创新，如内存计算、多租户等。thomas kyte作为全球著名的oracle数据库大师，其多本著作让全球oracle技术爱好者广为受益。朱龙春是国内为数不多的oracle技术领域的典范。我相信通过老朱和oracle研发同事的倾心翻译，这本针对12c云架构的经典著作会给国内的广大oracle技术爱好者带来一份技术盛宴。”——李珈，oracle公司数据库技术部总经理</p>]<p><h2>本书特色</h2></p>[<p>
本书是一本关于oracle数据库体系结构的图书，涵盖了所有重要的oracle体系结构特性，包括文件、内存结构和进程，锁和闩，事务、并发和多版本，表和索引，数据类型，分区和并行，以及数据加密等，并利用具体的例子来全面介绍每个特性，不仅讨论了各个特性是什么，还说明了它是如何工作的，如何使用这个特性来开发软件，以及有关的常见陷阱。本书的读者对象是数据库开发人员。
                                        </p>]<p><h2>内容简介</h2></p>[<p>ask tom！数据库技术大佬经典畅销书新版凝聚专家数十年的宝贵经验和真知灼见公认的oracle数据库指南针对oracle 12c阐述云架构之美oracle中国架构师和研发人员倾心翻译不止于技，更传授道，值得你一读再读本书深入分析了oracle数据库体系结构，包括文件、内存结构以及构成oracle数据库和实例的底层进程，利用具体示例讨论了一些重要的数据库主题，同时分析了数据库中的物理结构，如表、索引和数据类型，并介绍采用哪些技术能使用这些物理结构。新版在前两版的基础上，增加了针对oracle database 12c诸多特性的介绍。新增内容重点关注12c的云架构，以及可插拔式数据库的应用。 </p>]<p><h2>作者简介</h2></p>[<p>Thomas Kyte，Oracle数据库大师，长期主持Oracle Magazine “Ask Tom”专栏，热心回答困扰全世界Oracle开发人员和DBA的各种问题。曾任Oracle公司核心技术集团副总裁。从5.1.5c版本开始使用Oracle，自7.0.9版本发布至2015年8月一直任职于Oracle公司，帮助Oracle数据库用户设计和构建系统，或者对系统进行重构和调优。此前他曾是一位系统集成师，主要为美国军方和政府部门的客户构建大规模的异构数据库和应用。Darl Kuhn，Oracle公司DBA，同时也在美国瑞吉斯大学教授Oracle相关课程。他乐于分享知识，著有多本数据库相关书籍，如《深入理解Oracle 12c数据库管理（第2版）》《Oracle Database 12c性能优化攻略》等。</p>]<p><h2>目录</h2></p>
    第1章　开发成功的oracle应用　　11.1　我的方法　　21.2　黑盒方法　　31.3　开发数据库应用的正确（和不正确）方法　　111.3.1　了解oracle体系结构　　111.3.2　理解并发控制　　211.3.3　多版本控制　　251.3.4　数据库独立性　　311.3.5　怎么能让应用运行得更快451.3.6　dba与开发人员的关系　　481.4　小结　　48第2章　体系结构概述　　502.1　定义数据库和实例　　512.2　连接oracle　　592.2.1　专用服务器　　592.2.2　共享服务器　　612.2.3　tcp/ip连接的基本原理　　632.3　可插拔式数据库　　652.3.1　降低资源用量　　662.3.2　降低维护开销　　662.4　可插拔式数据库的不同之处　　672.5　小结　　67第3章　文件　　683.1　参数文件　　693.1.1　什么是参数　　703.1.2　init.ora参数文件　　733.1.3　服务器参数文件　　753.2　跟踪文件　　823.2.1　计划内的、由用户请求所产生的跟踪文件　　833.2.2　针对内部错误生成的跟踪文件　　883.2.3　跟踪文件小结　　923.3　警告文件　　923.4　数据文件　　953.4.1　简要回顾文件系统机制　　963.4.2　oracle数据库中的存储层次体系　　973.4.3　字典管理和本地管理的表空间　　1003.5　临时文件　　1023.6　控制文件　　1043.7　重做日志文件　　1043.7.1　在线重做日志　　1053.7.2　归档重做日志　　1073.8　密码文件　　1083.9　修改跟踪文件　　1113.10　闪回日志　　1123.10.1　闪回数据库　　1123.10.2　快速恢复区　　1133.11　dmp文件（exp/imp 文件）　　1143.12　数据泵文件　　1153.13　平面文件　　1173.14　小结　　118第4章　内存结构　　1194.1　进程全局区和用户全局区　　1204.1.1　手动pga内存管理　　1214.1.2　自动pga内存管理　　1274.1.3　如何选择手动和自动内存管理　　1374.1.4　pga和uga小结　　1384.2　系统全局区　　1384.2.1　固定sga 区　　1434.2.2　重做缓冲区　　1434.2.3　块缓冲区缓存　　1454.2.4　共享池　　1514.2.5　大池　　1534.2.6　java池　　1544.2.7　流池　　1554.2.8　sga内存管理　　1554.3　小结　　160第5章　oracle 进程　　1615.1　服务器进程　　1615.1.1　专用服务器连接　　1625.1.2　共享服务器连接　　1645.1.3　数据库常驻连接池　　1655.1.4　连接与会话　　1655.1.5　专用服务器、共享服务器和数据库常驻连接池　　1705.1.6　专用/共享服务器小结　　1735.2　后台进程　　1745.2.1　特定任务后台进程　　1755.2.2　工具后台进程　　1855.3　从属进程　　1885.3.1　i/o从属进程　　1885.3.2　pnnn：并行查询执行服务器　　1895.4　小结　　189第6章　锁和闩　　1906.1　什么是锁　　1906.2　锁的问题　　1936.2.1　丢失更新　　1936.2.2　悲观锁　　1946.2.3　乐观锁　　1956.2.4　乐观锁还是悲观锁　　2016.2.5　阻塞　　2026.2.6　死锁　　2056.2.7　锁升级　　2096.3　锁类型　　2096.3.1　dml锁　　2106.3.2　ddl锁　　2196.3.3　闩　　2236.3.4　互斥锁　　2316.3.5　手动锁定和用户定义锁　　2326.4　小结　　233第7章　并发与多版本控制　　2347.1　什么是并发控制　　2347.2　事务隔离级别　　2357.2.1　read uncommitted　　2367.2.2　read committed　　2387.2.3　repeatable read　　2397.2.4　serializable　　2417.2.5　read only　　2437.3　多版本读一致性的含义　　2447.3.1　数据仓库中一种常见但有问题的方法　　2447.3.2　解释热表上超出期望的i/o　　2457.4　写一致性　　2477.4.1　一致读和当前读　　2487.4.2　查看重启动　　2507.4.3　为什么重启动对我们很重要　　2527.5　小结　　253第8章　事务　　2558.1　事务控制语句　　2558.2　原子性　　2578.2.1　语句级原子性　　2578.2.2　过程级原子性　　2598.2.3　事务级原子性　　2628.2.4　ddl与原子性　　2628.3　持久性　　2638.3.1　commit的write扩展　　2638.3.2　非分布式pl/sql代码块中的commit　　2648.4　完整性约束和事务　　2668.4.1　immediate约束　　2668.4.2　deferrable约束和级联更新　　2668.5　不好的事务习惯　　2708.5.1　在循环中提交　　2708.5.2　使用自动提交　　2768.6　分布式事务　　2778.7　自治事务　　2788.7.1　自治事务如何工作　　2798.7.2　何时使用自治事务　　2808.8　小结　　283第9章　redo与undo　　2849.1　什么是redo　　2859.2　什么是undo　　2869.3　redo和undo如何协作　　2899.4　提交和回滚处理　　2939.4.1　commit做什么　　2939.4.2　rollback做什么　　2999.5　分析redo　　3009.5.1　测量redo　　3019.5.2　能关掉重做日志的生成吗　　3029.5.3　为什么我拿不到日志空间　　3059.5.4　块清除　　3079.5.5　日志竞争　　3109.5.6　临时表和redo/undo　　3129.6　分析undo　　3179.6.1　什么操作会生成*多和*少的undo　　3179.6.2　ora-01555: snapshot too old错误　　3199.7　小结　　328第10章　数据库表　　32910.1　表类型　　32910.2　术语　　33110.2.1　段　　33110.2.2　段空间管理　　33310.2.3　高水位线　　33410.2.4　freelist　　33610.2.5　pctfree和pctused　　33910.2.6　logging和nologging　　34210.2.7　initrans和maxtrans　　34310.3　堆组织表　　34310.4　索引组织表　　34610.5　索引聚簇表　　35910.6　散列聚簇表　　36610.7　有序散列聚簇表　　37510.8　嵌套表　　37710.8.1　嵌套表语法　　37810.8.2　嵌套表存储　　38410.8.3　嵌套表小结　　38710.9　临时表　　38710.9.1　12c之前的统计信息　　39110.9.2　12c之后的统计信息　　39510.9.3　临时表小结　　39810.10　对象表　　39910.11　小结　　405第11章　索引　　40611.1　oracle索引概述　　40611.2　b*tree索引　　40811.2.1　索引键压缩　　41111.2.2　反向键索引　　41311.2.3　降序索引　　41811.2.4　什么情况下应该使用b*tree索引　　42011.2.5　b*tree小结　　43011.3　位图索引　　43011.3.1　什么情况下应该使用位图索引　　43111.3.2　位图联结索引　　43511.3.3　位图索引小结　　43711.4　基于函数的索引　　43811.4.1　一个简单的例子　　43811.4.2　只对部分行建立索引　　44611.4.3　实现有选择的唯一性　　44811.4.4　关于ora-01743的警告　　44811.4.5　基于函数的索引小结　　44911.5　应用域索引　　45011.6　不可见的索引　　45111.7　同列上的多个索引　　45211.8　在扩展列上使用索引　　45311.8.1　使用虚拟列的方法　　45411.8.2　使用基于函数索引的方法　　45611.9　关于索引的常见问题和各种传言　　45711.9.1　视图能使用索引吗　　45711.9.2　null和索引能协作吗　　45711.9.3　外键是否应该加索引　　46011.9.4　为什么没有使用我的索引　　46111.9.5　传言：索引中从不重用空间　　46611.9.6　传言：*有差别的元素应该在*前面　　46911.10　小结　　472第12章　数据类型　　47312.1　oracle数据类型概述　　47312.2　字符和二进制串类型　　47512.2.1　nls概述　　47612.2.2　字符串　　47912.3　二进制串：raw类型　　48512.4　扩展的数据类型　　48712.5　数值类型　　48912.5.1　number类型的语法和用法　　49112.5.2　binary_float/binary_double类型的语法和用法　　49412.5.3　非固有数值类型　　49512.5.4　性能考虑　　49512.6　long类型　　49712.6.1　long 和long raw类型的限制　　49712.6.2　处理遗留的long类型　　49812.7　date、timestamp和interval类型　　50212.7.1　格式　　50312.7.2　date类型　　50412.7.3　timestamp类型　　50912.7.4　interval类型　　51512.8　lob类型　　51812.8.1　内部lob　　51812.8.2　bfile　　53112.9　rowid/urowid类型　　53312.10　小结　　533第13章　分区　　53513.1　分区概述　　53513.1.1　提高可用性　　53613.1.2　减少管理负担　　53813.1.3　增强语句性能　　54113.2　表分区机制　　54313.2.1　区间分区　　54413.2.2　散列分区　　54613.2.3　列表分区　　55013.2.4　间隔分区　　55213.2.5　引用分区　　55713.2.6　间隔引用分区　　56113.2.7　虚拟列分区　　56313.2.8　组合分区　　56413.2.9　行移动　　56613.2.10　表分区机制小结　　56813.3　索引分区　　56913.3.1　本地索引与全局索引　　57013.3.2　本地索引　　57013.3.3　全局索引　　57513.4　再论分区和性能　　59013.5　一些简化维护的特性　　59513.5.1　多分区管理操作　　59513.5.2　级联截断　　59713.5.3　级联交换　　59913.6　审计和段空间压缩　　60013.7　小结　　601第14章　并行执行　　60314.1　何时使用并行执行　　60414.2　oracle exadata　　60614.3　并行查询　　60614.4　并行dml　　61214.5　并行ddl　　61514.5.1　并行ddl和使用外部表的数据加载　　61614.5.2　并行ddl和扩展截断　　61714.6　过程并行化　　62514.6.1　并行管道函数　　62614.6.2　diy并行化　　62914.6.3　老式diy并行化　　63214.7　小结　　635第15章　数据加载和卸载　　63715.1　外部表　　63715.1.1　建立外部表　　63815.1.2　处理错误　　64515.1.3　使用外部表加载不同的文件　　64815.1.4　多用户问题　　64915.1.5　预处理　　65015.1.6　外部表总结　　65815.2　数据泵卸载　　65915.3　sqlldr　　66015.3.1　用sqlldr加载数据的常见问题　　66415.3.2　sqlldr警告　　68615.3.3　sqlldr小结　　68615.4　平面文件卸载　　68715.5　小结　　694
