Erlang程序设计-(第2版) PDF下载 阿姆斯特朗 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711535457
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711535457
<p>书名:Erlang程序设计-(第2版)</p><p>作者:阿姆斯特朗</p><p>页数:428</p><p>定价:¥89.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2014-06-01</p><p>ISBN:9787115354570</p><p><h2>本书特色</h2></p>[<p>
《erlang程序设计(第2版)》由erlang之父joe armstrong编写，是毋庸置疑的经典著作。书中兼顾了顺序编程、并发编程和分布式编程，深入讨论了开发erlang应用中至关重要的文件和网络编程、otp、ets和dets等主题。新版针对入门级程序员增加了相关内容。
　　《erlang程序设计(第2版)》适合erlang初学者和中级水平erlang程序员学习参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>在多核、并发、分布为王的时代，谁将成为下一个主流编程语言？来自全世界的众多专家都认为，erlang*有可能在竞争中胜出。
　　erlang开源语言系出名门，通信巨头爱立信公司用它开发出了可靠性惊人的交换机系统axd301。它天生就是面向并发、分布和高容错的，兼有函数式语言和脚本语言的各种优点，而且已经用于商业开发多年，具有稳定性极高的虚拟机和平台库。有了这些天时地利，无怪乎erlang能够迅速成为热门的开发语言，除了广泛应用于通信行业之外，它已经进入了各个领域：facebook用它实现了聊天系统，yahoo用它重写了delicious，amazon用它开发了云计算数据服务simpledb，还有多人游戏、测试工具、电子支付、数据采集与监控、企业消息、电子邮件、空中交通管制……
　　本书由erlang之父joe armstrong编写，是毋庸置疑的经典著作。书中兼顾了顺序编程、并发编程和分布式编程，重点介绍如何编写并发和分布式的erlang程序以及如何在多核cpu上自动加速程序，并深入地讨论了开发erlang应用中至关重要的文件和网络编程、otp、ets和dets等主题。第2版全新改写，反应了自第1版面世以来erlang历经的所有变化，添加了大量针对初学者的内容，并在每章后都附上了练习题。</p>]<p><h2>作者简介</h2></p>[<p>Joe Armstrong
　　Erlang最初的设计者和实现者，也是Erlang OTP系统项目的首席架构师。他拥有瑞典皇家理工学院博士学位，是容错系统开发领域的世界级专家。现就职于爱立信公司。</p>]<p><h2>目录</h2></p>
    **部分　为何用erlang第1章　什么是并发　1.1　给并发建模　1.1.1　开始模拟　1.1.2　发送消息　1.1.3　接收消息　1.2　并发的益处　1.3　并发程序和并行计算机　1.4　顺序和并发编程语言　1.5　小结　第2章　erlang速览　2.1　shell　2.1.1　=操作符　2.1.2　变量和原子的语法　2.2　进程、模块和编译　2.2.1　在shell里编译并运行hello world　2.2.2　在erlang shell外编译　2.3　你好，并发　2.3.1　文件服务器进程　2.3.2　客户端代码　2.3.3　改进文件服务器　2.4　练习　第二部分　顺序编程第3章　基本概念　3.1　启动和停止erlang shell　3.1.1　在shell里执行命令　3.1.2　可能出错的地方　3.1.3　在erlang shell里编辑命令　3.2　简单的整数运算　3.3　变量　3.3.1　erlang的变量不会变　3.3.2　变量绑定和模式匹配　3.3.3　为什么一次性赋值让程序变得更好　3.4　浮点数　3.5　原子　3.6　元组　3.6.1　创建元组　3.6.2　提取元组的值　3.7　列表　3.7.1　专用术语　3.7.2　定义列表　3.7.3　提取列表元素　3.8　字符串　3.9　模式匹配再探　3.10　练习　第4章　模块与函数　4.1　模块是存放代码的地方　4.1.1　常见错误　4.1.2　目录和代码路径　4.1.3　给代码添加测试　4.1.4　扩展程序　4.1.5　分号放哪里　4.2　继续购物　4.3　fun：基本的抽象单元　4.3.1　以fun作为参数的函数　4.3.2　返回fun的函数　4.3.3　定义你自己的控制抽象　4.4　简单列表处理　4.5　列表推导　4.5.1　quicksort　4.5.2　毕达哥拉斯三元数组　4.5.3　回文构词　4.6　内置函数　4.7　关卡　4.7.1　关卡序列　4.7.2　关卡示例　4.7.3　true关卡的作用　4.8　case和if表达式　4.8.1　case表达式　4.8.2　if表达式　4.9　构建自然顺序的列表　4.10　归集器　4.11　练习　第5章　记录与映射组　5.1　何时使用映射组或记录　5.2　通过记录命名元组里的项　5.2.1　创建和更新记录　5.2.2　提取记录字段　5.2.3　在函数里模式匹配记录　5.2.4　记录是元组的另一种形式　5.3　映射组：关联式键-值存储　5.3.1　映射组语法　5.3.2　模式匹配映射组字段　5.3.3　操作映射组的内置函数　5.3.4　映射组排序　5.3.5　以json为桥梁　5.4　练习　第6章　顺序程序的错误处理　6.1　处理顺序代码里的错误　6.2　用try...catch捕捉异常错误　6.2.1　try...catch具有一个值　6.2.2　简写法　6.2.3　try...catch编程样例　6.3　用catch捕捉异常错误　6.4　针对异常错误的编程样式　6.4.1　改进错误消息　6.4.2　经常返回错误时的代码　6.4.3　错误可能有但罕见时的代码　6.4.4　捕捉一切可能的异常错误　6.5　栈跟踪　6.6　抛错要快而明显，也要文明　6.7　练习　第7章　二进制型与位语法　7.1　二进制型　7.2　位语法　7.2.1　打包和解包16位颜色　7.2.2　位语法表达式　7.2.3　位语法的真实例子　7.3　位串：处理位级数据　7.4　练习　第8章　erlang顺序编程补遗　8.1　apply　8.2　算术表达式　8.3　元数　8.4　属性　8.4.1　预定义的模块属性　8.4.2　用户定义的模块属性　8.5　块表达式　8.6　布尔值　8.7　布尔表达式　8.8　字符集　8.9　注释　8.10　动态代码载入　8.11　erlang的预处理器　8.12　转义序列　8.13　表达式和表达式序列　8.14　函数引用　8.15　包含文件　8.16　列表操作：++和--　8.17　宏　8.18　模式的匹配操作符　8.19　数字　8.19.1　整数　8.19.2　浮点数　8.20　操作符优先级　8.21　进程字典　8.22　引用　8.23　短路布尔表达式　8.24　比较数据类型　8.25　元组模块　8.26　下划线变量　8.27　练习　第9章　类型　9.1　指定数据和函数类型　9.2　erlang的类型表示法　9.2.1　类型的语法　9.2.2　预定义类型　9.2.3　指定函数的输入输出类型　9.2.4　导出类型和本地类型　9.2.5　不透明类型　9.3　dialyzer教程　9.3.1　错误使用内置函数的返回值　9.3.2　内置函数的错误参数　9.3.3　错误的程序逻辑　9.3.4　使用dialyzer　9.3.5　干扰dialyzer的事物　9.4　类型推断与成功分型　9.5　类型系统的局限性　9.6　练习　第10章　编译和运行程序　10.1　改变开发环境　10.1.1　设置载入代码的搜索路径　10.1.2　在系统启动时执行一组命令　10.2　运行程序的不同方式　10.2.1　在erlang shell里编译和运行　10.2.2　在命令提示符界面里编译和运行　10.2.3　作为escript运行　10.2.4　带命令行参数的程序　10.3　用makefile使编译自动化　10.4　当坏事发生　10.4.1　停止erlang　10.4.2　未定义(缺失)的代码　10.4.3　shell没有反应　10.4.4　我的makefile不工作　10.4.5　erlang崩溃而你想阅读故障转储文件　10.5　获取帮助　10.6　调节运行环境　10.7　练习　第三部分　并发和分布式程序第11章　现实世界中的并发　第12章　并发编程　12.1　基本并发函数　12.2　客户端-服务器介绍　12.3　进程很轻巧　12.4　带超时的接收　12.4.1　只带超时的接收　12.4.2　超时值为0的接收　12.4.3　超时值为无穷大的接收　12.4.4　实现一个定时器　12.5　选择性接收　12.6　注册进程　12.7　关于尾递归的说明　12.8　用mfa或fun进行分裂　12.9　练习　第13章　并发程序中的错误　13.1　错误处理的理念　13.1.1　让其他进程修复错误　13.1.2　任其崩溃　13.1.3　为何要崩溃　13.2　错误处理的术语含义　13.3　创建连接　13.4　同步终止的进程组　13.5　设立防火墙　13.6　监视　13.7　基本错误处理函数　13.8　容错式编程　13.8.1　在进程终止时执行操作　13.8.2　让一组进程共同终止　13.8.3　生成一个永不终止的进程　13.9　练习　第14章　分布式编程　14.1　两种分布式模型　14.2　编写一个分布式程序　14.3　创建名称服务器　14.3.1　第1阶段：一个简单的名称服务器　14.3.2　第2阶段：客户端在一个节点，服务器在相同主机的另一个节点　14.3.3　第3阶段：同一局域网内不同机器上的客户端和服务器　14.3.4　第4阶段：跨互联网不同主机上的客户端和服务器　14.4　分布式编程的库和内置函数　14.4.1　远程分裂示例　14.4.2　文件服务器再探　14.5　cookie保护系统　14.6　基于套接字的分布式模型　14.6.1　用lib_chan控制进程　14.6.2　服务器代码　14.7　练习　第四部分　编程库与框架第15章　接口技术　15.1　erlang如何与外部程序通信　15.2　用端口建立外部c程序接口　15.2.1　c程序　15.2.2　erlang程序　15.2.3　编译和链接端口程序　15.2.4　运行程序　15.3　在erlang里调用shell脚本　15.4　高级接口技术　15.5　练习　第16章　文件编程　16.1　操作文件的模块　16.2　读取文件的几种方法　16.2.1　读取文件里的所有数据类型　16.2.2　分次读取文件里的数据类型　16.2.3　分次读取文件里的行　16.2.4　读取整个文件到二进制型中　16.2.5　通过随机访问读取文件　16.3　写入文件的各种方式　16.3.1　把数据列表写入文件　16.3.2　把各行写入文件　16.3.3　一次性写入整个文件　16.3.4　写入随机访问文件　16.4　目录和文件操作　16.4.1　查找文件信息　16.4.2　复制和删除文件　16.5　其他信息　16.6　一个查找工具函数　16.7　练习　第17章　套接字编程　17.1　使用tcp　17.1.1　从服务器获取数据　17.1.2　一个简单的tcp服务器　17.1.3　顺序和并行服务器　17.1.4　注意事项　17.2　主动和被动套接字　17.2.1　主动消息接收(非阻塞式)　17.2.2　被动消息接收(阻塞式)　17.2.3　混合消息接收(部分阻塞式)　17.3　套接字错误处理　17.4　udp　17.4.1　*简单的udp服务器与客户端　17.4.2　一个udp阶乘服务器　17.4.3　udp数据包须知　17.5　对多台机器广播　17.6　一个shoutcast服务器　17.6.1　shoutcast协议　17.6.2　shoutcast服务器的工作原理　17.6.3　shoutcast服务器的伪代码　17.6.4　运行shoutcast服务器　17.7　练习　第18章　用websocket和erlang进行浏览　18.1　创建一个数字时钟　18.2　基本交互　18.3　浏览器里的erlang shell　18.4　创建一个聊天小部件　18.5　简化版irc　18.6　浏览器里的图形　18.7　浏览器-服务器协议　18.7.1　从erlang发送消息到浏览器　18.7.2　从浏览器到erlang的消息　18.8　练习　第19章　用ets和dets存储数据　19.1　表的类型　19.2　影响ets表效率的因素　19.3　创建一个ets表　19.4　ets示例程序　19.4.1　三字母组合迭代函数　19.4.2　创建一些表　19.4.3　创建表所需的时间　19.4.4　访问表所需的时间　19.4.5　获胜者是……　19.5　保存元组到磁盘　19.6　其余操作　19.7　练习　第20章　mnesia：erlang数据库　20.1　创建初始数据库　20.2　数据库查询　20.2.1　选择表里的所有数据　20.2.2　从表里选择数据　20.2.3　从表里有条件选择数据　20.2.4　从两个表里选择数据(联接)　20.3　添加和移除数据库里的数据　20.3.1　添加行　20.3.2　移除行　20.4　mnesia事务　20.4.1　中止事务　20.4.2　载入测试数据　20.4.3　do()函数　20.5　在表里保存复杂数据　20.6　表的类型和位置　20.6.1　创建表　20.6.2　常用的表属性组合　20.6.3　表的行为　20.7　表查看器　20.8　深入挖掘　20.9　练习　第21章　性能分析、调试与跟踪　21.1　erlang代码的性能分析工具　21.2　测试代码覆盖　21.3　生成交叉引用　21.4　编译器诊断信息　21.4.1　头部不匹配　21.4.2　未绑定变量　21.4.3　未结束字符串　21.4.4　不安全变量　21.4.5　影子变量　21.5　运行时诊断　21.6　调试方法　21.6.1　io:format调试　21.6.2　转储至文件　21.6.3　使用错误记录器　21.7　erlang调试器　21.8　跟踪消息与进程执行　21.9　erlang代码的测试框架　21.10　练习　第22章　otp介绍　22.1　通用服务器之路　22.1.1　server 1：基本的服务器　22.1.2　server 2：实现事务的服务器　22.1.3　server 3：实现热代码交换的服务器　22.1.4　server 4：事务与热代码交换　22.1.5　server 5：更多乐趣　22.2　gen_server入门　22.2.1　确定回调模块名　22.2.2　编写接口方法　22.2.3　编写回调方法　22.3　gen_server的回调结构　22.3.1　启动服务器　22.3.2　调用服务器　22.3.3　调用和播发　22.3.4　发给服务器的自发性消息　22.3.5　后会有期，宝贝　22.3.6　代码更改　22.4　填写gen_server模板　22.5　深入探索　22.6　练习　第23章　用otp构建系统　23.1　通用事件处理　23.2　错误记录器　23.2.1　记录错误　23.2.2　配置错误记录器　23.2.3　分析错误　23.3　警报管理　23.4　应用程序服务器　23.4.1　质数服务器　23.4.2　面积服务器　23.5　监控树　23.6　启动系统　23.7　应用程序　23.8　文件系统组织方式　23.9　应用程序监视器　23.10　怎样计算质数　23.11　深入探索　23.12　练习　第五部分　构建应用程序第24章　编程术语　24.1　保持erlang世界观　24.2　多用途服务器　24.3　有状态的模块　24.4　适配器变量　24.5　表意编程　24.6　练习　第25章　第三方程序　25.1　制作可共享代码存档并用rebar管理代码　25.1.1　安装rebar　25.1.2　在github上创建一个新项目　25.1.3　在本地克隆这个项目　25.1.4　制作一个otp应用程序　25.1.5　宣传你的项目　25.2　整合外部程序与我们的代码　25.3　生成依赖项本地副本　25.4　用cowboy构建嵌入式web服务器　25.5　练习　第26章　多核cpu编程　26.1　给erlang程序员的好消息　26.2　如何在多核cpu中使程序高效运行　26.2.1　使用大量进程　26.2.2　避免副作用　26.2.3　避免顺序瓶颈　26.3　让顺序代码并行　26.4　小消息，大计算　26.5　用mapreduce使计算并行化　26.6　练习　第27章　福尔摩斯的*后一案　27.1　找出数据的相似度　27.2　sherlock演示　27.2.1　获取并预处理数据　27.2.2　寻找*像给定文件的邮件　27.2.3　搜索指定作者、日期或标题的邮件　27.3　数据分区的重要性　27.4　给邮件添加关键词　27.4.1　词汇的重要性：tf*idf权重　27.4.2　余弦相似度：两个权重向量的相似程度　27.4.3　相似度查询　27.5　实现方式概览　27.6　练习　27.7　总结　附录a　otp模板　附录b　一个套接字应用程序　附录c　一种简单的执行环境
