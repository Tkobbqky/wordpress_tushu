Linux操作系统-基础.原理与应用-(第2版) PDF下载 张玲 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730249407
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730249407
<p>书名:Linux操作系统-基础.原理与应用-(第2版)</p><p>作者:张玲</p><p>页数:384</p><p>定价:¥49.0</p><p>出版社:清华大学出版社</p><p>出版日期:2019-08-01</p><p>ISBN:9787302494072</p><p><h2>节选</h2></p>[<p>第5章 
进 程 管 理 在多道程序系统中，同时存在多个程序在运行。它们共享系统的资源，轮流使用CPU，彼此之间相互制约和依赖，表现出复杂的行为特性。进程是为了刻画并发程序的执行过程而引入的概念，进程管理就是对并发程序的运行过程的管理，也就是对CPU的管理。 进程管理的功能是跟踪和控制所有进程的活动，为它们分配和调度CPU，协调进程的运行步调。进程管理的目标是*大限度地发挥CPU的处理能力，提高进程的运行效率。 
5.1  进程 进程是现代操作系统的核心概念，它用来描述程序的执行过程，是实现多任务操作系统的基础。操作系统的其他所有内容都是围绕着进程展开的。因此，正确地理解和认识进程是理解操作系统原理的基础和关键。 
5.1.1  程序的顺序执行与并发执行 
1. 程序的顺序执行 如果程序的各操作步骤之间是依序执行的，程序与程序之间是串行执行的，这种执行程序的方式就称为顺序执行。顺序执行是单道程序系统中的程序的运行方式。 程序的顺序执行具有如下特点： （1）顺序性。CPU严格按照程序规定的顺序执行，仅当一个操作结束后，下一个操作才能开始执行。多个程序要运行时，仅当一个程序全部执行结束后另一个程序才能   开始。 （2）封闭性。程序在封闭的环境中运行，即程序运行时独占全部系统资源，只有程序本身才能改变程序的运行环境。因而程序的执行过程不受外界因素的影响，结果只取决于程序自身。 （3）可再现性。程序执行的结果与运行的时间和速度无关，结果总是可再现的，即无论何时重复执行该程序都会得到同样的结果。 总的说来，这种执行程序的方式简单，且便于调试。但由于顺序程序在运行时独占全部系统资源，因而系统资源利用率很低。DOS程序就是采用顺序方式执行的。 
2. 程序的并发执行 单道程序、封闭式运行是早期操作系统的标志，而多道程序并发运行是现代操作系统的基本特征。由于同时有多个程序在系统中运行，使系统资源得到充分的利用，系统效率大大提高。 程序的并发执行是指若干程序或程序段同时运行。它们的执行在时间上是重叠的。程序的并发执行有以下特点： （1）间断性。并发程序之间因竞争资源而相互制约，导致程序运行过程的间断。例如，在单CPU的系统中，多个程序需要轮流占用CPU运行，未获得CPU的程序就必须等待。 （2）没有封闭性。当多个程序共享系统资源时，一个程序的运行受其他程序的影响，其运行过程和结果不完全由自身决定。例如，一个程序计划在某一时刻执行一个操作，但很可能在那个时刻到来时它没有获得CPU，因而也就无法完成该操作。 （3）不可再现性。由于没有了封闭性，并发程序的执行结果与执行的时机以及执行的速度有关，结果往往不可再现。 可以看出，并发执行程序虽然可以提高系统的资源利用率和吞吐量，但程序的行为变得复杂和不确定。这使程序难以调试，若处理不当还会带来许多潜在问题。 
3. 并发执行的潜在问题 程序在并发执行时会导致执行结果的不可再现性，这是多道程序系统必须解决的问题。我们用下面的例子来说明并发执行过程对运行结果的影响，从而了解产生问题的     原因。 设某停车场使用程序控制电子公告牌来显示空闲车位数。空闲车位数用一个计数器C记录。车辆入库时执行程序A，车辆出库时执行程序B，它们都要更新同一个计数器C。程序A和程序B的片段如图5-1所示。 图5-1  两个程序并发运行，访问计数器C 更新计数器C的操作对应的机器语言有3个步骤：读取内存C单元的数据到一个寄存器中，修改寄存器的数值，然后再将其写回C单元中。 由于车辆出入库的时间是随机的，程序A与程序B的运行时间也就是不确定的。当出入库同时发生时，将使两个程序在系统中并发运行。它们各运行一次后C计数器的值应保持不变。但结果可能不是如此。 如果两个程序的运行时序如图5-2（a）所示，即一个程序对C进行更新的操作是在另一个程序的更新操作全部完成之后才开始，则C被正确地更新了。如果两个程序的运行时序如图5-2（b）所示穿插地进行，即当一个程序正在更新C，更新操作还未完成时，CPU发生了切换，另一个程序被调度运行，并且也对C进行更新。在这种情况下会导致错误的结果。 图5-2  并发程序的执行时序影响执行结果 可以看出，导致C更新错误的原因是两个程序交叉地执行了更新C的操作。概括地说，当多个程序在访问共享资源时的操作是交叉执行时，则会发生对资源使用上的错误。 
5.1.2  进程的概念 进程的概念*早出现在20世纪60年代中期，此时操作系统进入多道程序设计时代。多道程序并发显著地提高了系统的效率，但同时也使程序的执行过程变得复杂与不确定。为了更好地研究、描述和控制并发程序的执行过程，操作系统引入了进程的概念。进程概念对于理解操作系统的并发性有着极为重要的意义。 
1. 进程 进程（process）是一个可并发执行的程序在一个数据集上的一次运行。简单地说，进程就是程序的一次运行过程。 进程与程序的概念既相互关联又相互区别。程序是进程的一个组成部分，是进程的执行文本，而进程是程序的执行过程。两者的关系可以比喻为电影与胶片的关系：胶片是静态的，是电影的放映素材。而电影是动态的，一场电影就是胶片在放映机上的一次“运行”。对进程而言，程序是静态的指令集合，可以永久存在；而进程是动态的过程实体，动态地产生、发展和消失。 此外，进程与程序之间也不是一一对应的关系，表现在以下两点： （1）一个进程可以顺序执行多个程序，如同一场电影可以连续播放多部胶片一样。 （2）一个程序可以对应多个进程，就像一本胶片可以放映多场电影一样。程序的每次运行就对应了一个不同的进程。更重要的是，一个程序还可以同时对应多个进程。例如系统中只有一个vi程序，但它可以被多个用户同时执行，编辑各自的文件。每个用户的编辑过程都是一个不同的进程。 
2. 进程的特性 进程与程序的不同主要体现在进程有一些程序所没有的特性。要真正理解进程，首先应了解它的基本性质。进程具有以下几个基本特性： （1）动态性。进程由“创建”而产生，由“撤销”而消亡，因“调度”而运行，因“等待”而停顿。进程从创建到消失的全过程称为进程的生命周期。 （2）并发性。在同一时间段内有多个进程在系统中活动。它们宏观上是在并发运行，而微观上是在交替运行。 （3）独立性。进程是可以独立运行的基本单位，是操作系统分配资源和调度管理的基本对象。因此，每个进程都独立地拥有各种必要的资源，独立地占有CPU运行。 （4）异步性。每个进程都独立地执行，各自按照不可预知的速度向前推进。进程之间的协调运行由操作系统负责。 
3. 进程的基本状态 在多道系统中，进程的个数总是多于CPU的个数，因此它们需要轮流地占用CPU。从宏观上看，所有进程同时都在向前推进；而在微观上，这些进程是在走走停停之间完成整个运行过程的。为了刻画一个进程在各个时期的动态行为特征，通常采用状态模型。 进程有3个基本的状态： （1）就绪态。进程已经分配到了除CPU之外的所有资源，这时的进程状态称为就绪状态。处于就绪态的进程，一旦获得CPU便可立即执行。系统中通常会有多个进程处于就绪态，它们排成一个就绪队列。 （2）运行态。进程已经获得CPU，正在运行，这时的进程状态称为运行态。在单CPU系统中，任何时刻只能有一个进程处于运行态。 （3）等待态。进程因某种资源不能满足，或希望的某事件尚未发生而暂停执行时，则称它处于等待态。系统中常常会有多个进程处于等待态，它们按等待的事件分类，排成多个等待队列。 
4. 进程状态的转换 进程诞生之初处于就绪态，在其后的生存期间内不断地从一个状态转换到另一个状态，*后在运行态结束。图5-3所示是一个进程的状态转换图。 图5-3  进程的状态转换图 引起状态转换的原因如下： 
* 运行态→等待态：正在执行的进程因为等待某事件而无法执行下去。例如，进程申请某种资源，而该资源恰好被其他进程占用，则该进程将交出CPU，进入等待状态。 
* 等待态→就绪态：处于等待状态的进程，当其所申请的资源得到满足时，则系统将资源分配给它，并将其状态变为就绪态。 
* 运行态→就绪态：正在执行的进程的时间片用完了，或者有更高优先级的进程到来，系统会暂停该进程的运行，使其进入就绪态，然后调度其他进程运行。 
* 就绪态→运行态：处于就绪态的进程，当被进程调度程序选中后，即进入CPU运行。此时该进程的状态变为运行态。 
5.1.3  进程控制块 进程由程序、数据和进程控制块3个基本部分组成。程序是进程执行的可执行代码，数据是进程所处理的对象，进程控制块用于记录有关进程的各种信息。它们存在于内存，其内容会随着执行过程的进展而不断变化。在某个时刻的进程的执行内容（指代码、数据和堆栈）被称为进程映像（process image）。进程映像可以看作是进程的剧本，决定了进程推进的路线和行为。进程控制块则是进程的档案。系统中每个进程都是唯一的。即使两个进程执行的是同一映像，它们也都有各自的进程控制块，因此是不同的进程。 进程控制块（Process Control Block，PCB）是为管理进程而设置的一个数据结构，用于记录进程的相关信息。当创建一个进程时，系统为它生成PCB；进程完成后，撤销它的PCB。因此，PCB是进程的代表，PCB存在则进程就存在，PCB消失则进程也就结束了。在进程的生存期中，系统通过PCB来感知进程，了解它的活动情况，通过它对进程实施控制和调度。因此，PCB是操作系统中*重要的数据结构之一。 PCB记录了有关进程的所有信息，主要包括以下4方面的内容。 （1）进程描述信息。 进程描述信息用于记录一个进程的标识信息和身份特征，如家族关系和归属关系等。通过这些信息可以识别该进程，了解进程的权限，以及确定这个进程与其他进程之间的关系。 系统为每个进程分配了一个唯一的整数作为进程标识号PID，这是*重要的标识信息。系统通过PID来标识各个进程。 （2）进程控制与调度信息。 进程的运行需要由系统进行控制和调度。进程控制块记录了进程的当前状态、调度策略、优先级、时间片等信息。系统依据这些信息实施进程的控制与调度。 （3）资源信息。 进程的运行需要占用一些系统资源，必要的资源包括进程的地址空间、要访问的文件和设备以及要处理的信号等。进程是系统分配资源的基本单位。系统将分配给进程的资源信息记录在进程的PCB中。通过这些信息，进程就可以访问分配到的各种资源。 （4）现场信息。 进程现场也称为进程上下文（process context），包括CPU的各个寄存器的值。这些值刻画了进程的运行状态和环境。退出CPU的进程必须保存好这些现场信息，以便在下次被调度时继续运行。当进程被重新调度运行时，系统用它的PCB中的现场信息恢复CPU现场。现场一旦恢复，进程就可以从上次运行的断点处继续执行下去了。 5.1.4  Linux系统中的进程 在Linux系统中，进程也称为任务（task），两者的概念是一致的。 
1．Linux进程的状态 Linux系统的进程有5种基本状态，即可执行态（运行态与就绪态）、可中断睡眠态、不可中断睡眠态、暂停态和僵死态。状态转换图如图5-4所示。 图5-4  Linux系统的进程状态转换图 Linux进程的基本状态定义如下： （1）可执行态（runnable）：可执行态包含上述状态图中的运行和就绪两种状态。处于可执行态的进程均已具备运行条件。它们或正在运行，或准备运行。 （2）睡眠态（sleeping）：即等待态。此时进程正在等待某个事件或某个资源。睡眠态又细分为可中断的（interruptable）和不可中断的（uninterruptable）两种。它们的区别在于，在睡眠过程中，处于不可中断状态的进程会忽略信号，而处于可中断状态的进程如果收到信号会被唤醒而进入可执行态，待处理完信号后再次进入睡眠态。 （3）暂停态（stopped或traced）：处于暂停态的进程是由运行态转换而来的，等待某种特殊处理。当进程收到一个暂停信号时则进入暂停态，等待恢复运行的信号。 （4）僵死态（zombie）：进程运行结束或因某些原因被终止时，它将释放除PCB外的所有资源。这种占有PCB但已经无法运行的进程就处于僵死态。 
2．Linux进程的状态转换过程 Linux进程的状态转换过程如下。 新创建的进程处于可执行的就绪态，等待调度执行。 处于可执行态的进程在就绪态和运行态之间轮回。就绪态的进程一旦被调度程序选中，就进入运行状态。当进程的时间片耗尽或有更高优先级的进程就绪时，调度程序将选择新的进程来抢占CPU运行。被抢占的进程将交出CPU，转入就绪态等待下一次的调度。处于此轮回的进程在运行态与就绪态之间不断地高速切换，可谓瞬息万变。因此，对观察者（系统与用户）来说，将此轮回概括为一个相对稳定的可执行态才有意义。 运行态、睡眠态和就绪态形成一个回路。处于运行态的进程，有时需要等待某种资源或某个事件的发生，这时已无法占有CPU继续运行，于是它退出CPU，转入睡眠态。当该进程等待的事件发生后，进程被唤醒，进入就绪态。 运行态、暂停态和就绪态也构成一个回路。当处于运行态的进程接收到暂停执行信号时，它就放弃CPU，进入暂停态。当暂停的进程获得恢复执行信号时，就转入就绪态。 处于运行态的进程执行结束后进入僵死态。待父进程（即创建此进程的进程）对其进行相应处理后撤销它的PCB。此时，这个进程就完成了它的使命，从僵死走向彻底    消失。 
3．Linux的进程描述符 Linux系统用task_struct结构来记录进程的信息，称为进程描述符，也就是通常所说的PCB。系统中每创建一个新的进程，就给它建立一个task_struct结构，并填入进程的控制信息。task_struct中的字段很多，主要包括以下内容： 
* 进程标识号（pid）：标识该进程的一个整数。 
* 归属关系（uid、gid）：进程的属主和属组的标识号。 
* 家族关系（parent、children、sibling）：关联父进程、子进程及兄弟进程的链接     指针。 
* 链接指针（tasks、run_list）：将进程链入进程链表和可执行队列的指针。 
* 状态（state）：进程当前的状态。 
* 调度信息（policy、prio、time_slice）：调度使用的调度策略、优先级和时间片等。 
* 记时信息（start_time、utime、stime）：进程建立的时间以及执行用户代码与系统代码的累计时间。 
* 信号信息（signal、sighand）：进程收到的信号以及使用的信号处理程序。 
* 退出码（exit_code）：进程运行结束后的退出代码，供父进程查询用。 
* 文件系统信息（fs、files）：包括文件系统及打开文件的信息。 
* 地址空间信息（mm）：进程使用的地址空间。 
* 硬件现场信息（thread）：进程切换时保存的CPU寄存器的内容。 
* 运行信息（thread_info）：有关进程运行环境、状况的CPU相关信息 
</p>]<p><h2>本书特色</h2></p>[<p>
本书以理论结合实践，注重应用为原则，全面、系统地讲述操作系统的基本原理，并将其与Linux的实现和应用技术紧密结合。全书内容分为3部分：第1部分为基础篇，包括Linux系统概述、Linux系统的操作基础、vi文本编辑器的使用以及Linux C编程基础；第2部分为原理篇，介绍操作系统的基本原理和Linux内核实现技术，包括进程管理、存储管理、文件管理、设备管理和操作系统接口；第3部分为应用篇，包括Shell程序设计、Linux系统管理和网络与通信应用。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书以理论结合实践，注重应用为原则，全面、系统地讲述操作系统的基本原理，并将其与Linux的实现和应用技术紧密结合。全书内容分为3部分：第1部分为基础篇，包括Linux系统概述、Linux系统的操作基础、vi文本编辑器的使用以及Linux C编程基础；第2部分为原理篇，介绍操作系统的基本原理和Linux内核实现技术，包括进程管理、存储管理、文件管理、设备管理和操作系统接口；第3部分为应用篇，包括Shell程序设计、Linux系统管理和网络与通信应用。</p>]