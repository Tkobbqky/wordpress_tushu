UNITY 3D SHADERLAB开发实战详解(第3版) PDF下载 郭浩瑜张鹤 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711550540
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711550540
<p>书名:UNITY 3D SHADERLAB开发实战详解(第3版)</p><p>作者:郭浩瑜  张鹤</p><p>页数:251</p><p>定价:¥79.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2018-01-01</p><p>ISBN:9787115505408</p><p><h2>本书特色</h2></p>[<p>
内 容 提 要 本书全面讲解了Unity Shader渲染的实用技术，分为5篇，共31章。主要内容有着色器的概念和渲染流水线，渲染原理和图形存储器，Unity中着色器的形态，着色器中用到的各种空间概念，基本的光照模型，通道，前向渲染路径，基于光照贴图的烘焙照明，柔和的低频照明，各种阴影，通道的通用指令开关，固定流水线，表面着色器，常用的材质，雾的计算，物体的分割，自定义光源，高级效果，以及着色器的组织和复用，渲染优化等。 本书适合移动开发者、游戏开发者、程序员阅读，也可作为大专院校相关专业的师生用书以及培训学校的教材。
                                        </p>]<p><h2>内容简介</h2></p>[<p>1.一本专一介绍底层渲染的图书 。对着色器的概念、渲染流水线以及图形存储器的解释，扩展了在阴影批处理和渲染优化方面的内容。同时，针对不好理解的体积阴影和体积光，改成了在世界坐标空间内实现的程序。 2.针对Unity 5.x全新改版，删减了一些第2版中难懂且没有实际意义的内容。 3.书中的彩图文件和工程文件全部提供给读者免费下载。 </p>]<p><h2>作者简介</h2></p>[<p>郭浩瑜，社区的技术分享者，Unity资深开发者，在游戏开发、Unity3D、特效开发上具有很高技术水平。</p>]<p><h2>目录</h2></p>
    目　　录第 1篇　初识庐山真面目—Unity　3D着色器第 1章　着色器的概念和渲染流水线　21.1　着色器的概念　21.1.1　虚拟世界中的光明和色彩　21.1.2　游戏开发人员的巅峰　21.1.3　着色器简史　21.1.4　着色器的实例化　31.1.5　着色器的实现语言　31.1.6　Unity中的着色器编程　41.2　渲染流水线　41.2.1　渲染流水线简介　41.2.2　渲染流水线阶段　51.3　渲染流水线执行阶段　61.3.1　输入装配阶段　61.3.2　顶点着色器　81.3.3　细化阶段　81.3.4　几何着色器　91.3.5　流输出阶段　101.3.6　片元着色器　101.3.7　输出合并阶段　111.4　其他一些细节　111.4.1　延迟渲染和前向渲染　111.4.2　批次合并渲染　13第 2章　渲染原理和图形存储器　142.1　渲染原理　142.1.1　立即模式渲染　142.1.2　基于区块的（延迟）渲染　162.2　图形存储器　182.2.1　GPU的存储系统层次体系　192.2.2　数据结构　202.2.3　渲染所需的数据结构　232.2.4　合并批次渲染原理回顾　23第3章　Unity中着色器的形态　253.1　Unity通过ShaderLab来组织着色器　253.1.1　关键字Shader　253.1.2　使用子着色器组织着色器的不同实现　253.1.3　子着色器的重要标签　253.1.4　子着色器中的Pass块　263.1.5　Pass块的标签及其名字的意义　263.1.6　使用FallBack语句保证着色器的广泛适应性　273.2　Unity支持的着色器编程语言　273.3　Unity中着色器的3种形态　273.3.1　固定流水线　273.3.2　可编程着色器　283.3.3　ShaderLab中的表面着色器　293.4　着色器的数据接口—属性和uniform变量　313.4.1　在Properties块中定义属性　313.4.2　通过图形界面操作属性　313.4.3　通过脚本操控属性　313.4.4　矩阵—不能在属性块中定义的变量　323.4.5　在Cg代码中使用属性　32第4章　着色器中用到的各种空间概念　334.1　模型空间　334.1.1　为什么用模型空间　334.1.2　在脚本和着色器中进出模型空间　334.2　世界坐标空间　334.2.1　统一的坐标空间—世界坐标空间　334.2.2　在脚本和着色器中进出世界坐标空间　344.3　视空间　344.3.1　渲染的需要—视空间　344.3.2　在脚本和着色器中进出视空间　344.4　空间的一块—视锥体　344.5　剪切空间　354.5.1　投影　354.5.2　脚本和着色器中的投影矩阵　354.5.3　验证NDC　354.6　NDC之后　36第5章　基本的光照模型　375.1　光源对物体照明的分类　375.1.1　间接照明　375.1.2　直接照明　375.2　亮度的计算方式—光照模型　375.2.1　漫反射和Lambert　375.2.2　镜面高光和Phong　385.2.3　半角向量和BlinnPhong　38第 2篇　让应用更炫彩—Unity中的照明第6章　第 一个执行的通道　426.1　不同的LightMode被选择的顺序　426.1.1　渲染路径和通道的LightMode标签　426.1.2　设计可以检测渲染路径的材质　426.1.3　设计便于检测渲染路径的场景　436.1.4　观察那些渲染的通道　436.2　3个渲染路径之外的处理方式　456.2.1　LightMode的其他值　456.2.2　设计检测用的材质　45第7章　前向渲染路径　477.1　渲染物体—ForwardBase和ForwardAdd　477.1.1　设计检测用的场景和材质　477.1.2　ForwardBase和ForwardAdd的表现　487.2　前向渲染路径下的光源　487.2.1　设计检测用的材质　487.2.2　光源的情况　487.2.3　Unity如何为前向渲染路径设置光源　49第8章　基于光照贴图的烘焙照明　508.1　烘焙的维度和属性矩阵　508.2　光照贴图　508.2.1　测试烘焙的场景　518.2.2　烘焙之后的场景　528.2.3　双光照贴图　528.3　在效果和性能间进行权衡　528.3.1　影响全局的Resolution选项　538.3.2　单个物体的选项　53第9章　柔和的低频照明　559.1　初识光照探头　559.1.1　光照探头照明的优点　559.1.2　检测光照探头照明的场景　559.1.3　使用光照探头组进行管理　579.1.4　烘焙场景光照信息到光照探头中　579.1.5　对比光照探头照明和实时照明　589.2　放置光照探头的注意事项　599.2.1　必须形成一个体积　599.2.2　单个光照探头必须处于采样光源的照射范围　599.3　照明采样的Anchor Override　599.3.1　动态更新光照探头　599.3.2　基于线性插值的采样　599.3.3　改变默认的插值位置　599.4　光照探头照明和阴影　609.4.1　光照探头和光照贴图的异同　609.4.2　烘焙阴影时可能会犯的错误　619.4.3　将静态物体的阴影烘焙到光照探头上　619.4.4　光照探头照明和实时阴影的混合　629.5　烘焙一个色彩丰富的场景　629.6　在自己的材质中使用光照探头　639.6.1　为前向渲染路径中的材质计算光照探头　639.6.2　使用ShadeSH9函数　649.6.3　在一个表面着色器中进行计算　659.7　LPPV的设计目的　669.7.1　LPPV是什么　669.7.2　照明的场景　66第3篇　使应用更逼真—阴影第 10章　平面阴影　7010.1　平行光对平面的投影　7010.1.1　对平行光投影的考虑　7010.1.2　进出阴影接受平面的矩阵　7010.1.3　使用三角形相似计算阴影　7110.2　点光源对平面的投影　7210.3　阴影的淡出　7310.3.1　有效利用平面阴影计算过程中的数据　7310.3.2　潜在的问题　74第 11章　球体阴影　7511.1　平行光对球体的投影　7511.1.1　投影球体的信息　7511.1.2　使用相似三角形计算投影　7511.2　阴影的淡入/淡出　7611.3　点光源对球体的投影　77第 12章　体积阴影　7812.1　将顶点沿某一方向挤出　7812.1.1　在Vertex函数中操作　7812.1.2　判断顶点是向光还是背光　7912.2　从体积中找到阴影区域　7912.2.1　两次挤出　7912.2.2　计算出阴影区域　8012.2.3　渲染阴影　8012.2.4　需要注意的问题　80第 13章　阴影映射　8213.1　灯光空间和相机空间　8213.1.1　观察两个空间　8213.1.2　两个视角的Z深度　8213.1.3　渲染Z深度的材质　8313.2　投射Z深度　8313.2.1　准备灯光视角的投影矩阵　8313.2.2　在材质中计算投影后的Z深度　8413.3　比较Z深度　8513.3.1　比较Z深度的材质　8513.3.2　Z深度的精度引起的问题　8713.3.3　提高Z深度的精度　8713.3.4　对Z深度值进行偏移　88第 14章　内置的阴影　8914.1　Unity实时阴影的原理　8914.1.1　基本原理　8914.1.2　软阴影　8914.2　投射阴影　9014.2.1　使用ShadowCaster投射阴影　9014.2.2　在ShadowCaster里都做了什么　9114.2.3　写一个自己的ShadowCaster　9114.2.4　改变ShadowCaster的行为　9214.2.5　阴影和FallBack机制　9214.3　接受阴影　9414.4　表面着色器和阴影　9414.4.1　表面着色器的阴影和Fallback　9414.4.2　表面着色器里的灯光参数和阴影　9514.4.3　表面着色器对前向渲染路径下阴影的支持　9514.5　阴影的批处理　9614.5.1　批处理阴影的好处　9614.5.2　简单的Caster　9714.5.3　静态阴影的批处理　9814.5.4　动态阴影的批处理　100第4篇　Unity中的各种着色器第 15章　通道的通用指令开关　10415.1　使用LOD在运行时决定材质　10415.1.1　材质的LOD　10415.1.2　在运行时设定单个材质的LOD　10415.1.3　设定全局所有材质的LOD　10515.2　渲染队列　10615.2.1　标签队列和渲染顺序　10615.2.2　渲染队列和ZTest判断　10715.2.3　Unity中内置的渲染队列　10715.2.4　一个利用渲染队列的例子　10715.3　透明的产生　10815.3.1　Alpha检测和8种比较条件　10815.3.2　生成着色器的内容　10815.3.3　结合AlphaTest和Blend操作　10915.4　混合操作及其应用　11015.4.1　混合操作　11015.4.2　生成着色器的代码　11015.4.3　检测不同的混合操作　11015.4.4　BlendOp选项　11115.4.5　检测BlendOp操作　11215.4.6　两个使用Blend生成的效果　11215.5　使用ColorMask　11415.5.1　ColorMask的作用　11415.5.2　检测ColorMask　11415.5.3　一个使用ColorMask的例子　11515.6　深度测试　11615.6.1　存取场景的深度测试　11615.6.2　RenderType标签和与生成深度测试的关联　11615.6.3　内置RenderType的值　11715.6.4　前向渲染路径下的深度测试　11715.7　Z深度的偏移量　11815.7.1　干预正常深度测试的手段　11815.7.2　观察偏移量在不同应用条件下的表现　11815.8　面的剔除操作　11815.9　自动生成贴图的坐标　11915.9.1　ObjectLinear和等价的Cg代码　11915.9.2　EyeLinear和等价的Cg代码　12015.9.3　SphereMap和等价的Cg代码　12115.9.4　CubeReflect和等价的Cg代码　12215.9.5　CubeNormal和等价的Cg代码　12215.10　抓屏操作　12315.10.1　如何使用GrabPass　12315.10.2　一个模拟曲面反射的例子　12415.11　雾效　12415.11.1　雾效和Unity的3种实现　12415.11.2　材质中对雾效的控制　12515.11.3　实现自己的雾效　12615.12　蒙版　12815.12.1　蒙版测试、Z深度和Alpha测试　12815.12.2　使用蒙版测试改变渲染结果　12815.12.3　综合使用蒙版和队列　128第 16章　固定流水线　13016.1　Unity中的固定流水线　13016.1.1　固定流水线基本形态　13016.1.2　与照明相关的Material块　13016.1.3　处理纹理的SetTexture块　13116.1.4　流水线基本形态的另一种写法　13116.1.5　Combine语句　13116.2　使用顶点色　13216.2.1　使用ColorMaterial　13216.2.2　使用Bind　13216.3　在固定流水线中使用光照贴图　13216.4　嵌套Cg代码　133第 17章　表面着色器　13417.1　表面着色器的适应性　13417.1.1　一个分析策略　13417.1.2　测试用的场景　13417.1.3　检测结果　13517.2　延迟渲染和GeoBuffer　13517.3　表面着色器的特殊性　13617.3.1　表面着色器的混合和透明　13617.3.2　自定义Vertex函数　137第 18章　凹凸材质　13918.1　切空间　13918.2　凹凸贴图　13918.2.1　计算到切空间的矩阵　13918.2.2　Unity中法线贴图的压缩格式　14018.2.3　使用切空间矩阵的另一种方法　14018.2.4　Unity对切空间计算的支持　14118.2.5　解压缩法线贴图的函数　14118.2.6　在切空间中计算高光　14218.2.7　表面着色器和切空间　14218.3　视差映射　14318.3.1　视差映射及其别名　14318.3.2　一个使用灰度图来偏移UV的材质　14318.3.3　结合法线贴图　14518.3.4　用视角来决定UV偏移量　14518.3.5　一个完整的实现　14618.4　地势映射　14718.4.1　视差映射的极限和地势映射的面世　14718.4.2　地势映射的算法　14818.4.3　一个完整的实现　148第 19章　卡通材质　15119.1　描边　15119.1.1　沿法线挤出轮廓　15119.1.2　容易产生的问题　15219.1.3　在视空间中挤出　15219.1.4　顶点位置的另一个含义　15319.1.5　调和法线和顶点方向　15419.1.6　判断顶点的指向　15419.1.7　不仅仅是轮廓　15519.1.8　通过Z偏移量来描边　15819.2　卡通着色　15819.2.1　对光照进行离散化　15819.2.2　使用2D贴图重新映射光照　160第 20章　镜面材质　16220.1　镜像一个相机　16220.1.1　镜子里的世界和我的计划　16220.1.2　在脚本中对位置和角度进行镜像　16220.2　使用镜像相机来渲染和投影　16320.2.1　镜面材质的工作—采样被投影的渲染结果　16320.2.2　脚本的工作—渲染镜像相机和设置投影矩阵　16420.3　镜像相机的近剪切平面和倾斜矩阵　16420.3.1　调节近剪切平面　16420.3.2　使用倾斜矩阵微调视锥体　165第 21章　透明和半透明材质　16621.1　半透明材质　16621.2　化繁为简　16621.3　透明材质　167第 22章　体积雾　17022.1　距离的表达—相对于背景的体积雾　17022.1.1　需要计算的东西　17022.1.2　使用一个通道来完成所有的计算　17022.1.3　黑色的雾效　17122.2　厚度的表达—物体形体的体积雾　17222.2.1　必须计算的两个数据　17222.2.2　在Unity中使用一个通道来完成所有计算　172第 23章　面积光　17523.1　线光源　17523.1.1　点、线、面　17523.1.2　如何理解一个线光源　17523.1.3　通过脚本传递线光源的几何信息　17523.1.4　计算线光源的照明　17623.1.5　线光源的辐射方向　17723.1.6　线光源的衰减　17823.2　面积光源　17923.2.1　面积光和线光源的不同　17923.2.2　通过脚本设定面积光的几何特性　17923.2.3　计算面积光　17923.2.4　和默认照明的整合　181第 24章　体积光　18324.1　体积光和体积阴影　18324.1.1　体积光　18324.1.2　体积光和体积阴影的关系　18324.2　实现体积光　18324.2.1　在着色器中表现体积光　18324.2.2　脚本的帮助　184第 25章　材质替代渲染　18625.1　相机和渲染消息　18625.1.1　相机的渲染消息发送顺序　18625.1.2　*后能改变Cull操作结果的地方　18625.1.3　*后能设置材质数据的地方　18725.2　如何使用RenderWithShader方法　18725.2.1　标签值不同的5个着色器　18725.2.2　调用RenderWithShader方法的脚本　18925.2.3　替换用的5个材质　19025.2.4　检测RenderWithShader方法的效果　19125.2.5　使用子着色器组织替代材质　19125.2.6　如何设置替代材质的属性　19225.2.7　将结果输出到屏幕上　19225.3　SetReplacementShader和ResetReplacementShader与RenderWithShader方法的异同　193第 26章　后期效果　19426.1　Graphics的两个方法　19426.1.1　与相机渲染方法的不同之处　19426.1.2　Blit方法的简单示例　19426.1.3　使用BlitMultiTap方法进行多重采样　19526.2　一个简单的调色　19926.2.1　调色用的脚本　19926.2.2　调色用的材质　20026.2.3　更高效的做法　20126.3　景深　20326.3.1　用于模糊图像的材质　20326.3.2　进行纵横两次模糊操作　20426.3.3　进行混合操作的脚本　20426.3.4　进行混合操作的材质　20526.3.5　提供一个可调节参数　20626.4　轮廓检测　20626.4.1　用脚本获得场景的Z深度和法线　20726.4.2　在材质中进行边缘检测　20726.5　扭曲　20826.5.1　通过UV操作扭曲图像　20826.5.2　限定扭曲的区域　20926.5.3　使用物体来做遮罩　21026.6　运动模糊　21326.6.1　如何记录运动轨迹　21326.6.2　实现运动模糊的材质　21326.6.3　用于完成整个过程的脚本　21426.6.4　通过Alpha和帧的混合操作实现运动模糊　21526.7　噪波　21526.7.1　根据Z深度来混合噪波　21626.7.2　根据明暗程度来混合噪波　21726.8　色彩的溢出　21726.8.1　色彩溢出的算法考量　21826.8.2　实现色彩溢出的采样计算　218第 27章　投影　22027.1　Unity的Projector　22027.1.1　Projector中材质的执行顺序　22027.1.2　如何写Projector使用的材质　22027.1.3　控制投影淡进淡出的矩阵　22127.2　实现自己的投影　22227.2.1　设定投影矩阵的脚本　22227.2.2　采样投影的材质　22327.2.3　直接投影到屏幕上　224第 28章　分割一个物体　22528.1　分割一个物体的思路　22528.1.1　我们需要什么样的信息　22528.1.2　脚本的帮助　22528.2　在着色器中剪切一个物体　225第5篇　着色器的组织和优化第 29章　着色器的组织和复用　22829.1　cginc文件　22829.1.1　Unity的UnityCG.cginc文件　22829.1.2　定义自己的cginc文件　22829.1.3　使用自定义的cginc文件　22929.2　通过UsePass来复用通道　22929.2.1　定义自己要复用的通道　22929.2.2　复用这些通道　23029.3　定义着色器的关键字　23129.3.1　使用关键字改变着色器的行为　23129.3.2　自定义着色器的关键字　23129.4　使用multi_compile编译着色器的多个版本　23229.4.1　使用multi_compile实现多次编译　23229.4.2　在脚本中选择着色器的版本　23229.4.3　使用自定义的材质编辑器　23329.4.4　MaterialEditor　23329.5　Unity对DX11支持所带来的问题　234第30章　基本的渲染概念　23630.1　逐顶点计算和逐像素计算　23630.1.1　逐顶点计算　23630.1.2　逐像素计算　23630.1.3　如何在这两个概念中取舍　23630.2　绘制调用的意义　23630.2.1　绘制调用的概念　23630.2.2　正确理解绘制调用对开发应用的意义　23630.2.3　合批的概念和Unity为优化绘制调用所做的工作　23730.2.4　优化绘制调用　23730.3　利用渲染队列的技巧　23730.3.1　渲染队列的概念　23730.3.2　设置渲染队列的技巧　237第31章　渲染优化　23831.1　渲染优化的元素　23831.2　小型物体的优化　23831.3　中型物体的优化　24031.4　大型物体的优化　24131.5　模型的优化　24231.6　地形的优化　24331.7　UI的优化　24631.8　物理引擎　24831.9　慎用后期效果　24831.10　慎用透明效果　24831.11　其他　24831.12　移动平台的特点　24931.12.1　一些指令的运算速度　24931.12.2　几何复杂度　24931.12.3　贴图的问题　24931.12.4　数据类型的使用方式　25031.12.5　变量的使用　251附录　相关资源　252
