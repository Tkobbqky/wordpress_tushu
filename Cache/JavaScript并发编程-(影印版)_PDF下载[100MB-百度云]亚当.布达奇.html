JavaScript并发编程-(影印版) PDF下载 亚当.布达奇 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#756417076
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#756417076
<p>书名:JavaScript并发编程-(影印版)</p><p>作者:亚当.布达奇</p><p>页数:267</p><p>定价:¥69.0</p><p>出版社:东南大学出版社</p><p>出版日期:2017-04-01</p><p>ISBN:9787564170769</p><p><h2>本书特色</h2></p>[<p>
JavaScript已经具备了并发能力，这也解释了为 什么这门语言至今仍然屹立于现代web开发的前沿阵 地。亚当·布达奇编*的《JavaScript并发编程(影 印版)(英文版)》将帮助你深入JavaScript并发编程 的世界，演示如何应用其核心原理、关键技术以及工 具来应对各种复杂的开发难题。围绕并发编程的三个 核心要素：并发、同步和保护，你将学会如何编写* 高效、*富于变化的JavaScript程序，从而提高用户 体验。<br/>    书中通过采用各种开发方法，带领你将这些原理 应用于实践。从JavaScript promises、web  workers、生成器到函数式编程技术，所有这些知识 都将对你的应用程序性能产生实实在在的影响。除此 之外，还进一步讨论了NodeJS并发编程。在成长为* **的Web开发人员的道路上，本书将助你一臂之力 。
                                        </p>]<p><h2>目录</h2></p>
    
Preface
Chapter 1: Why JavaScript Concurrency?Synchronous JavaScriptSynchronicity is easy to understandAsynchronous is inevitableAsynchronous browsersTypes of concurrencyAsynchronous actionsParallel actionsJavaScript concurrency principles: Parallelize, Synchronize,ConserveParallelizeSynchronizeThe Promise APIConserveSummary
Chapter 2: The JavaScript Execution ModelEverything is a taskMeet the playersThe Execution environmentEvent loopsTask queuesExecution contextsMaintaining execution stateJob queuesCreating tasks using timersUsing setTimeout()Using setlnterval()Responding to DOM eventsEvent targetsManaging event frequencyResponding to network eventsMaking requestsCoordinating requestsConcurrency challenges with this modelLimited opportunity for parallelismSynchronization through callbacksSummary
Chapter 3: Synchronizing with PromisesPromise terminologyPromiseStateExecutorResolverRejectorThenableResolving and rejecting promisesResolving promisesRejecting promisesEmpty promisesReacting to promisesResolution job queuesUsing promised dataError callbacksAlways reactingResolving other promisesPromise-like objectsBuilding callback chainsPromises only change state onceImmutable promisesMany then callbacks, many promisesPassing promises aroundSynchronizing several promisesWaiting on promisesCancelling promisesPromises without executorsSummary
Chapter 4: Lazy Evaluation with GeneratorsCall stacks and memory allocationBookmarking function contextsSequences instead of arraysCreating generators and yielding valuesGenerator function syntaxYielding valuesIterating over generatorsInfinite sequencesNo end in sightAlternating sequencesDeferring to other generatorsSelecting a strategyInterweaving generatorsPassing data to generatorsReusing generatorsLightweight map/reduceCoroutinesCreating coroutine functionsHandling DOM eventsHandling promised valuesSummary
Chapter 5: Working with WorkersWhat are workers?OS threadsEvent targetsTrue parallelismTypes of workersDedicated workersSub-workersShared workersWorker environmentsWhat's available, what isn't?Loading scriptsCommunicating with workersPosting messagesMessage serializationReceiving messages from workersSharing application stateSharing memoryFetching resourcesCommunicating between pagesPerforming sub-tasks with sub-workersDividing work into tasksA word of cautionError handling in web workersError condition checkingException handlingSummary
Chapter 6: Practical ParallelismFunctional programmingData in, data outImmutabilityReferential transparency and timeDo we need to go parallel?How big is the data?Hardware concurrency capabilitiesCreating tasks and assigning workCandidate problemsEmbarrassingly parallelSearching collectionsMapping and reducingKeeping the DOM responsiveBottom halvesTranslating DOM manipulationTranslating DOM eventsSummary
Chapter 7: Abstracting ConcurrencyWriting concurrent codeHiding the concurrency mechanismWithout concurrencyWorker communication with promisesHelper functionsExtending postMessage0Synchronizing worker resultsLazy workersReducing overheadGenerating values in workersLazy worker chainsUsing Parallel.jsHow it worksSpawning workersMapping and reducingWorker poolsAllocating poolsScheduling jobsSummary
Chapter 8: Evented IO with NodeJSSingle threaded IOIO is slowIO eventsMulti-threading challengesMore connections, more problemsDeploying to the InternetThe C10K problemLightweight event handlersEvented network IOHandling HTTP requestsStreaming responsesProxy network requestsEvented file IOReading from filesWriting to filesStreaming reads and writesSummary
Chapter 9: Advanced NodeJS ConcurrencyCoroutines with CoGenerating promisesAwaiting valuesResolving valuesAsynchronous dependenciesWrapping coroutinesChild ProcessesBlocking the event loopForking processesSpawning external processesInter-process communicationProcess ClustersChallenges with process managementAbstracting process poolsServer clustersProxying requestsFacilitating micro-servicesInformed load balancingSummary
Chapter 10: Building a Concurrent ApplicationGetting startedConcurrency firstRetrofitting concurrencyApplication typesRequirementsThe overall goalThe APIThe UIBuilding the APIThe HTTP server and routingCo-routines as handlersThe create chat handlerThe join chat handlerThe load chat handlerThe send message handler.Static handlersBuilding the UITalking to the APIImplementing the HTMLDOM events and manipulationAdding an API workerAdditions and improvementsClustering the APICleaning up chatsAsynchronous entry pointsWho's typing?Leaving chatsPolling timeoutsSummary
Index

