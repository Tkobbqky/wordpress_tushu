Rust编程之道 PDF下载 张汉东 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712135485
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712135485
<p>书名:Rust编程之道</p><p>作者:张汉东</p><p>页数:580</p><p>定价:¥128.0</p><p>出版社:电子工业出版社</p><p>出版日期:2019-01-01</p><p>ISBN:9787121354854</p><p><h2>节选</h2></p>[<p>序 <br/>当我2015 年开始学习Rust 的时候，我绝对没有想过要写一本Rust 编程的书。 <br/>缘起 <br/>当时我刚刚翻译完《Ruby 原理剖析》一书，开始对底层开发产生了一点点兴趣。从2006年入行以来，我就一直和动态语言打交道。虽然自己也想学习底层开发，但能选择的语言几乎只有C++。我在学校里浅浅地学过C++这门语言，也许是**印象作怪，总难以提起对C++的兴趣。 <br/>当Rust 1.0 发布时，我去官方网站了解了一下Rust 语言，发现它的主要特点有以下几方面： <br/>? 系统级语言 <br/>? 无GC <br/>? 基于LLVM <br/>? 内存安全 <br/>? 强类型+静态类型 <br/>? 混合编程范式 <br/>? 零成本抽象 <br/>? 线程安全 <br/>我一下子就被这些鲜明的特性“击中”了，从此开始了Rust 的学习。 <br/>再一次爱上编程 <br/>**次爱上编程是在上小学时。父亲给我买回来一台金字塔学习机，这台学习机有两种功能，一种是学习Logo 语言，另一种是玩卡带游戏。编写Logo 语言就是用小海龟画图，也许是因为太早了，也许是因为没有人引导，那时的我选择了痛快地玩游戏。总想着先玩游戏，再去学怎么编程，然后还幻想着能不能用Logo 语言编写一个游戏。其实这时候的我对编程更多的是一种憧憬，并没有在学习编程上付出更多的实际行动。 <br/>第二次爱上编程是在大学初次学习C 语言的时候。我本可以选择计算机科学专业，但是*后还是选了电子信息科学与技术专业。这样选是因为我想把软硬件都学了。想法是好的，可惜实施起来并不容易。*后的结果就是，软硬件都没学好。 <br/>第三次爱上编程是在遇到Ruby 语言的时候。当时我在用Java，并且已经完全陷入了Java语言和Web 框架纷繁复杂的细节中，痛苦不堪。Ruby on Rails 框架的横空出世，把我从这种状态中解救了出来。Ruby 语言的优雅和自由，以及“让程序员更快乐”的口号深深地吸引了我。这一次我是真正爱上了编程，并且积极付诸行动去学习和提升自己。此时也恰逢互联网创业大潮的开始，Ruby 语言的开发效率让它迅速成为创业公司的宠儿，因此，我也借着Ruby这门语言参与到了这股创业洪流中。 <br/>第四次爱上编程是在遇到Rust 的时候。此时，创业洪流已经退潮。技术圈有句话，叫“十年一轮回”。当年喜欢Ruby 给开发过程带来的快乐，但是随着时代的变革和业务规模的增长，我不禁开始重新思考一个问题：何谓快乐？真正的快乐不仅仅是写代码时的“酸爽”，更应该是代码部署到生产环境之后的“安稳”。Rust 恰恰可以给我带来这种“双重快乐”体验。 <br/>为什么是Rust <br/>社区中有人模仿阿西莫夫的机器人三大定律，总结了程序的三大定律： <br/>? 程序必须正确。 <br/>? 程序必须可维护，但不能违反**条定律。 <br/>? 程序必须高效，但不能违反前两条定律。 <br/>程序的正确性，一方面可以理解为该程序满足了实际的问题需求，另一方面是指满足了它自身的程序规约。那么如何保证程序的正确性呢？首先，可以通过对程序的各种测试、断言和错误处理机制，来保证其满足实际的问题需求。其次，在数学和计算机科学已经融合的今天，通过较为成熟的类型理论即可保证程序自身的规约正确。 <br/>以我*熟悉的Ruby 语言为例，程序的正确性必须依赖于开发者的水平，并需要大量的测试代码来保证正确性。即便在100%测试覆盖率的条件下，也经常会遇到NilError 之类的空指针问题。也就是说，Ruby 程序自身的正确性还没有得到保证。以此类推，C、C++、Python、Java、JavaScript 等语言都有同样的问题。 <br/>而函数式编程语言在这方面要好很多，尤其是号称纯函数式的Haskell 语言，它具有融合了范畴理论的类型系统，利用了范畴理论自身的代数性质和定律保证了程序自身的正确性。然而，Haskell 也有比较明显的缺点，比如它不满足上述第三条定律，运行效率不高。 <br/>反观Rust 语言，对程序的三定律支持得恰到好处。它借鉴了Haskell 的类型系统，保证了程序的正确性。但还不止于此，在类型系统的基础上，Rust 借鉴了现代C++的内存管理机制，建立了所有权系统。不仅保证了类型安全，还保证了内存安全。同时，也解决了多线程并发编程中的数据竞争问题，默认线程安全。再来看代码的可维护性，Rust 代码的可读性和抽象能力都是一流的。不仅拥有高的开发效率，还拥有可以和C/C++媲美的性能。当然，没有银弹，但Rust 就是我目前想要的语言。 <br/>目前Rust 被陆续应用在区块链、游戏、WebAssembly 技术、机器学习、分布式数据库、网络服务基础设施、Web 框架、操作系统和嵌入式等领域。时代在变化，未来的互联网需要的是安全和性能并重的语言，Rust 必然会在其中大放异彩。 <br/>学习Rust 带来了什么收获 <br/>Rust 是一门现代化的语言，融合了多种语言特性，而且Rust 语言可以应用的领域范围非常广泛。在学习Rust 的过程中，我发现自己的编程能力在很多方面存在短板。突破这些短板的过程实际上就是一次自我提升的过程。 <br/>Rust 是一门成长中的新语言，学习Rust，跟随Rust 一起成长，可以体验并参与到一门真正工业化语言的发展进程中，感觉就像在创造历史。虽然我并未给Rust 语言提交过PR，但也为Rust 语言和社区多次提交过Bug，以及文档和工具的改进意见。 <br/>Rust 自身作为一个开源项目，算得上是开源社区中的“明星”项目了。学习Rust 的过程加深了我对开源社区的认识，也开拓了我的眼界。 <br/>为什么要写这本书 <br/>在学习Rust 一年之后，我写下了《如何学习一门新语言》一文，其中记录了我学习Rust的心得，这篇文章颇受好评。也正因为这篇文章，电子工业出版社的刘恩惠编辑找到了我，并询问是否可以出一本Rust 编程的书籍。我当时也正想通过一本书来完整地表达自己的学习心得，再加上中文社区中没有较全面系统的Rust 书籍，于是，一拍即合。 <br/>写书的过程可以形容为痛并快乐着。Rust 语言正值成长期，很多语言特性还在不断地完善。举一个极端的例子，比如写下某段代码示例并成功编译后，过了三天却发现它无法编译通过了。于是，我再一次跟进Rust 的RFC、源码、ChangeLog 去看它们的变更情况，然后再重新修订代码示例。这个过程虽然痛苦，但改完之后会发现Rust 的这个改进确实是有必要的。 <br/>在这个过程中，我看到了Rust 的成长，以及Rust 团队为保证语言一致性和开发者的开发体验所付出的努力，让我感觉自己花再多时间和精力去修改本书的内容都是值得的。 <br/>话说回来，任何人做事都是有动机或目的的，我也不例外。我写这本书的目的主要有以下三个。 <br/>? 为Rust 中文社区带来一本真正可以全面系统地学习Rust 的书。 <br/>? 以教为学。在写作的过程中，让自己所学的知识进一步内化。 <br/>? 传播一种自学方法。本书内容以Rust 语言的设计哲学为出发点，按照从整体到细节的思路逐个阐述每个语言特性，希望读者可以产生共鸣。 <br/>结语 <br/>我自己作为本书的**位读者，目前对这本书是非常满意的。衷心希望每一位读者都能从本书中收获新知。当然，我也知道不可能让每一位读者都满意。在我看来，写书不仅是在传播知识和思想，更是一种交流和沟通。所以，当你不满意的时候，可以来找我交流，提出更多建设性意见，帮助我成长。我争取在写下一本书的时候，让更多的人满意。而且，如果你的建议确实中肯，让我得到了成长，我也为你准备了不错的小礼物。</p>]<p><h2>本书特色</h2></p>[<p>
                                    适读人群 ：适合本书的读者群体包括： 1.	有一定编程经验，想要学习Rust的初学者。 2.	对Rust有一定了解，还想对Rust深入学习的进阶者。 本书不适合完全没有编程基础的人学习。<br/>                                √ Rust，集安全、高性能、高效率、高可读性于一身，是开发一款优秀产品不得不考虑的编程语言，学习Rust势在必行！ <br/>√ 本书作者作为Rust语言的早期实践者，以及中国社区的管理运营者，对Rust的设计理念有深入理解，并有丰富的实践经验。 <br/>√ 从设计哲学、源码分析、工程视角、底层原理多个维度，对Rust语言进行系统化梳理，帮助读者理清知识脉络，降低学习曲线。 <br/>√ 本书附有随书源码，配套运行，方便读者在实践中巩固理论知识，熟悉Rust在生产环境中的应用，避免纸上谈兵的尴尬。            
                                        </p>]<p><h2>内容简介</h2></p>[<p>Rust 是一门利用现代化的类型系统，有机地融合了内存管理、所有权语义和混合编程范式的编程语言。它不仅能科学地保证程序的正确性，还能保证内存安全和线程安全。同时，还有能与C/C++语言媲美的性能，以及能和动态语言媲美的开发效率。 <br/>《Rust编程之道》并非对语法内容进行简单罗列讲解，而是从四个维度深入全面且通透地介绍了Rust 语言。从设计哲学出发，探索Rust 语言的内在一致性；从源码分析入手，探索Rust 地道的编程风格；从工程角度着手，探索Rust 对健壮性的支持；从底层原理开始，探索Rust 内存安全的本质。 <br/>《Rust编程之道》涵盖了Rust 2018 的特性，适合有一定编程经验且想要学习Rust 的初学者，以及对Rust 有一定的了解，想要继续深入学习的进阶者。</p>]<p><h2>作者简介</h2></p>[<p>张汉东，80后，资深软件工程师、企业独立咨询师、技术作者译者。爱好读书、写作，喜欢研究技术、学习之道，以及心智和认知开发模式。曾在互联网行业沉浮十余载，先后效力于电商、社交游戏、广告和众筹领域。作为企业独立咨询师，先后为思科、平安科技和闪迪等公司提供咨询服务。目前在心智教育及创客领域开疆拓土。是《Ruby原理剖析》一书的译者。喜欢Rust语言，为Rust语言提交了三次编译器Bug，并协助修复其中之一。为官方Rust 2018 Guide做过贡献，并数次提出改进意见。参与了国内Rust社区的管理和运营，在2018年打造了《Rust每日新闻》频道，深受Rustacean们的喜爱。为初学者精心打造了Rust必学第一课：知乎Live《如何系统地学习Rust语言》，获得五星好评。</p>]<p><h2>目录</h2></p>
第1 章 新时代的语言  1 1.1 缘起  1 1.2 设计哲学  3 1.2.1 内存安全  3 1.2.2 零成本抽象  4 1.2.3 实用性  5 1.3 现状与未来  7 1.3.1 语言架构  8 1.3.2 开源社区  9 1.3.3 发展前景  9 1.4 Rust 代码如何执行  10 1.5 小结  10 第2 章 语言精要  11 2.1 Rust 语言的基本构成  11 2.1.1 语言规范  11 2.1.2 编译器  12 2.1.3 核心库  12 2.1.4 标准库  12 2.1.5 包管理器  13 2.2 语句与表达式  13 2.3 变量与绑定  14 2.3.1 位置表达式和值表达式  15 2.3.2 不可变绑定与可变绑定  15 2.3.3 所有权与引用  16 2.4 函数与闭包  17 2.4.1 函数定义  17 2.4.2 作用域与生命周期  18 2.4.3 函数指针  19 2.4.5 CTFE 机制  20 2.4.6 闭包  20 2.5 流程控制  22 2.5.1 条件表达式  22 2.5.2 循环表达式  23 2.5.3 match 表达式与模式匹配  24 2.5.4 if let 和while let 表达式  25 2.6 基本数据类型  26 2.6.1 布尔类型  26 2.6.2 基本数字类型  26 2.6.3 字符类型  27 2.6.4 数组类型  28 2.6.5 范围类型  29 2.6.6 切片类型  29 2.6.7 str 字符串类型  30 2.6.8 原生指针  31 2.6.9 never 类型  31 2.7 复合数据类型  32 2.7.1 元组  32 2.7.2 结构体  33 2.7.3 枚举体  36 2.8 常用集合类型  38 2.8.1 线性序列：向量  38 2.8.2 线性序列：双端队列  39 2.8.3 线性序列：链表  40 2.8.4 Key-Value 映射表：HashMap 和BTreeMap  40 2.8.5 集合：HashSet 和BTreeSet  41 2.8.6 优先队列：BinaryHeap  42 2.9 智能指针  42 2.10 泛型和trait  43 2.10.1 泛型  43 2.10.2 trait  44 2.11 错误处理  47 2.12 表达式优先级  48 2.13 注释与打印  48 2.14 小结  50 第3 章 类型系统  51 3.1 通用概念  51 3.1.1 类型系统的作用  51 3.1.2 类型系统的分类  52 3.1.3 类型系统与多态性  53 3.2 Rust 类型系统概述  53 3.2.1 类型大小  53 3.2.2 类型推导  58 3.3 泛型  60 3.3.1 泛型函数  60 3.3.2 泛型返回值自动推导  62 3.4 深入trait  62 3.4.1 接口抽象  63 3.4.2 泛型约束  69 3.4.3 抽象类型  71 3.4.4 标签trait  77 3.5 类型转换  83 3.5.1 Deref 解引用  83 3.5.2 as 操作符  86 3.5.3 From 和Into  88 3.6 当前trait 系统的不足  89 3.6.1 孤儿规则的局限性  90 3.6.2 代码复用的效率不高  91 3.6.3 抽象表达能力有待改进  93 3.7 小结  94 第4 章 内存管理  95 4.1 通用概念  95 4.1.1 栈  96 4.1.2 堆  99 4.1.3 内存布局  101 4.2 Rust 中的资源管理  103 4.2.1 变量和函数  103 4.2.2 智能指针与RAII  106 4.2.3 内存泄漏与内存安全  110 4.2.4 复合类型的内存分配和布局  115 4.3 小结  117 第5 章 所有权系统  119 5.1 通用概念  120 5.2 所有权机制  123 5.3 绑定、作用域和生命周期  125 5.3.1 不可变与可变  126 5.3.2 绑定的时间属性——生命周期  127 5.4 所有权借用  131 5.5 生命周期参数  135 5.5.1 显式生命周期参数  136 5.5.2 省略生命周期参数  143 5.5.3 生命周期限定  145 5.5.4 trait 对象的生命周期  145 5.6 智能指针与所有权  146 5.6.1 共享所有权 Rc和Weak  149 5.6.2 内部可变性Cell和RefCell  151 5.6.3 写时复制Cow  153 5.7 并发安全与所有权  156 5.8 非词法作用域生命周期  157 5.9 小结  161 第6 章 函数、闭包与迭代器  162 6.1 函数  162 6.1.1 函数屏蔽  164 6.1.2 函数参数模式匹配  164 6.1.3 函数返回值  165 6.1.4 泛型函数  166 6.1.5 方法与函数  167 6.1.6 高阶函数  168 6.2 闭包  171 6.2.1 闭包的基本语法  172 6.2.2 闭包的实现  173 6.2.3 闭包与所有权  178 6.2.4 闭包作为函数参数和返回值  184 6.2.5 高阶生命周期  190 6.3 迭代器  194 6.3.1 外部迭代器和内部迭代器  194 6.3.2 Iterator trait  195 6.3.3 IntoIterator trait 和迭代器  199 6.3.4 迭代器适配器  202 6.3.5 消费器  207 6.3.6 自定义迭代器适配器  211 6.4 小结  214 第7 章 结构化编程  216 7.1 面向对象风格编程  217 7.1.1 结构体  217 7.1.2 枚举体  225 7.1.3 析构顺序  230 7.2 常用设计模式  233 7.2.1 建造者模式  234 7.2.2 访问者模式  236 7.2.3 RAII 模式  239 7.3 小结  243 第8 章 字符串与集合类型  244 8.1 字符串  244 8.1.1 字符编码  244 8.1.2 字符  247 8.1.3 字符串分类  249 8.1.4 字符串的两种处理方式  251 8.1.5 字符串的修改  253 8.1.6 字符串的查找  256 8.1.7 与其他类型相互转换  265 8.1.8 回顾  270 8.2 集合类型  271 8.2.1 动态可增长数组  271 8.2.2 映射集  281 8.3 理解容量  289 8.4 小结  292 第9 章 构建健壮的程序  294 9.1 通用概念  294 9.2 消除失败  295 9.3 分层处理错误  297 9.3.1 可选值Option  298 9.3.2 错误处理Result  302 9.4 恐慌（Panic）  314 9.5 第三方库  316 9.6 小结  319 第10 章 模块化编程  320 10.1 包管理  321 10.1.1 使用Cargo 创建包  321 10.1.2 使用第三方包  323 10.1.3 Cargo.toml 文件格式  331 10.1.4 自定义Cargo  337 10.2 模块系统  339 10.3 从零开始实现一个完整功能包  344 10.3.1 使用Cargo 创建新项目  345 10.3.2 使用structopt 解析命令行参数  345 10.3.3 定义统一的错误类型  347 10.3.4 读取CSV 文件  348 10.3.5 替换CSV 文件中的内容  351 10.3.6 进一步完善包  353 10.4 可见性和私有性  358 10.5 小结  360 第11 章 安全并发  362 11.1 通用概念  362 11.1.1 多进程和多线程  363 11.1.2 事件驱动、异步回调和协程  364 11.1.3 线程安全  365 11.2 多线程并发编程  370 11.2.1 线程管理  371 11.2.2 Send 和Sync  375 11.2.3 使用锁进行线程同步  379 11.2.4 屏障和条件变量  384 11.2.5 原子类型  386 11.2.6 使用Channel 进行线程间通信  388 11.2.7 内部可变性探究  397 11.2.8 线程池  399 11.2.9 使用Rayon 执行并行任务  407 11.2.10 使用Crossbeam  409 11.3 异步并发  412 11.3.1 生成器  413 11.3.2 Future 并发模式  418 11.3.3 async/await  421 11.4 数据并行  428 11.4.1 什么是SIMD  429 11.4.2 在Rust 中使用SIMD  430 11.5 小结  434 第12 章 元编程  435 12.1 反射  436 12.1.1 通过is 函数判断类型  436 12.1.2 转换到具体类型  437 12.1.3 非静态生命周期类型  439 12.2 宏系统  440 12.2.1 起源  440 12.2.2 Rust 中宏的种类  441 12.2.3 编译过程  442 12.2.4 声明宏  445 12.2.5 过程宏  458 12.3 编译器插件  472 12.4 小结  475 第13 章 超越安全的边界  477 13.1 Unsafe Rust 介绍  477 13.1.1 Unsafe 语法  478 13.1.2 访问和修改可变静态变量  480 13.1.3 Union 联合体  480 13.1.4 解引用原生指针  483 13.2 基于Unsafe 进行安全抽象  484 13.2.1 原生指针  484 13.2.2 子类型与型变  489 13.2.3 未绑定生命周期  494 13.2.4 Drop 检查  495 13.2.5 NonNull指针  505 13.2.6 Unsafe 与恐慌安全  508 13.2.7 堆内存分配  508 13.2.8 混合代码内存安全架构三大原则  510 13.3 和其他语言交互  510 13.3.1 外部函数接口  510 13.3.2 与C/C++语言交互  514 13.3.3 使用Rust 提升动态语言性能  528 13.4 Rust 与WebAssembly  532 13.4.1 WebAssembly 要点介绍  533 13.4.2 使用Rust 开发WebAssembly  539 13.4.3 打造WebAssembly 开发生态  541 13.5 小结  543 附录A Rust 开发环境指南  544 附录B Rust 如何调试代码  549
