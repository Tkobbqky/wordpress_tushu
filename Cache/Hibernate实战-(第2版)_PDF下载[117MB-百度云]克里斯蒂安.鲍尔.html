Hibernate实战-(第2版) PDF下载 克里斯蒂安.鲍尔 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730244808
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730244808
<p>书名:Hibernate实战-(第2版)</p><p>作者:克里斯蒂安.鲍尔</p><p>页数:532</p><p>定价:¥88.0</p><p>出版社:清华大学出版社</p><p>出版日期:2016-09-01</p><p>ISBN:9787302448082</p><p><h2>本书特色</h2></p>[<p>
持久化——数据在程序实例之外留存的功能——是现代应用程序的核心。Hibernate是*流行的Java持久化工具，提供了自动且透明的对象/关系映射，使得在Java应用程序中使用SQL数据库变得轻而易举。《Hibernate实战(第2版)》通过开发一个将数百个单独示例联系起来的应用程序来探究Hibernate。你将直接深入到Hibernate的富编程模型之中，贯穿映射、查询、抓取策略、事务、会话、缓存以及更多其他内容。书中图文并茂地介绍了数据库设计和优化技术的*佳实践。在本书中，作者详尽介绍了具有Java持久化2.1标准的Hibernate 5(JSR 338)。所有的示例都已经被更新，以便用于*新的Hibernate和Java EE规范版本。
主要内容
◆ 对象/关系映射概念
◆ 有效的数据库应用程序设计
◆ 全面的Hibernate与Java持久化介绍
◆ Java持久化与EJB、CDI、JSF和JAX-RS的集成
◆ 无与伦比的广度和深度
本书假设读者具有Java的使用经验。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书分为五个主要部分。在第Ⅰ部分“ORM入门”中，我们将探讨对象/关系映射背后的基础。第Ⅱ部分“映射策略”专注于Java类及其属性，以及它们如何映射到SQL表和列。第Ⅲ部分“事务性数据处理”完全与使用Hibernate和Java持久化加载与存储数据有关。第Ⅳ部分“编写查询”将介绍数据查询功能，并详尽讲解查询语言和API。第Ⅴ部分“构建应用程序”将探讨分层和有会话意识的Java数据库应用程序的设计与实现。 </p>]<p><h2>作者简介</h2></p>[<p>作者简介　　Christian Bauer是Hibernate开发团队的成员，并且是一位培训师和顾问。Gavin King是Hibernate之父，也是Java持久化专家组(JSR 220)的成员。Gary Gregory是应用程序服务器和既有系统集成的首席软件工程师。</p>]<p><h2>目录</h2></p>
    第Ⅰ部分  ORM入门     第1章  理解对象/关系持久化 1    1.1  持久化的定义 4    1.1.1  关系型数据库 4    1.1.2  理解SQL 5    1.1.3  在Java中使用SQL 5    1.2  范式不匹配 7    1.2.1  粒度问题 8    1.2.2  子类型问题 10    1.2.3  标识问题 11    1.2.4  与关联相关的问题 12    1.2.5  数据导航的问题 13    1.3  ORM和JPA 14    1.4  本章小结 15第Ⅰ部分  ORM入门 第1章  理解对象/关系持久化 11.1  持久化的定义 41.1.1  关系型数据库 41.1.2  理解SQL 51.1.3  在Java中使用SQL 51.2  范式不匹配 71.2.1  粒度问题 81.2.2  子类型问题 101.2.3  标识问题 111.2.4  与关联相关的问题 121.2.5  数据导航的问题 131.3  ORM和JPA 141.4  本章小结 15第2章  开启一个项目 172.1  Hibernate介绍 172.2  使用JPA的“Hello World” 182.2.1  配置一个持久化单元 182.2.2  编写一个持久化类 202.2.3  存储和加载消息 212.3  原生Hibernate配置 232.4  本章小结 26第3章  域模型和元数据 273.1  CaveatEmptor示例应用程序 283.1.1  一个分层架构 283.1.2  分析业务域 293.1.3  CaveatEmptor域模型 303.2  实现域模型 313.2.1  处理关注点渗漏 313.2.2  透明及自动持久化 323.2.3  编写可持久化类 333.2.4  实现POJO关联 363.3  域模型元数据 393.3.1  基于注解的元数据 403.3.2  应用Bean验证规则 423.3.3  使用XML文件外部化元数据 453.3.4  在运行时访问元数据 483.4  本章小结 51第Ⅱ部分  映射策略第4章  映射持久化类 554.1  理解实体和值类型 554.1.1  细粒度域模型 554.1.2  定义应用程序概念 564.1.3  区分实体和值类型 574.2  映射具有标识的实体 584.2.1  理解Java标识和相等性 584.2.2  **个实体类和映射 594.2.3  选择一个主键 604.2.4  配置键生成器 614.2.5  标识符生成器策略 634.3  实体映射选项 664.3.1  控制名称 664.3.2  动态SQL生成 694.3.3  让实体不可变 694.3.4  将一个实体映射到子查询 704.4  本章小结 71第5章  映射值类型 735.1  映射基本属性 735.1.1  重写基本属性的默认设置 745.1.2  自定义属性访问 755.1.3  使用派生属性 775.1.4  转换列值 775.1.5  生成的以及默认的属性值 785.1.6  时序属性 795.1.7  映射枚举 805.2  映射可嵌入组件 805.2.1  数据库架构 815.2.2  让类可嵌入 815.2.3  重写嵌入属性 845.2.4  映射嵌套的可嵌入组件 855.3  使用转换器映射Java和SQL类型 875.3.1  内置类型 875.3.2  创建自定义JPA转换器 925.3.3  使用UserTypes扩展Hibernate985.4  本章小结 104第6章  映射继承关系 1056.1  每个带有隐式多态的具体类使用一个表 1056.2  每个带有联合的具体类使用一个表 1076.3  每个类层次结构使用一个表 1096.4  每个带有联结的子类使用一个表 1126.5  混合继承策略 1156.6  可嵌入类的继承 1176.7  选择一种策略 1196.8  多态关联 1206.8.1  多态多对一关联 1216.8.2  多态集合 1236.9  本章小结 124第7章  映射集合和实体关联 1257.1  集、包、列表及值类型映射 1257.1.1  数据库架构 1267.1.2  创建和映射一个集合属性 1267.1.3  选择集合接口 1277.1.4  映射集 1287.1.5  映射标识符包 1297.1.6  映射列表 1307.1.7  映射一个映射 1327.1.8  排列和排序集合 1327.2  组件集合 1357.2.1  组件实例的相等性 1367.2.2  组件集 1387.2.3  组件包 1397.2.4  组件值的映射 1417.2.5  作为映射键的组件 1427.2.6  可嵌入组件中的集合 1437.3  映射实体关联 1447.3.1  *简单的可能关联 1457.3.2  让其变成双向的 1467.3.3  级联状态 1477.4  本章小结 153第8章  高级实体关联映射 1558.1  一对一关联 1558.1.1  共享主键 1568.1.2  外主键生成器 1588.1.3  使用一个外键联结列 1618.1.4  使用一个联结表 1628.2  一对多关联 1648.2.1  考虑一对多包 1648.2.2  单向和双向列表映射 1668.2.3  具有联结表的可选一对多 1688.2.4  可嵌入类中的一对多关联 1698.3  多对多和三元关联 1718.3.1  单向和双向多对多关联 1728.3.2  具有中间实体的多对多关联 1738.3.3  具有组件的三元关联 1778.4  具有映射的实体关联 1808.4.1  具有属性键的一对多关联 1808.4.2  键/值三元关系 1818.5  本章小结 182第9章  复杂和遗留模式 1859.1  改进数据库架构 1869.1.1  添加辅助数据库对象 1869.1.2  SQL约束 1899.1.3  创建索引 1949.2  处理遗留键 1959.2.1  映射一个自然主键 1959.2.2  映射一个组合主键 1969.2.3  组合主键中的外键 1989.2.4  引用组合主键的外键 2019.2.5  引用非主键的外键 2029.3  将属性映射到辅助表 2039.4  本章小结 204第Ⅲ部分  事务性数据处理第10章  管理数据 20710.1  持久化生命周期 20710.1.1  实体实例状态 20810.1.2  持久化上下文 20910.2  EntityManager接口 21110.2.1  规范的工作单元 21110.2.2  使数据持久化 21210.2.3  检索和修改持久化数据 21310.2.4  得到一个引用 21510.2.5  让数据变成瞬时的 21610.2.6  刷新数据 21710.2.7  复制数据 21710.2.8  在持久化上下文中缓存 21810.2.9  刷新持久化上下文 22010.3  处理分离的状态 22110.3.1  分离实例的标识 22110.3.2  实现相等性方法 22310.3.3  分离实体实例 22510.3.4  合并实体实例 22610.4  本章小结 227第11章  事务和并发 22911.1  事务的要素 22911.1.1  ACID属性 23011.1.2  数据库和系统事务 23011.1.3  使用JTA的编程式事务 23011.1.4  处理异常 23211.1.5  声明式事务分界 23411.2  控制并发访问 23411.2.1  理解数据库级别的并发 23511.2.2  乐观并发控制 23911.2.3  显式悲观锁 24511.2.4  避免死锁 24811.3  非事务性数据访问 24911.3.1  在自动提交模式中读取数据 25011.3.2  对修改进行排队 25111.4  本章小结 253第12章  抓取计划、策略和配置文件 25512.1  延迟加载和急加载 25612.1.1  理解实体代理 25612.1.2  延迟持久化集合 26012.1.3  使用拦截进行延迟加载 26212.1.4  关联和集合的急加载 26412.2  选择一个抓取策略 26612.2.1  n 1查询问题 26612.2.2  笛卡尔积问题 26712.2.3  批量预抓取数据 27012.2.4  使用子查询预抓取集合 27212.2.5  使用多个SELECT进行急抓取 27312.2.6  动态急抓取 27412.3  使用抓取配置文件 27512.3.1  声明Hibernate抓取配置文件 27612.3.2  使用实体图 27712.4  本章小结 281第13章  数据过滤 28313.1  级联状态迁移 28413.1.1  可用的级联选项 28413.1.2  传递式分离与合并 28513.1.3  级联刷新 28713.1.4  级联复制 28913.1.5  启用全局传递式持久化 29013.2  侦听和拦截事件 29013.2.1  JPA事件侦听器和回调 29113.2.2  实现Hibernate拦截器 29413.2.3  核心事件系统 29813.3  使用Hibernate Envers进行审计和版本控制 29913.3.1  启用审计日志 30013.3.2  创建审计追踪 30113.3.3  找出版本 30113.3.4  访问历史数据 30313.4  动态数据过滤器 30513.4.1  定义动态过滤器 30613.4.2  应用过滤器 30613.4.3  启用过滤器 30713.4.4  过滤集合访问 30813.5  本章小结 309第IV部分  编写查询第14章  创建和执行查询 31314.1  创建查询 31414.1.1  JPA查询接口 31414.1.2  类型化查询结果 31614.1.3  Hibernate的查询接口 31614.2  准备查询 31814.2.1  防止SQL注入攻击 31814.2.2  绑定命名参数 31814.2.3  使用定位参数 32014.2.4  对大结果集分页 32014.3  执行查询 32214.3.1  列示所有结果 32214.3.2  得到单个结果 32214.3.3  滚动数据库游标 32314.3.4  遍历一个结果 32514.4  命名和外部化查询 32614.4.1  调用一个命名查询 32614.4.2  在XML元数据中定义查询 32614.4.3  使用注解定义查询 32714.4.4  编程式定义命名查询 32814.5  查询提示 32914.5.1  设置一个超时时长 33014.5.2  设置刷新模式 33014.5.3  设置只读模式 33114.5.4  设置一个抓取大小 33114.5.5  设置一个SQL注释 33114.5.6  命名的查询提示 33214.6  本章小结 333第15章  查询语言 33515.1  选择 33615.1.1  指定别名和查询根 33615.1.2  多态查询 33715.2  限制 33815.2.1  比较表达式 33915.2.2  使用集合的表达式 34415.2.3  调用函数 34515.2.4  对查询结果排序 34715.3  投影 34815.3.1  实体和标量值的投影 34815.3.2  使用动态实例化 35015.3.3  得到唯一结果 35115.3.4  在投影中调用函数 35215.3.5  聚合函数 35415.3.6  分组 35515.4  联结 35715.4.1  使用SQL进行联结 35715.4.2  JPA中的联结选项 35915.4.3  隐式关联联结 35915.4.4  显式联结 36115.4.5  使用联结进行动态抓取 36315.4.6  theta风格的联结 36615.4.7  比较标识符 36715.5  子查询 36915.5.1  相关与不相关的嵌套 36915.5.2  量化 37015.6  本章小结 371第16章  高级查询选项 37316.1  转换查询结果 37316.1.1  返回一系列列表 37416.1.2  返回一系列映射 37516.1.3  将别名映射到bean属性 37616.1.4  编写一个ResultTransformer37616.2  过滤集合 37716.3  Hibernate条件查询API 38016.3.1  选择和排序 38016.3.2  限制 38116.3.3  投影和聚合 38216.3.4  联结 38316.3.5  子查询 38516.3.6  示例查询 38516.4  本章小结 387第17章  自定义SQL 38917.1  回退到JDBC 39017.2  映射SQL查询结果 39117.2.1  使用SQL查询进行投影 39217.2.2  映射到一个实体类 39317.2.3  自定义结果映射 39517.2.4  外部化原生查询 40617.3  自定义CRUD操作 41017.3.1  启用自定义加载器 41017.3.2  自定义创建、更新和删除 41117.3.3  自定义集合操作 41217.3.4  在自定义加载器中急抓取 41417.4  调用存储过程 41717.4.1  返回一个结果集 41817.4.2  返回多个结果以及更新计数 41917.4.3  设置输入和输出参数 42117.4.4  返回一个游标 42317.5  将存储过程用于CRUD 42517.5.1  自定义一个具有过程的加载器 42517.5.2  用于CUD的过程 42617.6  本章小结 428第V部分  构建应用程序第18章  设计客户端/服务器应用程序 43118.1  创建持久化层 43218.1.1  一种通用的数据访问对象模式 43318.1.2  实现通用接口 43418.1.3  实现实体DAO 43618.1.4  测试持久化层 43818.2  构建一个无状态服务器 43918.2.1  编辑一个拍卖商品 44018.2.2  放置出价 44218.2.3  分析无状态应用程序 44618.3  构建一个状态服务器 44718.3.1  编辑一个拍卖商品 44818.3.2  分析状态性应用程序 45218.4  本章小结 454第19章  构建Web应用程序 45519.1  集成JPA与CDI 45519.1.1 生成一个EntityManager 45619.1.2  将EntityManager与事务联结起来45719.1.3  注入一个EntityManager 45819.2 数据的分页和排序 45919.2.1 偏移量分页与搜寻分页对比 45919.2.2 在持久化层中分页 46119.2.3 逐页查询 46619.3  构建JSF应用程序 46819.3.1  请求作用域服务 46819.3.2  会话作用域服务 47119.4  序列化域模型数据 47819.4.1  编写一个JAX-RS服务 47919.4.2  应用JAXB映射 48019.4.3  序列化Hibernate代理 48219.5  本章小结 485第20章  扩展Hibernate 48720.1  大量和批量处理 48720.1.1  JPQL和条件中的大批量语句 48820.1.2  SQL中的大批量语句 49220.1.3  批处理 49320.1.4  Hibernate StatelessSession接口49620.2  缓存数据 49820.2.1  Hibernate共享的缓存架构 49820.2.2  配置共享缓存 50220.2.3  启用实体和集合缓存 50320.2.4  测试共享缓存 50620.2.5  设置缓存模式 50820.2.6  控制共享缓存 50920.2.7  查询结果缓存 51020.3  本章小结 512  信息
