.NET开发经典名著C#高级编程第11版 C# 7 & .NET CORE 2.0 PDF下载 [美]克里斯琴·内格尔（Christia 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730252256
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730252256
<p>书名:.NET开发经典名著C#高级编程第11版 C# 7 & .NET CORE 2.0</p><p>作者:[美]克里斯琴·内格尔（Christia</p><p>页数:0</p><p>定价:¥198.0</p><p>出版社:清华大学出版社</p><p>出版日期:2018-09-01</p><p>ISBN:9787302522560</p><p><h2>本书特色</h2></p>[<p>
★为需要新工具的高级开发人员介绍了C# 7和.NET Core 2.0的扩展新特性
★揭示了Visual Studio 2017的新技巧和切合实际的提示，包括新的用户界面、新增的模板、编辑器的改进等
★论述了计划工作流的全新方式，使编码更快，诊断和调试更精确，测试更频繁，发布更自信
★为开发在Android、iOS、Windows、Linux、网络和云上运行的应用程序提供了循序渐进的指南
★掌握Visual Studio的高效率特性，以加速AI革新
                                        </p>]<p><h2>内容简介</h2></p>[<p>★为需要新工具的不错开发人员介绍了C# 7和.NET Core 2.0的扩展新特性
★揭示了Visual Studio 2017的新技巧和切合实际的提示，包括新的用户界面、新增的模板、编辑器的改进等
★论述了计划工作流的全新方式，使编码更快，诊断和调试更准确，测试更频繁，发布更自信
★为开发在Android、iOS、Windows、Linux、网络和云上运行的应用程序提供了循序渐进的指南
★掌握Visual Studio的高效率特性，以加速AI革新</p>]<p><h2>作者简介</h2></p>[<p>Christian Nagel 是Visual Studio 和开发技术方向的Microsoft MVP，担任微软开<br/>发技术代言人(Microsoft Regional Director)已经超过15 年。Christian 是CN innovation<br/>公司的创始人，CN innovation 公司提供指导、培训、代码评审，并协助使用微软技术<br/>设计和开发解决方案。他拥有超过25 年的软件开发经验。<br/>Christian Nagel 最初在Digital Equipment 公司通过PDP 11 和VAX / VMS 系统开<br/>始他的计算机职业生涯，接触过各种语言和平台。在2000 年，.NET 只有一个技术<br/>概览版时，他就开始使用各种技术建立.NET 解决方案。目前，他主要指导人们开发和<br/>设计Windows 应用程序、ASP.NET Core Web 应用程序和Xamarin，并帮助他们使用<br/>Microsoft Azure 服务产品。Christian Nagel 是Visual Studio 和开发技术方向的Microsoft MVP，担任微软开<br/>发技术代言人(Microsoft Regional Director)已经超过15 年。Christian 是CN innovation<br/>公司的创始人，CN innovation 公司提供指导、培训、代码评审，并协助使用微软技术<br/>设计和开发解决方案。他拥有超过25 年的软件开发经验。<br/>Christian Nagel 最初在Digital Equipment 公司通过PDP 11 和VAX / VMS 系统开<br/>始他的计算机职业生涯，接触过各种语言和平台。在2000 年，.NET 只有一个技术<br/>概览版时，他就开始使用各种技术建立.NET 解决方案。目前，他主要指导人们开发和<br/>设计Windows 应用程序、ASP.NET Core Web 应用程序和Xamarin，并帮助他们使用<br/>Microsoft Azure 服务产品。<br/>在软件开发领域工作多年以后，Christian 仍然热爱学习和使用新技术，并通过多种形式教别人如何使用新<br/>技术。他的Microsoft 技术知识非常渊博，编写了很多书，拥有微软认证培训师(MCT)和微软认证解决方案开发<br/>专家(MCSD)认证。Christian 经常在国际会议(如Microsoft Ignite、BASTA！和TechDays)上发言。</p>]<p><h2>目录</h2></p>
    目 录第 I 部分 C# 语 言第1 章 .NET 应用程序和工具   31.1 选择技术   31.2 回顾.NET 历史   41.2.1 C# 1.0——一种新语言  41.2.2 带有泛型的C# 2 和.NET 2  61.2.3 .NET 3.0——Windows Presentation Foundation   61.2.4 C# 3 和.NET 3.5——LINQ   61.2.5 C# 4 和.NET 4.0——dynamic 和TPL   71.2.6 C# 5 和异步编程   71.2.7 C# 6 和.NET Core 1.0   81.2.8 C# 7 和.NET Core 2.0    81.2.9 选择技术，继续前进    91.3 .NET 术语    101.3.1 .NET Framework      111.3.2 .NET Core      111.3.3 .NET Standard    111.3.4 NuGet 包   121.3.5 名称空间   121.3.6 公共语言运行库   131.3.7 Windows 运行库   131.4 用.NET Core CLI 编译  141.4.1 设置环境   141.4.2 创建应用程序   151.4.3 构建应用程序   161.4.4 运行应用程序   161.4.5 创建Web 应用程序   171.4.6 发布应用程序   171.5 使用Visual Studio 2017   191.6 应用程序类型和技术   241.6.1 数据访问   241.6.2 Windows 应用程序   241.6.3 Xamarin    241.6.4 Web 应用程序    251.6.5 Web API     251.6.6 WebHooks 和SignalR   251.6.7 Microsoft Azure     251.7 开发工具    261.7.1 Visual Studio Community   271.7.2 Visual Studio Professional   271.7.3 Visual Studio Enterprise   271.7.4 Visual Studio for Mac   271.7.5 Visual Studio Code   271.8 小结    27第2 章 核心C#   292.1 C#基础     292.2 变量    312.2.1 初始化变量    312.2.2 类型推断    322.2.3 变量的作用域    332.2.4 常量    342.3 预定义数据类型     352.3.1 值类型和引用类型    352.3.2 .NET 类型     362.3.3 预定义的值类型    362.3.4 预定义的引用类型   402.4 程序流控制    422.4.1 条件语句    422.4.2 循环    442.4.3 跳转语句    472.5 名称空间    472.5.1 using 语句    482.5.2 名称空间的别名    492.6 Main()方法    492.7 使用注释    502.7.1 源文件中的内部注释   502.7.2 XML 文档     512.8 C#预处理器指令    522.8.1 #define 和#undef    522.8.2 #if、#elif、#else 和#endif    522.8.3 #warning 和 # error    532.8.4 #region 和#endregion   532.8.5 #line     532.8.6 #pragma     542.9 C#编程准则    542.9.1 关于标识符的规则    542.9.2 用法约定    552.10 小结       58第3 章 对象和类型   593.1 创建及使用类     603.2 类和结构    603.3 类    613.3.1 字段    613.3.2 只读字段    613.3.3 属性    623.3.4 匿名类型    653.3.5 方法    663.3.6 构造函数    693.4 结构    733.4.1 结构是值类型     743.4.2 只读结构    753.4.3 结构和继承    753.4.4 结构的构造函数    753.4.5 ref 结构     763.5 按值和按引用传递参数   763.5.1 ref 参数     773.5.2 out 参数    773.5.3 in 参数    783.6 可空类型    793.7 枚举类型    793.8 部分类     813.9 扩展方法    833.10 Object 类    833.11 小结    84第4 章 继承   854.1 面向对象    854.2 继承的类型    854.2.1 多重继承    864.2.2 结构和类    864.3 实现继承    864.3.1 虚方法    874.3.2 多态性    884.3.3 隐藏方法    894.3.4 调用方法的基类版本    904.3.5 抽象类和抽象方法   904.3.6 密封类和密封方法   914.3.7 派生类的构造函数   914.4 修饰符      934.4.1 访问修饰符     934.4.2 其他修饰符     944.5 接口    944.5.1 定义和实现接口     954.5.2 派生的接口     974.6 is 和as 运算符    984.7 小结    99第5 章 泛型    1005.1 泛型概述     1005.1.1 性能    1015.1.2 类型安全    1025.1.3 二进制代码的重用    1025.1.4 代码的扩展    1025.1.5 命名约定    1025.2 创建泛型类    1035.3 泛型类的功能    1055.3.1 默认值    1065.3.2 约束    1065.3.3 继承    1085.3.4 静态成员    1085.4 泛型接口     1095.4.1 协变和抗变    1095.4.2 泛型接口的协变   1105.4.3 泛型接口的抗变   1115.5 泛型结构   1115.6 泛型方法   1135.6.1 泛型方法示例   1135.6.2 带约束的泛型方法    1145.6.3 带委托的泛型方法    1155.6.4 泛型方法规范       1155.7 小结    116第6 章 运算符和类型强制转换   1176.1 运算符和类型转换    1176.2 运算符   1186.2.1 运算符的简化操作      1196.2.2 运算符的优先级和关联性     1256.3 使用二进制运算符        1266.3.1 位的移动            1286.3.2 有符号数和无符号数    1286.4 类型的安全性       1296.4.1 类型转换           1306.4.2 装箱和拆箱         1326.5 比较对象的相等性    1336.5.1 比较引用类型的相等性   1336.5.2 比较值类型的相等性     1346.6 运算符重载        1356.6.1 运算符的工作方式       1356.6.2 运算符重载的示例：Vector 结构     1366.6.3 比较运算符的重载       1396.6.4 可以重载的运算符       1406.7 实现自定义的索引运算符     1416.8 用户定义的类型强制转换     1426.8.1 实现用户定义的类型强制转换     1436.8.2 多重类型强制转换       1476.9 小结       150第7 章 数组     1517.1 相同类型的多个对象    1517.2 简单数组   1527.2.1 数组的声明   1527.2.2 数组的初始化   1527.2.3 访问数组元素   1537.2.4 使用引用类型   1537.3 多维数组   1547.4 锯齿数组   1557.5 Array 类   1567.5.1 创建数组   1567.5.2 复制数组   1567.5.3 排序      1577.6 数组作为参数   1597.7 数组协变   1597.8 枚举   1607.8.1 IEnumerator 接口     1607.8.2 foreach 语句     1607.8.3 yield 语句   1617.9 结构比较   1647.10 Span      1657.10.1 创建切片   1667.10.2 使用Span 改变值    1667.10.3 只读的Span    1677.11 数组池     1677.11.1 创建数组池     1687.11.2 从池中租用内存    1687.11.3 将内存返回给池    1687.12 小结       169第8 章 委托、lambda 表达式和事件    1708.1 引用方法        1708.2 委托    1708.2.1 声明委托    1718.2.2 使用委托    1728.2.3 简单的委托示例    1748.2.4 Action和Func委托     1758.2.5 BubbleSorter 示例      1768.2.6 多播委托    1778.2.7 匿名方法    1808.3 lambda 表达式    1818.3.1 参数      1818.3.2 多行代码    1818.3.3 闭包     1828.4 事件     1828.4.1 事件发布程序    1828.4.2 事件侦听器    1848.5 小结    185第9 章 字符串和正则表达式 1869.1 System.String 类    1879.1.1 构建字符串    1889.1.2 StringBuilder 成员   1909.2 字符串格式       1909.2.1 字符串插值        1919.2.2 日期时间和数字的格式    1929.2.3 自定义字符串格式     1939.3 正则表达式      1949.3.1 正则表达式概述    1949.3.2 RegularExpressionsPlayground 示例    1959.3.3 显示结果    1979.3.4 匹配、组和捕获    1989.4 字符串和Span    2009.5 小结    201第10 章 集合     20210.1 概述     20210.2 集合接口和类型    20310.3 列表     20310.3.1 创建列表    20410.3.2 只读集合    21010.4 队列     21010.5 栈    21310.6 链表     21410.7 有序列表    21710.8 字典     21910.8.1 字典初始化器   21910.8.2 键的类型    21910.8.3 字典示例    22010.8.4 Lookup 类    22310.8.5 有序字典    22310.9 集    22410.10 性能    22510.11 小结    227第11 章 特殊的集合   22811.1 概述     22811.2 处理位    22811.2.1 BitArray 类    22911.2.2 BitVector32 结构   23011.3 可观察的集合     23211.4 不变的集合     23311.4.1 使用构建器和不变的集合    23511.4.2 不变集合类型和接口      23511.4.3 使用LINQ 和不变的数组   23611.5 并发集合    23611.5.1 创建管道    23711.5.2 使用BlockingCollection   23911.5.3 使用ConcurrentDictionary   24011.5.4 完成管道    24111.6 小结     242第12 章 LINQ   24312.1 LINQ 概述    24312.1.1 列表和实体    24412.1.2 LINQ 查询    24612.1.3 扩展方法    24612.1.4 推迟查询的执行    24812.2 标准的查询操作符 24912.2.1 筛选    25012.2.2 用索引筛选    25112.2.3 类型筛选    25212.2.4 复合的from 子句   25212.2.5 排序    25312.2.6 分组    25412.2.7 LINQ 查询中的变量     25512.2.8 对嵌套的对象分组      25512.2.9 内连接      25612.2.10 左外连接     25812.2.11 组连接      26012.2.12 集合操作     26212.2.13 合并     26312.2.14 分区     26412.2.15 聚合操作符    26412.2.16 转换操作符    26612.2.17 生成操作符    26712.3 并行LINQ     26712.3.1 并行查询    26812.3.2 分区器    26812.3.3 取消    26912.4 表达式树    26912.5 LINQ 提供程序     27112.6 小结     272第13 章 C#函数式编程   27313.1 概述     27313.1.1 避免状态突变     27413.1.2 函数作为**个类     27513.2 表达式体的成员    27513.3 扩展方法    27613.4 using static 声明     27713.5 本地函数    27813.5.1 本地函数与yield 语句    27913.5.2 递归本地函数     28113.6 元组      28213.6.1 元组的声明和初始化    28213.6.2 元组解构    28313.6.3 元组的返回    28313.6.4 幕后的原理    28413.6.5 ValueTuple 与元组的兼容性    28513.6.6 推断出元组名称     28513.6.7 元组与链表    28613.6.8 元组和LINQ    28613.6.9 解构    28713.6.10 解构与扩展方法    28813.7 模式匹配        28813.7.1 模式匹配与is 运算符    28813.7.2 模式匹配与switch 语句   29013.7.3 模式匹配与泛型      29113.8 小结    291第14 章 错误和异常     29214.1 简介    29214.2 异常类   29314.3 捕获异常   29414.3.1 异常和性能   29614.3.2 实现多个catch 块    29614.3.3 在其他代码中捕获异常    29914.3.4 System.Exception 属性    29914.3.5 异常过滤器        29914.3.6 重新抛出异常       30014.3.7 没有处理异常时发生的情况     30314.4 用户定义的异常类     30314.4.1 捕获用户定义的异常      30414.4.2 抛出用户定义的异常      30514.4.3 定义用户定义的异常类    30714.5 调用者信息        30914.6 小结    310第15 章 异步编程      31115.1 异步编程的重要性   31115.2 异步编程的.NET 历史    31215.2.1 同步调用      31215.2.2 异步模式      31315.2.3 基于事件的异步模式     31415.2.4 基于任务的异步模式     31415.2.5 异步Main()方法     31515.3 异步编程的基础   31515.3.1 创建任务   31615.3.2 调用异步方法     31615.3.3 使用Awaiter      31715.3.4 延续任务   31715.3.5 同步上下文   31815.3.6 使用多个异步方法    31815.3.7 使用ValueTasks     31915.3.8 转换异步模式      32015.4 错误处理       32015.4.1 异步方法的异常处理     32115.4.2 多个异步方法的异常处理    32115.4.3 使用AggregateException 信息   32215.5 异步与Windows 应用程序   32215.5.1 配置await     32315.5.2 切换到UI 线程     32415.5.3 使用IAsyncOperation   32515.5.4 避免阻塞情况      32515.6 小结       325
