SPA设计与架构-理解单页面Web应用 PDF下载 埃米顿.A斯科特 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712130091
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712130091
<p>书名:SPA设计与架构-理解单页面Web应用</p><p>作者:埃米顿.A斯科特</p><p>页数:304</p><p>定价:¥79.0</p><p>出版社:电子工业出版社</p><p>出版日期:2016-11-01</p><p>ISBN:9787121300912</p><p><h2>本书特色</h2></p>[<p>
单页的Web应用程序（SPA）是网络软件发展的下一阶段，SPA能够使浏览器应用像原生桌面应用一样流畅易用。 开发SPA需要新的开发理念，并掌握那些支持更复杂应用的新技术。幸运的是，学习如何创建SPA并不需要十分丰富的经验！本书能够帮助开发者从传统的网页应用开发过渡到SPA的开发。本书首先介绍了SPA模式，及建立创建链接页面的标准方法。然后简单介绍了模块化JavaScript编程，包括AMD和模块加载器。本书将指导读者学习SPA架构的各个方面，包括MV*框架、单元测试、路由、布局管理、数据访问、发布/订阅、性能和安全性。配套的示例很容易上手，且可被应用于读者自己的库或框架中。
                                        </p>]<p><h2>内容简介</h2></p>[<p>Web应用发展的下一个热点是单页面Web应用程序，其将原生桌面应用的流畅体验带到了浏览器。如果你打算从传统Web应用跨越到SPA却又无从下手，那么这本书正是为你准备的。本书讲述SPA应用程序构建所需的设计与开发技术。书中首先介绍SPA模型，并阐述SPA标准构建方式。随着内容的展开，作者通过具体的SPA构建知识点引导你前进，涵盖MV*框架、单元测试、路由、布局管理、数据访问、发布/订阅模式以及客户端任务自动化等内容。书中示例丰富易懂，并可结合各种第三方库或框架来创建。内容包括：<br/>√ 模块化JavaScript实践<br/>√ 理解MV*框架<br/>√ 布局管理<br/>√ 客户端任务自动化<br/>√ SPA应用程序测试<br/> </p>]<p><h2>作者简介</h2></p>[<p>Emmit A. Scott 是一名有17 年Web 应用构建经验的高级软件工程师和架构师。他为教育、银行和通信领域开发过大型应用程序。他的爱好包括阅读（特别喜欢Jim Butcher的小说）、吉他（想当年他可是一位摇滚乐手）以及尽可能多陪陪孩子。
译者简介<br/>卢俊祥<br/>译者，书迷；关注Web 技术趋势，热衷App 开发、Web 开发、数据分析、架构设计以及各类编程语言；陈氏太极拳五十六式爱好者；佛禅人生，缘散缘聚。<br/>微博：@2gua<br/>个人网站：http://www.2gua.info/<br/>知乎专栏：https://zhuanlan.zhihu.com/guagua/</p>]<p><h2>目录</h2></p>
    第1 部分 基础知识 11　单页面应用程序介绍 31.1 SPA 简述  41.1.1 无须刷新浏览器  71.1.2 表现逻辑位于客户端  71.1.3 服务器端事务处理  71.2 更进一步  81.2.1 以Shell 页面开始  81.2.2 从传统页面到视图  91.2.3 视图的产生  101.2.4 实现无刷新的视图切换  111.2.5 贯穿动态更新过程的流畅性  121.3 SPA 应用相较传统Web 应用的优势  121.4 温故知新  13第1 部分 基础知识 11　单页面应用程序介绍 31.1 SPA 简述  41.1.1 无须刷新浏览器  71.1.2 表现逻辑位于客户端  71.1.3 服务器端事务处理  71.2 更进一步  81.2.1 以Shell 页面开始  81.2.2 从传统页面到视图  91.2.3 视图的产生  101.2.4 实现无刷新的视图切换  111.2.5 贯穿动态更新过程的流畅性  121.3 SPA 应用相较传统Web 应用的优势  121.4 温故知新  131.5 优秀SPA 应用的构成  151.5.1 组织项目  151.5.2 创建可维护的松耦合UI  171.5.3 使用JavaScript 模块  181.5.4 执行SPA 导航  191.5.5 创建视图组成与布局  191.5.6 模块通信  201.5.7 与服务器端通信  201.5.8 执行单元测试  201.5.9 客户端自动化技术  201.6 小结  212　MV* 框架介绍 .222.1 MV* 概念  242.1.1 传统UI 设计模式  252.1.2 MV* 和浏览器环境  272.2 MV* 基础概念  282.2.1 框架  292.2.2 我们的MV* 项目  302.2.3 模型  322.2.4 绑定  362.2.5 模板  402.2.6 视图  442.3 为什么要用MV* 框架  442.3.1 关注分离 . 452.3.2 简化日常任务  462.3.3 提升生产率  472.3.4 标准化  472.3.5 可扩展性  482.4 框架选择  482.5 挑战环节  502.6 小结  503　JavaScript 模块化 523.1 模块概念  533.1.1 模块模式概念  533.1.2 模块结构  543.1.3 揭示模式  553.2 模块化编程的意义  563.2.1 避免命名冲突  563.2.2 保护代码完整性  653.2.3 隐藏复杂性  673.2.4 降低代码改变带来的冲击  683.2.5 代码组织  683.2.6 模块模式的不足  693.3 模块模式剖析  693.3.1 可访问性控制  693.3.2 创建公有API  703.3.3 允许全局导入  733.3.4 创建模块的命名空间  733.4 模块加载及依赖管理  743.4.1 脚本加载器  743.4.2 异步模块定义——AMD  753.4.3 通过RequireJS 实践AMD  763.5 挑战环节  813.6 小结  81第2 部分　核心概念 834　单页面导航 854.1 客户端路由器概念  864.1.1 传统导航  864.1.2 SPA 导航  864.2 路由及其配置 884.2.1 路由语法  904.2.2 路由配置项  904.2.3 路由参数  914.2.4 缺省路由  934.3 客户端路由器的工作机制  934.3.1 片段标识符方式  944.3.2 HTML5 历史API 方式  954.3.3 使用HTML5 历史API 方式  974.4 综合实作：实现SPA 路由  984.4.1 教员列表（缺省路由）  994.4.2 主要联系人路由 1014.4.3 教员授课时间（参数化路由） 1024.5 挑战环节  1044.6 小结  1055　视图合成与布局  1065.1 项目介绍 1075.2 布局设计概念  1085.2.1 视图  1085.2.2 Region  1095.2.3 视图合成  1105.2.4 嵌套视图 1115.2.5 路由  1125.3 高级合成与布局的可选方案  1135.3.1 优点  1135.3.2 缺点  1145.4 设计应用程序  1145.4.1 设计基本布局  1155.4.2 设计基本内容  1175.4.3 在复杂设计中应用视图管理  1225.4.4 通过自身状态创建嵌套视图  1255.5 挑战环节  1275.6 小结  1286　模块间交互  1296.1 模块概念回顾  1316.1.1 用模块封装代码  1316.1.2 API 提供对内部功能的访问控制  1336.1.3 SRP——以单一目的作为设计出发点  1346.1.4 代码重用——控制项目规模  1356.2 模块间交互方式  1366.2.1 通过依赖进行模块间交互  1366.2.2 依赖方式的优缺点  1386.2.3 通过发布/ 订阅模式进行模块间交互  1386.2.4 发布/ 订阅模式优缺点  1416.3 示例项目细节  1426.3.1 搜索功能 1446.3.2 显示产品信息  1506.4 挑战环节 .. 1556.5 小结 . 1557　与服务器端通信  1567.1 示例项目新要求  1577.2 与服务器端通信综述  1587.2.1 选择数据类型  1587.2.2 HTTP 请求方法  1597.2.3 数据转换  1607.3 使用MV* 框架  1617.3.1 请求生成 1627.3.2 通过回调函数处理结果  1657.3.3 通过Promise 处理结果  1667.3.4 Promise 错误处理  1707.4 RESTful Web 服务调用  1727.4.1 什么是REST  1727.4.2 REST 原则  1727.4.3 MV* 框架的RESTful 支持  1747.5 示例项目细节  1747.5.1 配置REST 调用1747.5.2 添加产品到购物车  1777.5.3 查看购物车  1797.5.4 修改购物车  1817.5.5 从购物车中移除产品  1837.6 挑战环节 1847.7 小结  1848　单元测试 1868.1 示例项目说明  1878.2 什么是单元测试  1878.2.1 单元测试的好处1888.2.2 构建更好的单元测试  1898.3 传统的单元测试  1928.3.1 QUnit 起步 1938.3.2 创建**个单元测试  1968.3.3 测试由MV* 对象创建的代码  2008.3.4 测试对DOM 所做的改变  2058.3.5 混合使用其他测试框架2068.4 挑战环节  2088.5 小结  2089　客户端任务自动化  2099.1 Task Runner 的常见用途  2109.1.1 即时刷新浏览器 2109.1.2 自动化JavaScript 和CSS 的预处理过程  2119.1.3 自动化Linter 代码分析  2119.1.4 持续单元测试  2119.1.5 文件串接  2129.1.6 代码压缩  2129.1.7 持续集成  2129.2 Task Runner 选择  2129.3 本章示例项目  2139.3.1 Gulp.js 介绍  2149.3.2 创建**个任务 2159.3.3 创建代码分析任务  2169.3.4 创建浏览器刷新任务  2189.3.5 自动化单元测试2209.3.6 创建构建过程  2229.4 挑战环节  2279.5 小结  227A　员工通讯录示例说明  229B　XMLHttpRequest API  259C　第7 章内容的服务器端设置与总结  266D　安装Node.js 与Gulp.js  277信息
