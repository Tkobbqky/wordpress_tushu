CLR via C-第3版 PDF下载 瑞奇特(JeffreyRichter) 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730223259
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730223259
<p>书名:CLR via C-第3版</p><p>作者:瑞奇特(Jeffrey Richter)</p><p>页数:777页</p><p>定价:¥99.0</p><p>出版社:清华大学出版社</p><p>出版日期:2010-09-01</p><p>ISBN:9787302232599</p><p><h2>节选</h2></p>[<p>
  《CLR via C#(第3版)》针对CLR和.NET Framework 4.0进行深入、全面的探讨，并结合实例介绍了如何利用它们进行设计、开发和调试。《CLR via C#(第3版)》5部分29章。第Ⅰ部分介绍CLR基础，第Ⅱ部分解释如何设计类型，第Ⅲ部分介绍基本类型，第Ⅳ部分以实用特性为主题，第Ⅴ部分花大量篇幅重点介绍线程处理。</p>]<p><h2>相关资料</h2></p>[<p>
  插图：Microsoft的C#，Visual Basic，F#和IL汇编器总是生成包含托管代码（IL）和托管数据（垃圾收集的数据类型）的模块。为了执行包含托管代码以及／或者托管数据的模块，最终用户必须在自己的计算机上安装好CLR（目前作为.NET Framework的一部分提供）。这类似于为了运行MFC或者Visual Basic 6应用程序，用户必须安装Microsoft Foundation Class（MFC）库或者Visual Basic DLLs。Microsoft的C++编译器默认生成包含非托管（本地）代码的EXE／DLL模块，并在运行时操纵非托管数据（本地内存）。这些模块不需要CLR即可执行。然而，指定一个／CLR命令行开关，C++编译器就能生成包含托管代码的模块。当然，最终用户必须安装CLR才能执行这种代码。在前面提到的所有Microsoft编译器中，最特殊的就是C++编译器，因为只有它才允许开发人员同时写托管和非托管代码，并生成到同一个模块中。它也是唯一允许开发人员在源代码中同时定义托管和非托管数据类型的Microsoft编译器。Microsoft C++编译器的灵活性是其他编译器无法比拟的，因为它允许开发人员在托管代码中使用他们现有的本地C／C++代码，并在逐渐习惯之后开始使用托管类型。</p>]<p><h2>本书特色</h2></p>[<p>

  《CLR via C#(第3版)》深入、全面探讨.NET Framework、CLR和多核编程，广泛讨论Framework Class Library（FCL）核心类型，对泛型和线程处理等深奥难懂的开发概念提供权威、实用的指导自下而上，由浅入深掌握CLR和.NET的权威指南享有全球盛誉的编程专家Jeffrey Richter，这位与Microsoft.NET开发团队合作长达8年时间的资深顾问，在《CLR via C#(第3版)》中和读者分享他编程生涯中积累的所有丰富经验和心得，他的独到。睿智的见解，他的远见卓识，为开发人员构建健壮、可靠和具有良好响应能力的应用程序与组件奠定了良好的基础。《CLR via C#(第3版)》重要主题：构建、部署应用程序、组件和共享程序集，并对它们进行版本管理理解基元类型、值类型和引用类型的行为，从而*高效地定义和使用它们使用泛型和接口来定义可重用的算法高效使用特定的CLR类型——委托、枚举、定制attribute、数组和字符串理解垃圾回收器是如何管理内存资源的使用线程池、任务、取消、计时器和异步I／O操作来设计响应性强、稳定性高和伸缩性大的解决方案·借助于异常处理来进行状态管理·使用CLR寄宿AppDomain、程序集加载、反射和C＃的dynamic类型来构造具有动态扩展能力的应用程序。
                                        </p>]<p><h2>作者简介</h2></p>[<p>
  作者：（美国）瑞奇特（Jeffrey Richter） 译者：周靖瑞奇特，(Jeffrey,Richter) Wintellect公司的创始人之一.该公司从事培训、调试和咨询，致力于帮助其他公司以更快的速度开发出更优秀的软件。他著作颇丰.代表作有畅销书《windows核心编程》和《CLR via C#》。他还是MSDN Magazine的特约编辑和专栏作家。周靖，从1983年接触苹果机开始，“浸染”IT业数十年，涉猎广泛，具有深厚的技术功底和良好的文学素养早期痴迷于硬件，曾担任《微型计算机》杂志特约作者多年。继而潜心钻研编程，并乐在其中，积累了丰富的经验，其翻译风格严谨、准确、朴实、流畅，深受读者欢迎。代表译著有《c++面向对象程序设计》（walter Savitch著）、《windows核心编程》（Jeffrey Richter著）和《c++图形与游戏编程基础》（Tony Gaddis著）等，业余时间，听音乐和看电影是他的爱好。</p>]<p><h2>目录</h2></p>
    
  第I部分 CLR基础第1章 CLR的执行模型1.1 将源代码编译成托管模块1.2 将托管模块合并成程序集1.3 加载公共语言运行时1.4 执行程序集的代码1.4.1 IL和验证1.4.2 不安伞的代码1.5 本地代码生成器：NGen.exe1.6 Framework类库1.7 通用类型系统1.8 公共语言规范1.9 与非托管代码的互操作性第2章 生成、打包、部署和管理应用程序及类型2.1.NETFramework部署目标2.2 将类型生成到模块中响应文件2.3元数据概述2.4 将模块合并成程序集2.4.1 使用Visual Studio IDE将程序集添加到项目中.2.4 ：2使用程序集链接器2.4.3 为程序集添加资源文件2.5 程序集版本资源信息2.6 语言文化2.7 简单应用程序部署（私有部署的程序集）2.8 简单管理控制（配置）第3章 共享程序集和强命名程序集3.1 两种程序集，两种部署3.2 为程序集分配强名称3.3 全局程序集缓存3.4 在生成的程序集中引用一个强命名程序集3.5 强命名程序集能防范篡改3.6 延迟签名3.7 私有部署强命名程序集3.8 “运行时”如何解析类型引用3.9 高级管理控制（配置）发布者策略控制第II部分 设计类型第4章 类型基础.4.1 所有类型都从System Object派生4.2 类型转换4.3 命名空间和程序集4.4 运行时的相互联系第5章 基元类型、引用类型和值类型5.1 编程语言的基元类型5.2 引用类型和值类型5.3 值类型的装箱和拆箱5.3.1 使用接口更改已装箱值类型中的字段（以及为什么不应该这样做）5.3.2 对象相等性和同一性5.4 对象哈希码5.5 dynamic基元类型第6章 类型和成员基础6.1 类型的各种成员6.2 类型的可见性友元程序集6.3 成员的可访问性6.4 静态类6.5 分部类、结构和接口6.6 组件、多态和版木控制6.6.1 CLR如何调用虚方法、属十和事件6.6.2 合理使用类型的可见性和成员的可访问性6.6.3对类型进行版本控制时的虚方法的处理第7章 常量和字段7.1 常量7.2字段第8章 方法8.1 实例构造器和类（引用类型）8.2 实例构造器和结构（值类型）8.3 类型构造器8.4 操作符重载方法8.5 转换操作符方法8.6 扩展方法8.6.1 规则和原则8.6.2 用扩展方法扩展各种类型8.6.3 Extension Attribute类8.7 分部方法第9章参数9.1 可选参数和命名参数9.1.1 规则和原则9.1.2 DefaultParameterValueAttribute和OptionalAttribute9.2 隐式类型的局部变量9.3 传引用的方式向方法传递参数9.4 向方法传递可变数量的参数9.5 参数和返回类型的指导原则9.6 常量性第10章 属性10.1 无参属性10.1.1 自动实现的属性10.1.2 合理定义属性10.1.3 对象和集合初始化器10.1.4 匿名类型10.1.5 SystemTuple类型l0.2 有参属性10.3 调用属性访问器方法时的性能10.4 属性访问器的可访问性10.5 泛型属性访问器方法第11章 事件11.1 设计要公开事件的类型11.1.1 **步：定义类型来容纳所需要发送给事件通知接收名的附加信息11.1.2 第二步：定义事件成员11.1.3第三步：定义负责引发事件的方法来通知事件的登记对象11.1.4 第四步：定义方法将输入转化为期望事件11.2 编译器如何实现事件11.3 设计侦听事件的类型11.4 显式实现事件第12章 泛型12.1 Framework类库巾的泛型l2.2 Wintellect的PowerCollections库12.3泛型基础结构12.3.1 开放类型和封闭类型12.3.2 泛型类型和继承12.3.3泛型类型同一性12.3.4 代码爆炸12.4 泛型接口12.5 泛型委托12.6 委托和接口的逆变和协变泛型类型实参12.7 泛型方法12.8 泛型和其他成员12.9 可验证性和约束12.9.1 主要约束12.9.2 次要约束12.9 .3构造器约束12.9.4 其他可验证性问题第III部分 基本类型第13章接口13.1 类和接口继承13.2 定义接口13.3 继承接口13.4 关于调用接口方法的更多探讨13.5 隐式和显式接口方法实现（幕后发生的事情）13.6 泛型接口13.7 泛型和接口约束13.8 实现多个具有相同方法名和签名的接口13.9 用显式接口方法实现来增强编译时类型安全性13.10 谨慎使用显式接口方法实现13.11 设计：基类还是接口第14章 字符、字符串和文本处理14.1 字符14.2 System. String类型14.2.1 构造字符串14.2.2 字符串是不可变的14.2.3 比较字符串14.2.4 字符串留用14.2.5 字符串池14.2.6 检查字符串中的字符和文本元素14.2.7 其他字符串操作14.3高效率构造字符串14.3.1 构造String Builder对象14.3.2 StringBuilder的成员14.4 获取对象的字符串表示：ToString14.4.1 指定具体的格式和语言文化14.4 .2将多个对象格式成一个字符串14.4 .3提供定制格式化器14.5 解析字符串来获取对象：Parse14.6 编码：字符和字节的相互转换14.6.1 字符和字节流的编码和解码14.6.2 Base.6 4字符串编码和解码14.7 安全字符串第15章 枚举类型和位标志15.1 枚举类型15.2位标志15.3向枚举类型添加方法第16章 数组16.1 初始化数组元素16.2 数组转型16.3 所有数组都隐式派生自System Array16.4 所有数组都隐式实现。IEnumerablelcollection和IList16.5 数组的传递和返回16.6 创建下限非零的数组16.7 数组的访问性能16.8 不安伞的数组访问和固定大小的数组第17章 委托17.1 初识委托17.2用委托回调静态方法17.3用委托回调实例方法17.4 委托揭秘17.5 用委托回调许多方法（委托链）17.5.1 C舟对委托链的支持17.5 .2取得对委托链调用的更多控制17.6 委托定义太多（泛型委托）17.7 C#为委托提供的简化语法17.7.1 简化语法1：不需要构造委托对象17.7.2 简化语法2：不需要定义回调方法17.7 .3简化语法3：局部变量不需要手动包装到类中即可传给回调方法17.8 委托和反射第18章 定制attribute18.1 使用定制attribute18.2 定义自己的attribute类18.3 attribute的构造器和字段／属性的数据类型18.4 检测定制attribute18.5 两个attribute实例的相互匹配18.6 检测定制attribute时不创建从Attribute派生的对象18.7 条件attribute类第19章 可空值类型19.1 C#对可窄值类型的支持19.2 C＃的空接合操作符19.3 CLR对可空值类型的特殊支持19.3.1 可空值类型的装箱19.3.2 可空值类型的拆箱19.3 .3通过可空值类型调用Get Type19.3.4 通过可空值类型调用接口方法第Ⅳ部分 核心机制第20章 异常和状态管理20.1 定义“异常20.2 异常处理机制20.2.1 try块20.2.2 catch块20.2 .3finalb，块20.3System.Exception类20.4 FCL定义的异常类20.5 抛出异常20.6 定义自己的异常类20.7 用可靠性换取开发效率20.8 指导原则和*佳实践20.8.1 善用finally块20.8 12不要什么都捕捉20.8 .3得体地从异常中恢复20.8.4 发生不可恢复的异常时回滚部分完成的操作——维持状态20.8.5 隐藏实现细节来维系契约20.9 未处理的异常20.10 对异常进行调试20.11 异常处理的性能问题20.12 约束执行区域（CER）20.13 代码契约第21章 自动内存管理（垃圾回收）21.1 理解垃圾回收平台的基小工作原理21.2 垃圾回收算法……第22章 CLR寄宿和AppDomain第23章 程序集加载和反射第24章 运行时序列化第V部分 线程处理
