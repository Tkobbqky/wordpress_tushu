Ruby程序员修炼之道-(第2版) PDF下载 戴维A.布莱克 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711540503
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711540503
<p>书名:Ruby程序员修炼之道-(第2版)</p><p>作者:戴维 A.布莱克</p><p>页数:442</p><p>定价:¥89.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2016-11-01</p><p>ISBN:9787115405036</p><p><h2>本书特色</h2></p>[<p>
这是一本深受好评的书。它不仅是一本纯Ruby的书，也不仅是一本纯Rails的书，而是一本为Rails程序员“优化”过的Ruby书。
本书从Ruby编程语言的基础开始一直讲到动态特性，其中包含大量的真实代码示例并附有详细的注解，对日常使用Ruby进行编程中会遇到的每个知识点都进行了清晰的讲解。本书的内容由浅入深，主要包含Ruby编程语言的语法、面向对象的特性、默认对象self、控制流技术、常用的内置类、正则表达式、I/O操作，用大量的篇幅讲述了Ruby中值得关注的动态特性。
本书不仅适合Ruby编程语言的初学者，也适合有经验的开发者以及那些想要真正提升Ruby编程技术的爱好者阅读和学习，具有极高的参考价值。
                                        </p>]<p><h2>作者简介</h2></p>[<p>David A. Black是国际知名的Ruby开发者、作家、培训师、演讲者、活动组织者、Ruby Central创办人、Cyrus Innovation首席顾问。</p>]<p><h2>目录</h2></p>
    目录**部分　Ruby语言基础
第1章　进入Ruby的世界　2
1.1　Ruby语言基础知识　3
1.1.1　Ruby语法生存包　4
1.1.2　多种多样的Ruby标识符　5
1.1.3　方法调用、消息和Ruby对象　7
1.1.4　编写和保存一个简单程序　8
1.1.5　给Ruby提供程序　9
1.1.6　键盘和文件I/O　11
1.2　剖析Ruby的安装　13
1.2.1　Ruby标准库子目录（RbConfig::CONFIG[rubylibdir]）　14
1.2.2　C语言扩展目录（RbConfig::CONFIG[archdir]）　14
1.2.3　site_ruby (RbConfig::CONFIG[sitedir])和vendor_ruby(RbConfig::CONFIG[vendordir])
1.2.4　gems目录　15
1.3　Ruby扩展和编程库　15
1.3.1　加载外部文件和扩展　16
1.3.2　加载位于默认加载路径中的文件　17
1.3.3　请求功能　18
1.3.4　require_relative指令　19
1.4　易用的Ruby工具和应用程序　19
1.4.1　解释器的命令行开关　20
1.4.2　走近Ruby的交互式解释器irb　23
1.4.3　ri和RDoc　25
1.4.4　任务管理实用工具：rake　26
1.4.5　使用gem命令安装组件包　28
1.5　小结　29
第2章　对象、方法和局部变量　30
2.1　与对象对话　30
2.1.1　Ruby和面向对象技术　31
2.1.2　创建通用对象　31
2.1.3　带参数的方法　33
2.1.4　方法的返回值　34
2.2　制作一个对象：一个ticket对象的行为　35
2.2.1　ticket对象，行为优先　35
2.2.2　查询ticket对象　36
2.2.3　通过字符串插值缩短ticket代码　37
2.2.4　入场券有效性：用方法表达布尔状态　37
2.3　对象的原生行为　39
2.3.1　使用object_id方法唯一标识对象　40
2.3.2　使用respond_to?方法查询对象的能力　41
2.3.3　使用send方法发送信息给对象　41
2.4　走近方法参数　43
2.4.1　必选参数和可选参数　43
2.4.2　参数的默认值　44
2.4.3　形参和实参的顺序　45
2.4.4　实际参数列表的错误使用方式　47
2.5　局部变量和变量赋值　48
2.5.1　变量、对象和引用　49
2.5.2　变量赋值和重新赋值中的引用　51
2.5.3　引用和方法参数　52
2.5.4　局部变量及类似的事物　53
2.6　小结　54
第3章　使用类组织对象　55
3.1　类和继承　56
3.1.1　实例方法　56
3.1.2　覆盖方法　57
3.1.3　重开类　57
3.2　实例变量和对象状态　59
3.3　setter方法　62
3.3.1　方法命名中的等号　62
3.3.2　用于赋值风格方法的
语法糖　63
3.3.3　充分使用setter方法　64
3.4　属性和attr_*方法体系　66
3.4.1　自动创建属性　66
3.4.2　总结attr_*方法　68
3.5　继承和Ruby类层级结构　69
3.5.1　单继承：继承一个customer　70
3.5.2　对象祖先和永不缺失的联系：Object类　70
3.5.3　El Viejo的长兄：BasicObject　71
3.6　类作为对象和消息接收者　72
3.6.1　创建类对象　72
3.6.2　类对象如何调用方法　73
3.6.3　单例方法的另一种使用方式　74
3.6.4　编写一个类方法的时机和原因　75
3.6.5　类方法与实例方法　76
3.7　走近常量　77
3.7.1　常量的基础应用　77
3.7.2　重赋值与修改常量　78
3.8　Ruby对象的“先天与后天”　79
3.9　小结　81
第4章　模块和程序组织　82
4.1　模块创建和基础应用　82
4.1.1　使用模块封装“栈特性”　83
4.1.2　将模块混合到类中　85
4.1.3　进一步使用模块　87
4.2　模块、类和方法查找　89
4.2.1　方法查找的基本原理　89
4.2.2　同名方法的多次定义　92
4.2.3　prepend的工作原理　94
4.2.4　总结方法查找的规则　95
4.2.5　使用super向上追溯方法路径　96
4.3　method_missing方法　98
4.4　类和模块的设计与命名　102
4.4.1　混合和继承　103
4.4.2　内嵌模块和类　104
4.5　小结　105
第5章　默认对象（self）、作用域和可见性　107
5.1　理解self、当前对象或默认对象　108
5.1.1　转变为self的对象和上下文　108
5.1.2　顶层的self对象　109
5.1.3　类、模块和方法定义中的self　110
5.1.4　self作为消息的默认接收者　112
5.1.5　通过self解析实例变量　115
5.2　判定作用域　116
5.2.1　全局作用域和全局变量　116
5.2.2　局部作用域　118
5.2.3　局部作用域和self的相互作用　121
5.2.4　作用域和常量的解析　122
5.2.5　类变量语法、作用域和可见性　124
5.3　部署方法访问规则　130
5.3.1　私有方法　130
5.3.2　受保护的方法　133
5.4　编写和使用顶层方法　134
5.4.1　定义一个顶层方法　134
5.4.2　预定义的（内置的）顶层方法　135
5.5　小结　136
第6章　控制流技术　137
6.1　条件代码执行　137
6.1.1　if和它的朋友们　138
6.1.2　在条件语句主体和测试中的赋值语法　142
6.1.3　case语句　144
6.2　使用循环重复执行　148
6.2.1　在loop方法中无条件地循环　148
6.2.2　使用while和until关键字进行条件循环　149
6.2.3　基于值列表循环　151
6.3　迭代器和代码块　152
6.3.1　迭代的细节　152
6.3.2　迭代：“家常菜”　152
6.3.3　解析方法调用　153
6.3.4　代码块语法：花括号与do/end　154
6.3.5　实现times方法　155
6.3.6　each方法的重要性　156
6.3.7　从each到map　158
6.3.8　代码块参数和变量作用域　159
6.4　错误处理和异常　162
6.4.1　引发和捕获异常　162
6.4.2　使用rescue关键字挽救程序　163
6.4.3　显式地引发异常　165
6.4.4　在rescue子句中捕获异常　165
6.4.5　ensure子句　167
6.4.6　创建自己的异常类　168
6.5　小结　169
第二部分　内置类和模块
第7章　内置要点　173
7.1　Ruby的字面构造器　174
7.2　常用的语法糖　175
7.2.1　通过定义方法定义运算符　175
7.2.2　自定义一元运算符　177
7.3　bang（!）方法和“危险”　178
7.3.1　破坏性（接收者改变）影响的危险　178
7.3.2　破坏能力和“危险”相对独立的不同点　179
7.4　内置和自定义to_*（转换）方法　180
7.4.1　字符串转换：to_s　181
7.4.2　使用to_a和*运算符进行数组转换　183
7.4.3　使用to_i和to_f进行数字转换　184
7.4.4　角色扮演to_*方法　185
7.5　布尔状态、布尔对象和nil　187
7.5.1　true和false作为状态使用　187
7.5.2　true和false作为对象　189
7.5.3　特殊的对象nil　190
7.6　对象比较　191
7.6.1　相等性测试　191
7.6.2　比较和Comparable模块　192
7.7　审查对象的能力　194
7.7.1　列出对象的方法　194
7.7.2　查询类和模块对象　196
7.7.3　过滤和选择性的方法列表　196
7.8　小结　197
第8章　字符串、符号和其他标 量对象　198
8.1　字符串的使用　198
8.1.1　字符串表示法　199
8.1.2　基础的字符串操作　202
8.1.3　查询字符串　206
8.1.4　字符串比较和排序　208
8.1.5　字符串转换　209
8.1.6　字符串转型　212
8.1.7　字符串编码的简介　213
8.2　符号及其使用　214
8.2.1　符号的主要特点　215
8.2.2　符号和标识符　216
8.2.3　实践中的符号　217
8.2.4　比较字符串和符号　219
8.3　数值对象　220
8.3.1　数值类　221
8.3.2　执行算术运算　221
8.4　时间和日期　222
8.4.1　实例化日期和时间对象　223
8.4.2　日期对象查询的方法　225
8.4.3　日期时间格式化的方法　226
8.4.4　日期/时间对象的转换方法　227
8.5　小结　228
第9章　集合和容器对象　230
9.1　数组和散列的比较　231
9.2　使用数组处理集合　232
9.2.1　创建新数组　232
9.2.2　插入、取回和移除数组的元素　236
9.2.3　数组的合并　238
9.2.4　数组转换　240
9.2.5　数组查询　241
9.3　散列　241
9.3.1　创建新的散列　242
9.3.2　插入、取回和移除散列键值对　243
9.3.3　指定默认的散列值和行为　245
9.3.4　与其他散列合并　246
9.3.5　散列转换　247
9.3.6　散列查询　248
9.3.7　散列用于方法的*终参数　249
9.3.8　回到参数的语法：具名（关键字）参数　250
9.4　范围　251
9.4.1　创建范围　252
9.4.2　范围的包含逻辑　253
9.5　集合　255
9.5.1　集合的创建　255
9.5.2　操作集合的元素　256
9.5.3　子集和超集　258
9.6　小结　259
第10章　集合类型核心：Enumerable和Enumerator　260
10.1　运用each获得枚举能力　261
10.2　Enumerable的布尔值查询　263
10.3　可枚举对象的搜索和选择　265
10.3.1　通过find方法进行**次 匹配　265
10.3.2　使用find_all（又名select）和reject获取 所有的匹配元素　266
10.3.3　使用基于三等号匹配的grep来选择元素　267
10.3.4　使用group_by和partition组织选择的结果　268
10.4　可枚举对象的元素级操作　269
10.4.1　first方法　270
10.4.2　take方法和drop方法　271
10.4.3　min方法和max方法　272
10.5　与each相关的方法　273
10.5.1　reverse_each方法　273
10.5.2　each_with_index方法（和each.with_index）　273
10.5.3　each_slice方法和each_cons方法　275
10.5.4　cycle方法　275
10.5.5　使用inject减少可枚举集合类型对象的数量　276
10.6　map方法　277
10.6.1　map的返回值　278
10.6.2　使用map!原位映射　278
10.7　将字符串作为准可枚举对象　279
10.8　可枚举对象的排序　281
10.8.1　在可枚举对象排序中使用（或不使用）Comparable 模块　282
10.8.2　使用代码块定义排序 逻辑　282
10.8.3　使用sort_by快捷排序　283
10.9　枚举器和可枚举性的下一个维度　283
10.9.1　使用代码块创建枚举器　284
10.9.2　附加枚举器到其他对象　286
10.9.3　无代码块迭代器隐式创建 枚举器　287
10.10　枚举器的语义和使用　288
10.10.1　枚举器each方法的运用　288
10.10.2　使用枚举器保护对象　290
10.10.3　使用枚举器的细粒度迭代　291
10.10.4　使用枚举器添加可枚举性　292
10.11　枚举器的方法链　293
10.11.1　节约使用中间对象　293
10.11.2　使用with_index检索可枚举对象　295
10.11.3　使用枚举器在字符串上执行异或操作　295
10.12　延迟枚举器　297
10.13　小结　299
第11章　正则表达式和基于正则表达式的字符串操作　300
11.1　什么是正则表达式　300
11.2　编写正则表达式　301
11.2.1　理解模式　301
11.2.2　使用正则表达式的字面构造器执行简单匹配　302
11.3　构建正则表达式的模式　303
11.3.1　模式中的文字字符　303
11.3.2　点通配符（.）　303
11.3.3　字符类　304
11.4　匹配、子串截取和MatchData　305
11.4.1　分组捕获　305
11.4.2　匹配成功和失败　307
11.4.3　获取捕获结果的两种方式　308
11.4.4　其他MatchData的信息　309
11.5　使用量词、锚点和修饰符微调正则表达式　310
11.5.1　使用量词约束匹配　310
11.5.2　贪婪的（和非贪婪的）量词　312
11.5.3　正则表达式的锚点和断言　314
11.5.4　修饰符　317
11.6　字符串和正则表达式的相互转换　318
11.6.1　字符串转换为正则表达式的习语　318
11.6.2　转换正则表达式为字符串　320
11.7　正则表达式的常用方法　320
11.7.1　String#scan　321
11.7.2　String#split　322
11.7.3　sub/sub!和gsub/gsub!　323
11.7.4　case相等性和grep方法　324
11.8　小结　326
第12章　文件和I/O操作　327
12.1　Ruby中I/O系统的组成　327
12.1.1　IO类　328
12.1.2　将IO对象用作可枚举对象　328
12.1.3　STDIN、STDOUT、STDERR　329
12.1.4　关于键盘输入的更多内容　330
12.2　基本文件操作　331
12.2.1　文件读取基础　331
12.2.2　基于行的文件读取　332
12.2.3　基于字节和字符的文件读取　333
12.2.4　搜索和查询文件位置　333
12.2.5　使用File的类方法读取文件　334
12.2.6　写入文件　335
12.2.7　使用代码块限定文件操作的作用域　336
12.2.8　File对象的可枚举性　337
12.2.9　文件I/O异常和错误　338
12.3　查询IO和File对象　339
12.3.1　从File类和FileTest模块中获得信息　339
12.3.2　使File::Stat获取文件信息　340
12.4　使用Dir类进行目录操作　341
12.4.1　读取目录下的条目　341
12.4.2　目录操作和查询　343
12.5　标准库中的文件处理工具　344
12.5.1　FileUtils模块　345
12.5.2　Pathname类　346
12.5.3　StringIO类　348
12.5.4　open-uri库　349
12.6　小结　349
第三部分　Ruby动态编程
第13章　对象的个性化　353
13.1　单例对象存在的位置：单例类　354
13.1.1　通过单例类双重决定　355
13.1.2　直接检查和修改单例类　355
13.1.3　查找路径中的单例类　357
13.1.4　singleton_class方法　361
13.1.5　深入类方法　361
13.2　修改Ruby核心类和模块　363
13.2.1　改变核心功能的风险　363
13.2.2　附加修改　368
13.2.3　穿透覆盖　368
13.2.4　通过extend修改独立对象　370
13.2.5　使用精化修改核心行为　373
13.3　BasicObject作为祖先类和类　374
13.3.1　使用BasicObject　374
13.3.2　实现BasicObject的子类　376
13.4　小结　378
第14章　可调用和可运行
对象　379
14.1　基础的匿名函数：Proc类　380
14.1.1　Proc对象　380
14.1.2　proc和代码块以及区别　381
14.1.3　代码块与proc相互转换　382
14.1.4　简洁的Symbol#to_proc　385
14.1.5　proc作为闭包使用　386
14.1.6　Proc的形式参数和实际参数　388
14.2　使用lambda和->创建函数　389
14.3　将方法作为对象使用　390
14.3.1　捕获方法对象　391
14.3.2　方法对象的基本原理　391
14.4　eval方法体系　393
14.4.1　使用eval执行任意的字符串　393
14.4.2　eval的危险　394
14.4.3　instance_eval方法　395
14.4.4　使用class_eval（又名module_eval）　397
14.5　使用线程并行执行　398
14.5.1　终止、停止和开启线程　399
14.5.2　基于线程实现的日期服务器　401
14.5.3　使用套接字和线程编写聊天服务器　402
14.5.4　线程与变量　404
14.5.5　操作线程键　405
14.6　从Ruby内部程序中发出系统命令　408
14.6.1　system方法和反引号　408
14.6.2　通过open和popen3与程序通信　410
14.7　小结　412
第15章　回调、钩子和运行时自省　414
15.1　回调和钩子　414
15.1.1　使用method_missing拦截不可识别的消息　415
15.1.2　捕获include和prepend操作　418
15.1.3　拦截extend　419
15.1.4　使用Class#inherited拦截继承事件　421
15.1.5　Module#const_missing方法　422
15.1.6　method_added方法和singleton_method_added方法　422
15.2　拦截针对对象能力的查询　424
15.2.1　列出对象的非私有方法　424
15.2.2　列出私有和受保护方法　426
15.2.3　获得类和模块的实例方法　427
15.2.4　列出对象的单例方法　429
15.3　变量和常量的自省机制　431
15.3.1　列出局部和全局变量　431
15.3.2　列出实例变量　431
15.4　执行追踪　432
15.4.1　使用caller检查栈追踪　432
15.4.2　编写工具以解析栈追踪　433
15.5　回调和方法审查的实践　436
15.5.1　MicroTest的背景： MiniTest　436
15.5.2　说明和实现 MicroTest　439
15.6　小结　441信息
