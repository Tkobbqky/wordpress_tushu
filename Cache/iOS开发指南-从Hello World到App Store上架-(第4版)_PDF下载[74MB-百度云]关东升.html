iOS开发指南-从Hello World到App Store上架-(第4版) PDF下载 关东升 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711542318
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711542318
<p>书名:iOS开发指南-从Hello World到App Store上架-(第4版)</p><p>作者:关东升</p><p>页数:802</p><p>定价:¥119.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2016-06-01</p><p>ISBN:9787115423184</p><p><h2>相关资料</h2></p>[<p>“本书在前一版的基础上针对ios 9进行了更新。书中以swift和objective-c两种语言进行讲解，内容涉及ios开发的各个方面，可以帮助开发者快速开发移动应用。本书重点突出，并且提供了大量实例源码和详细插图，有助于开发者更好地理解书中的内容。它不仅是初级开发者的入门教程，也可以作为高级开发者在闲暇之余翻阅的工具书。”——cocoachina社区
 
“本书连续4年被51cto社区评为ios最受欢迎的图书，一直作为“51cto学院ios就业培训班”指定教材，深受51cto社区广大开发者和爱好者的好评和认可，有几万人通过此书掌握ios技术，走上ios开发之路。”——曹亚莉，51cto博客总编、51cto学院高级产品运营经理
 
“认识关老师多年，并感动于他对移动终端开发与推广的热情！本书涵盖了ios 9的相关内容，通俗易懂，深入浅出，是ios开发人员手头必备的参考书。本书不仅侧重应用，而且兼顾理论，不可多得，书中同时提供了大量的实战案例，便于动手实践，是一本不可或缺的ios经典好书。”——柯博文，美国硅谷looptek公司cto，《大富翁》游戏主程，swift开源技术专家
 
“本书是第4版，继续秉承了双语（swift和objective-c）讲解，两种语言对照学习，能够快速上手。作者根据前3版读者的反馈，增加了通过代码构建界面相关知识点，同时也保留了通过故事板构建界面的内容。此外，还增加了ui测试、流行网络通信框架afnetworking和alamofire、项目依赖管理工具cocoapods和carthage等内容，摒弃了一些过时框架和技术。本书是一本广受ios开发人员好评的图书。”——智捷课堂</p>]<p><h2>本书特色</h2></p>[<p>
本书是ios开发杰出指南，分5部分讲解如何从零起步编写并上线ios应用。首部分介绍ios开发基础知识，包括界面构建技术、基本控件、协议、表视图、屏幕适配、导航、分屏多任务等。第二部分介绍设计与架构的相关知识，包括设计模式、分层模式、本地数据持久化等。第三部分为进阶篇，包括设置与配置、本地化、contacts与contactsui框架、数据交换格式、web service、定位服务、苹果地图等内容。第四部分介绍测试、调试和优化等相关知识。第五部分为实战篇，涵盖代码版本管理、项目依赖管理、app store发布流程，以及两个真实ios应用的分析设计、编程、测试与分布过程。本书同时提供swift和objective-c两版代码。本书适合所有ios开发人员学习参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>畅销书全新升级，累计印数60000册 
swift和objective-c双语讲解 
新增通过代码构建界面、ui测试、afnetworking和alamofire、cocoapods和carthage等
数百个项目案例 两个真实项目开发全过程 
涵盖ios平台架构设计、测试驱动开发、性能优化、版本控制和程序调试等
 </p>]<p><h2>作者简介</h2></p>[<p>关东升

国内杰出iOS和Cocos技术作家、iOS技术顾问、Cocos最有价值专家（CVP）、智捷课堂首席培训专家、51CTO社区iOS技术顾问。他精通iOS、Android和Windows及HTML5等移动开发技术，擅长应用和游戏类项目开发，曾先后主持开发：大型网络游戏《神农诀》的iOS和Android客户端，国家农产品追溯系统的iPad客户端，酒店预订系统的iOS客户端，金融系统的iOS、Windows及Android客户端。与此同时，他长期为中国移动研究院、方正科技、大唐电信、中国石油、工商银行、南方航空、惠普、东软集团、NTT等企事业单位提供技术咨询及员工培训。
</p>]<p><h2>目录</h2></p>
    **部分 　基础篇第1章　开篇综述　　21.1 　ios概述　　21.1.1 　ios介绍　　21.1.2 　ios 9新特性　　21.2 　开发环境及开发工具　　31.3 　本书约定　　41.3.1 　案例代码约定　　41.3.2 　图示的约定　　51.3.3 　方法命名约定　　61.3.4 　构造函数命名约定　　71.3.5 　错误处理约定　　8第2章　**个ios应用程序　　102.1 　创建helloworld工程　　102.1.1 　创建工程　　102.1.2 　xcode中的ios工程模板　　142.1.3 　应用剖析　　152.2 　应用生命周期　　172.2.1 　非运行状态——应用启动场景　　192.2.2 　点击home键——应用退出场景　　202.2.3 　挂起重新运行场景　　222.2.4 　内存清除：应用终止场景　　232.3 　设置产品属性　　232.3.1 　xcode中的工程和目标　　232.3.2 　设置常用的产品属性　　262.4 　ios api简介　　272.4.1 　api概述　　272.4.2 　如何使用api帮助　　292.5 　小结　　32第3章　cocoa touch框架与构建应用界面　　333.1 　视图控制器　　333.1.1 　视图控制器种类　　333.1.2 　视图的生命周期　　333.2 　视图　　353.2.1 　uiview继承层次结构　　353.2.2 　视图分类　　373.2.3 　应用界面构建层次　　373.3 　使用故事板构建界面　　383.3.1 　什么是故事板　　393.3.2 　场景和过渡　　413.4 　使用xib文件构建界面　　423.4.1 　重构helloworld　　423.4.2 　xib与故事板比较　　453.5 　使用纯代码构建界面　　453.5.1 　重构helloworld　　463.5.2 　视图的几个重要属性　　473.6 　3种构建界面技术讨论　　493.6.1 　所见即所得　　493.6.2 　原型驱动开发　　493.6.3 　团队协同开发　　493.7 　小结　　50第4章　uiview与视图　　514.1 　标签与按钮　　514.1.1 　interface builder实现　　514.1.2 　代码实现　　554.2 　事件处理　　564.2.1 　interface builder实现　　564.2.2 　代码实现　　594.3 　访问视图　　604.3.1 　interface builder实现　　604.3.2 　代码实现　　624.4 　textfield和textview　　634.4.1 　interface builder实现　　644.4.2 　代码实现　　654.4.3 　键盘的打开和关闭　　674.4.4 　关闭和打开键盘的通知　　684.4.5 　键盘的种类　　694.5 　开关控件、分段控件和滑块控件　　704.5.1 　开关控件　　714.5.2 　分段控件　　724.5.3 　滑块控件　　744.6 　web视图：wkwebview类　　764.7 　警告框和操作表　　804.7.1 　uialertcontroller实现警告框　　814.7.2 　uialertcontroller实现操作表　　834.8 　等待相关的控件与进度条　　844.8.1 　活动指示器activityindicatorview　　854.8.2 　进度条progressview　　874.9 　工具栏和导航栏　　904.9.1 　工具栏　　904.9.2 　导航栏　　944.10 　小结　　98第5章　委托协议、数据源协议与高级视图　　995.1 　视图中的委托协议和数据源协议　　995.2 　选择器　　995.2.1 　日期选择器　　995.2.2 　普通选择器　　1045.2.3 　数据源协议与委托协议　　1095.3 　集合视图　　1115.4 　实例：interface builder实现奥运会比赛项目　　1125.4.1 　添加集合视图　　1135.4.2 　添加集合视图单元格　　1145.4.3 　数据源协议与委托协议　　1185.5 　实例：代码实现奥运会比赛项目　　1205.5.1 　添加集合视图　　1205.5.2 　自定义集合视图单元格　　1225.6 　小结　　123第6章　表视图　　1246.1 　概述　　1246.1.1 　表视图的组成　　1246.1.2 　表视图的相关类　　1256.1.3 　表视图分类　　1256.1.4 　单元格的组成和样式　　1276.1.5 　数据源协议与委托协议　　1296.2 　简单表视图　　1296.2.1 　实现协议方法　　1306.2.2 　uiviewcontroller根视图控制器　　1306.2.3 　uitableviewcontroller根视图控制器　　1376.3 　自定义表视图单元格　　1406.3.1 　interface builder实现　　1416.3.2 　代码实现　　1456.4 　添加搜索栏　　1466.5 　分节表视图　　1506.5.1 　添加索引　　1506.5.2 　分组　　1536.6 　静态表与界面布局　　1546.7 　插入和删除单元格　　1606.7.1 　interface builder实现　　1626.7.2 　代码实现　　1676.8 　移动单元格　　1696.9 　表视图ui设计模式　　1716.9.1 　分页模式　　1716.9.2 　下拉刷新模式　　1716.9.3 　下拉刷新控件　　1726.10 　小结　　174第7章　界面布局与屏幕适配　　1757.1 　界面布局概述　　1757.2 　ios界面布局设计模式　　1767.2.1 　表单布局模式　　1767.2.2 　列表布局模式　　1767.2.3 　网格布局模式　　1777.3 　传统布局技术　　1777.4 　auto layout布局技术　　1797.4.1 　interface builder中管理auto layout约束　　1797.4.2 　实例：auto layout布局　　1807.5 　ios 9堆视图stackview　　1857.5.1 　堆视图与布局　　1857.5.2 　实例：堆视图布局　　1867.6 　ios 屏幕的多样性　　1917.6.1 　ios屏幕介绍　　1917.6.2 　ios的3种分辨率　　1927.6.3 　获得ios设备屏幕信息　　1937.7 　size class与ios多屏幕适配　　1947.7.1 　interface builder中使用size class　　1957.7.2 　size class的九宫格　　1957.7.3 　实例：使用size class　　1967.8 　资源目录与图片资源适配　　2017.9 　小结　　204第8章　视图控制器与导航模式　　2058.1 　概述　　2058.1.1 　视图控制器的种类　　2058.1.2 　导航模式　　2058.2 　模态视图　　2078.2.1 　interface builder实现　　2088.2.2 　代码实现　　2148.3 　平铺导航　　2158.3.1 　应用场景　　2158.3.2 　基于分屏导航的实现　　2178.3.3 　基于电子书导航的实现　　2238.4 　标签导航　　2288.4.1 　应用场景　　2298.4.2 　interface builder实现　　2308.4.3 　代码实现　　2348.5 　树形结构导航　　2358.5.1 　应用场景　　2358.5.2 　interface builder实现　　2368.5.3 　代码实现　　2448.6 　组合使用导航模式　　2458.6.1 　应用场景　　2468.6.2 　interface builder实现　　2468.6.3 　代码实现　　2548.7 　小结　　257第9章　ipad应用开发　　2589.1 　ipad与iphone应用开发的差异　　2589.1.1 　应用场景不同　　2589.1.2 　导航模式不同　　2589.1.3 　api不同　　2589.2 　ipad树形结构导航　　2599.2.1 　邮件应用中的树形结构导航　　2599.2.2 　master-detail应用程序模板　　2609.2.3 　interface builder实现splitviewsample案例　　2669.2.4 　代码实现splitviewsample案例　　2709.3 　ipad模态视图　　2739.3.1 　邮件应用中的模态导航　　2739.3.2 　ipad模态导航相关api　　2759.3.3 　interface builder实现modalview-sample案例　　2779.3.4 　代码实现modalviewsample案例　　2819.4 　popover（浮动层）视图　　2849.4.1 　popover相关api　　2849.4.2 　popoverviewsample案例　　2859.5 　ios 9分屏多任务　　2899.5.1 　slide over多任务　　2899.5.2 　分屏视图多任务　　2909.5.3 　画中画多任务　　2939.6 　ipad分屏多任务适配开发　　2939.6.1 　分屏多任务前提条件　　2939.6.2 　分屏多任务适配　　2949.7 　小结　　295第二部分 　设计与架构篇第10章　ios常用设计模式　　29810.1 　单例模式　　29810.1.1 　问题提出　　29810.1.2 　objective-c实现原理　　29810.1.3 　swift实现原理　　29910.1.4 　应用案例　　30010.2 　委托模式　　30110.2.1 　问题提出　　30110.2.2 　实现原理　　30310.2.3 　应用案例　　30610.3 　观察者模式　　30910.3.1 　问题提出　　30910.3.2 　实现原理　　31010.3.3 　通知机制和kvo机制　　31110.4 　再谈mvc模式　　31710.4.1 　mvc模式概述　　31710.4.2 　cocoa touch中的mvc模式　　31810.5 　小结　　320第11章　ios分层架构设计　　32111.1 　低耦合企业级系统架构设计　　32111.2 　ios分层架构设计　　32211.2.1 　工程与工作空间　　32211.2.2 　静态链接库　　32311.2.3 　框架　　32311.2.4 　16种分层模式　　32411.3 　实例：mynotes应用　　32511.4 　基于同一工程的分层　　32711.4.1 　采用纯swift语言实现：psss模式　　32711.4.2 　采用纯objective-c语言实现：pooo模式　　33011.4.3 　采用swift调用objective-c的混合搭配实现：psoo模式　　33411.5 　基于同一工作空间静态链接库实现的wlsoo模式　　33511.5.1 　使用工作空间　　33511.5.2 　添加数据持久层工程　　33611.5.3 　建立业务逻辑层与数据持久层依赖关系　　33711.5.4 　建立表示层与业务逻辑层依赖关系　　33911.6 　基于同一工作空间框架实现的wfsss模式　　33911.6.1 　创建框架工程　　34011.6.2 　建立依赖关系　　34111.6.3 　代码重构　　34211.7 　基于同一工作空间框架实现的wfooo模式　　34411.7.1 　设置public头文件　　34411.7.2 　设置保护伞头文件　　34511.7.3 　代码重构　　34511.8 　基于同一工作空间框架实现的wfsoo模式　　34611.8.1 　设置public头文件　　34611.8.2 　设置保护伞头文件　　34611.8.3 　建立表示层与业务逻辑层依赖关系　　34611.8.4 　代码重构　　34611.9 　基于同一工作空间框架实现的wfoss模式　　34611.9.1 　设置public头文件　　34611.9.2 　设置swift代码嵌入应用　　34711.9.3 　代码重构　　34711.10 　基于同一个工程不同目标框架实现的tfsoo模式　　34811.10.1 　使用目标　　34811.10.2 　添加框架目标　　34811.11 　小结　　349第12章　数据持久化　　35012.1 　概述　　35012.1.1 　沙箱目录　　35012.1.2 　持久化方式　　35112.2 　属性列表　　35112.3 　对象归档　　35712.4 　使用sqlite数据库　　36112.4.1 　sqlite数据类型　　36112.4.2 　配置objective-c框架工程环境　　36212.4.3 　配置swift框架工程环境　　36212.4.4 　创建数据库　　36412.4.5 　查询数据　　36512.4.6 　修改数据　　36812.5 　core data　　37012.5.1 　orm　　37012.5.2 　core data栈　　37112.5.3 　建模和生成实体　　37412.5.4 　采用core data分层架构设计　　38012.5.5 　查询数据　　38212.5.6 　修改数据　　38412.6 　小结　　385第三部分 　进 　阶 　篇第13章　应用程序设置　　38813.1 　概述　　38813.1.1 　设置　　38813.1.2 　配置　　38913.2 　应用程序设置包　　39013.3 　设置项目种类　　39213.3.1 　文本字段　　39513.3.2 　开关　　39813.3.3 　滑块　　39913.3.4 　值列表　　40013.3.5 　子界面　　40113.4 　读取设置　　40313.5 　小结　　405第14章　本地化　　40614.1 　概述　　40614.1.1 　需要本地化的内容　　40614.1.2 　本地化目录结构　　40914.2 　文本信息本地化　　41014.2.1 　系统按钮和信息本地化　　41014.2.2 　应用名称本地化　　41114.2.3 　程序代码输出的静态文本本地化　　41314.2.4 　使用genstring工具　　41414.3 　故事板和xib文件本地化　　41514.3.1 　使用base internationalization技术　　41514.3.2 　auto layout与本地化　　41714.4 　资源文件本地化　　41914.4.1 　图片资源文件本地化　　41914.4.2 　声音资源文件本地化　　42014.5 　小结　　421第15章　ios 9中访问通讯录　　42215.1 　通讯录的安全访问设置　　42215.2 　使用contacts框架读取联系人信息　　42315.2.1 　查询联系人　　42315.2.2 　读取单值属性　　42615.2.3 　读取多值属性　　42815.2.4 　读取图片属性　　43015.3 　使用contacts框架写入联系人信息　　43015.3.1 　创建联系人　　43115.3.2 　修改联系人　　43315.3.3 　删除联系人　　43415.4 　使用系统提供界面　　43515.4.1 　选择联系人　　43515.4.2 　显示和修改联系人　　43815.4.3 　创建联系人　　44115.5 　小结　　444第16章　数据交换格式　　44516.1 　xml数据交换格式　　44616.1.1 　xml文档结构　　44616.1.2 　解析xml文档　　44716.2 　实例：mynotes应用xml　　44816.2.1 　使用nsxml解析　　45016.2.2 　使用tbxml解析　　45316.3 　json数据交换格式　　45916.3.1 　json文档结构　　45916.3.2 　json数据编码/解码　　46016.4 　实例：mynotes应用json解码　　46116.5 　小结　　462第17章　rest web service　　46317.1 　概述　　46317.2 　使用nsurlsession　　46417.2.1 　nsurlsession api　　46417.2.2 　简单会话实现get请求　　46517.2.3 　默认会话实现get请求　　46817.2.4 　实现post请求　　46917.2.5 　下载数据　　47017.3 　实例：使用nsurlsession重构mynotes案例　　47317.3.1 　插入方法调用　　47317.3.2 　修改方法调用　　47417.3.3 　删除方法调用　　47517.4 　使用afnetworking框架　　47717.4.1 　比较asihttprequest、afnetworking和mknetworkkit　　47717.4.2 　安装和配置afnetworking框架　　47817.4.3 　实现get请求　　47917.4.4 　实现post请求　　48017.4.5 　下载数据　　48117.4.6 　上传数据　　48217.5 　使用为swift设计的网络框架：alamofire　　48417.5.1 　安装和配置alamofire框架　　48417.5.2 　实现get请求　　48517.5.3 　实现post请求　　48617.5.4 　下载数据　　48717.5.5 　上传数据　　48817.6 　反馈网络信息改善用户体验　　48917.6.1 　使用下拉刷新控件改善用户体验　　48917.6.2 　使用活动指示器控件　　49217.6.3 　使用网络活动指示器　　49417.7 　小结　　494第18章　定位服务　　49518.1 　定位服务概述　　49518.1.1 　定位服务编程　　49618.1.2 　测试定位服务　　49918.2 　管理定位服务　　50318.2.1 　应用启动与停止下的定位服务管理　　50418.2.2 　视图切换下的定位服务管理　　50418.2.3 　应用前后台切换下的定位服务管理　　50518.2.4 　设置自动暂停位置服务　　50718.2.5 　ios 9后台位置服务管理　　50718.3 　地理信息编码与反编码　　50818.3.1 　地理信息反编码　　50818.3.2 　实例：地理信息反编码　　50918.3.3 　地理信息编码查询　　51018.3.4 　实例：地理信息编码查询　　51018.4 　微定位技术ibeacon　　51218.4.1 　微定位与地理围栏　　51218.4.2 　ibeacon技术概述　　51218.4.3 　实例：使用ibeacon技术实现微定位　　51318.5 　小结　　519第19章　苹果地图应用　　52019.1 　使用ios苹果地图　　52019.1.1 　显示地图　　52019.1.2 　显示3d地图　　52419.2 　添加标注　　52519.2.1 　实现查询　　52619.2.2 　在地图上添加标注　　52819.3 　跟踪用户位置变化　　52919.4 　使用程序外地图　　53019.5 　小结　　533第四部分 　测试、调试和优化篇第20章　找出程序中的bug——调试　　53620.1 　xcode调试工具　　53620.1.1 　定位编译错误　　53620.1.2 　查看和显示日志　　53720.1.3 　设置和查看断点　　53920.1.4 　调试工具　　54420.1.5 　输出窗口　　54520.1.6 　变量查看窗口　　54620.1.7 　查看线程　　54720.2 　lldb调试工具　　54820.2.1 　断点命令　　54820.2.2 　观察点命令　　55020.2.3 　查看变量和计算表达式命令　　55220.3 　日志与断言输出　　55420.3.1 　使用nslog函数　　55420.3.2 　使用断言　　55520.4 　异常栈报告分析　　55620.4.1 　跟踪异常栈　　55620.4.2 　分析栈报告　　55820.5 　在ios设备上调试　　55920.5.1 　xcode设置　　55920.5.2 　设备设置　　56020.6 　xcode设备管理工具　　56220.6.1 　查看设备上的应用程序　　56220.6.2 　设备日志　　56420.7 　小结　　564第21章　ios测试驱动与单元测试　　56521.1 　测试驱动的软件开发概述　　56521.1.1 　测试驱动的软件开发流程　　56521.1.2 　测试驱动的软件开发案例　　56621.1.3 　ios单元测试框架　　56721.2 　使用xctest测试框架　　56821.2.1 　添加xctest到工程　　56821.2.2 　swift版本中设置编译目标成员　　57021.2.3 　编写xctest测试方法　　57021.2.4 　运行测试用例目标　　57321.2.5 　分析测试报告　　57521.3 　异步单元测试　　57621.4 　性能测试　　58021.4.1 　swift版本中配置测试环境　　58021.4.2 　测试用例代码　　58021.4.3 　分析测试结果　　58121.5 　ios单元测试*佳实践　　58321.5.1 　配置测试数据持久层　　58321.5.2 　编写数据持久层测试用例　　58421.5.3 　运行测试数据持久层测试用例　　58721.5.4 　配置测试业务逻辑层　　58821.5.5 　编写业务逻辑层测试用例　　58821.6 　小结　　589第22章　ios应用ui测试　　59022.1 　ui测试概述　　59022.2 　添加ui测试到工程　　59022.2.1 　创建工程时添加ui测试框架　　59022.2.2 　在现有工程中添加ui测试用例目标　　59122.3 　录制脚本　　59322.3.1 　录制之前的准备　　59322.3.2 　录制过程　　59322.3.3 　修改录制脚本　　59522.4 　访问ui元素　　59522.4.1 　ui元素层次结构树　　59522.4.2 　ui测试中相关api　　59722.5 　表示层测试*佳实践　　59822.5.1 　配置ui测试用例目标　　59822.5.2 　编写ui测试用例　　59922.6 　小结　　602第23章　让你的程序“飞”起来——性能优化　　60323.1 　内存优化　　60323.1.1 　内存管理　　60323.1.2 　使用analyze工具检查内存泄漏　　60323.1.3 　使用instruments工具检查内存泄漏　　60823.1.4 　使用instruments工具检查僵尸对象　　61223.1.5 　autorelease的使用问题　　61523.1.6 　响应内存警告　　61623.2 　优化资源文件　　61723.2.1 　图片文件优化　　61823.2.2 　音频文件优化　　61923.3 　延迟加载　　62023.3.1 　资源文件的延迟加载　　62023.3.2 　故事板文件的延迟加载　　62423.3.3 　xib文件的延迟加载　　62623.4 　数据持久化的优化　　62823.4.1 　使用文件　　62823.4.2 　使用sqlite数据库　　63123.4.3 　使用core data　　63223.5 　可重用对象的使用　　63423.5.1 　表视图中的可重用对象　　63523.5.2 　集合视图中的可重用对象　　63623.5.3 　地图视图中的可重用对象　　63823.6 　并发处理与多核cpu　　63823.6.1 　主线程阻塞问题　　63823.6.2 　选择nsthread还是gcd　　63923.7 　小结　　640第五部分 　实 　战 　篇第24章　管理好你的程序代码——代码版本控制　　64224.1 　概述　　64224.1.1 　版本控制历史　　64224.1.2 　基本概念　　64324.2 　git代码版本控制　　64324.2.1 　服务器搭建　　64324.2.2 　gitolite服务器管理　　64524.2.3 　git常用命令　　64724.2.4 　git分支　　64924.2.5 　git协同开发　　65324.2.6 　xcode中git的配置与使用　　65624.3 　github代码托管服务　　66324.3.1 　创建和配置github账号　　66324.3.2 　创建代码库　　66624.3.3 　删除代码库　　66824.3.4 　派生代码库　　66924.3.5 　使用github协同开发　　67124.3.6 　管理组织　　67724.4 　小结　　680第25章　项目依赖管理　　68125.1 　使用cocoapods工具管理依赖　　68125.1.1 　安装cocoapods　　68125.1.2 　搜索库　　68225.1.3 　项目与第三方库搭配形式　　68325.1.4 　示例：静态链接库形式管理依赖　　68425.1.5 　示例：框架形式管理依赖　　68625.2 　使用carthage工具管理依赖　　68725.2.1 　安装carthage　　68825.2.2 　项目与第三方库搭配形式　　68825.2.3 　cartfile文件　　68825.2.4 　示例：重构mynotes依赖关系　　68925.3 　小结　　691第26章　重构mynotes应用——ios网络通信中的设计模式与架构设计　　69226.1 　移动网络通信应用的分层架构设计　　69226.2 　objective-c版本：在数据持久层中添加和配置afnetworking　　69326.2.1 　用cocoapods工具管理依赖　　69326.2.2 　测试依赖　　69326.3 　swift版本：在数据持久层中添加和配置alamofire　　69426.3.1 　用carthage工具管理依赖　　69426.3.2 　测试依赖　　69526.4 　基于委托模式实现　　69526.4.1 　网络通信与委托模式　　69626.4.2 　在异步网络通信中使用委托模式实现分层架构设计　　69626.4.3 　类图　　69726.4.4 　时序图　　69926.4.5 　数据持久层重构（objective-c版本）　　70226.4.6 　数据持久层重构（swift版本）　　70526.4.7 　业务逻辑层的代码实现　　70726.4.8 　表示层的代码实现　　71026.5 　基于观察者模式的通知机制实现　　71626.5.1 　观察者模式的通知机制回顾　　71626.5.2 　异步网络通信中通知机制的分层架构设计　　71626.5.3 　类图　　71726.5.4 　时序图　　71926.5.5 　数据持久层重构（objective-c版本）　　72226.5.6 　数据持久层重构（swift版本）　　72326.5.7 　业务逻辑层的代码实现　　72526.5.8 　表示层的代码实现　　72626.6 　小结　　731第27章　把你的应用放到app store上　　73227.1 　收官　　73227.1.1 　在xcode 中添加图标　　73227.1.2 　在xcode中添加启动界面　　73427.1.3 　调整identity和deployment info属性　　73827.2 　为发布进行编译　　73927.2.1 　创建开发者证书　　73927.2.2 　创建app id　　74427.2.3 　创建描述文件　　74527.2.4 　发布编译　　74827.3 　发布上架　　75027.3.1 　创建应用　　75027.3.2 　应用定价　　75327.3.3 　基本信息输入　　75427.3.4 　上传应用　　75727.3.5 　提交审核　　75927.4 　常见审核不通过的原因　　76127.4.1 　功能问题　　76127.4.2 　用户界面问题　　76127.4.3 　商业问题　　76127.4.4 　不当内容　　76127.4.5 　其他问题　　76227.5 　小结　　762第28章　ios敏捷开发项目实战——2016里约热内卢奥运会应用开发及appstore发布　　76328.1 　应用分析与设计　　76328.1.1 　应用概述　　76328.1.2 　需求分析　　76328.1.3 　原型设计　　76428.1.4 　数据库设计　　76528.1.5 　架构设计　　76628.2 　ios敏捷开发　　76628.2.1 　敏捷开发宣言　　76628.2.2 　ios适合敏捷开发？　　76728.2.3 　ios敏捷开发*佳实践　　76728.3 　任务1：创建应用工作空间和工程　　76928.3.1 　迭代1.1：创建工作空间　　76928.3.2 　迭代1.2：发布到github　　76928.4 　任务2：信息系统层与持久层开发　　77028.4.1 　迭代2.1：编写数据库ddl脚本　　77028.4.2 　迭代2.2：插入初始数据到数据库　　77028.4.3 　迭代2.3：数据库版本控制　　77128.4.4 　迭代2.4：配置持久层工程persistencelayer　　77128.4.5 　迭代2.5：编写实体类　　77228.4.6 　迭代2.6：编写dao类单元测试用例类　　77328.4.7 　迭代2.7：编写dao类　　77528.4.8 　迭代2.8：数据库帮助类dbhelper　　77928.4.9 　迭代2.9：配置及运行持久层测试用例目标　　78128.4.10 　迭代2.10：发布到github　　78228.5 　任务3：业务逻辑层开发　　78228.5.1 　迭代3.1：比赛项目业务逻辑类xctest单元测试　　78328.5.2 　迭代3.2：编写比赛项目业务逻辑类　　78428.5.3 　迭代3.3：比赛日程业务逻辑类xctest单元测试　　78528.5.4 　迭代3.4：编写比赛日程业务逻辑类　　78628.5.5 　迭代3.5：发布到github　　78728.6 　任务4：表示层开发　　78828.6.1 　迭代4.1：使用资源目录管理图片和图标资源　　78828.6.2 　迭代4.2：根据原型设计初步设计故事板　　78928.6.3 　迭代4.3：“首页”模块　　79028.6.4 　迭代4.4：“比赛项目”模块　　79128.6.5 　迭代4.5：“比赛日程”模块　　79528.6.6 　迭代4.6：“倒计时”模块表示层　　79728.6.7 　迭代4.7：“关于我们”模块表示层　　80028.6.8 　迭代4.8：发布到github　　80028.7 　任务5：收工　　80028.7.1 　迭代5.1：添加图标　　80028.7.2 　迭代5.2：设计和添加启动界面　　80128.7.3 　迭代5.3：性能测试与改善　　80128.7.4 　迭代5.4：发布到github上　　80228.7.5 　迭代5.5：在app store上发布应用　　80228.8 　小结　　802 
