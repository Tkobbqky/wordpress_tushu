Java Persistence with Hibernate_Hibernate实战(第2版) PDF下载 （德）鲍尔 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711517448
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711517448
<p>书名:Java Persistence with Hibernate_Hibernate实战(第2版)</p><p>作者:（德）鲍尔</p><p>页数:608</p><p>定价:¥99.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2008-04-01</p><p>ISBN:9787115174482</p><p><h2>相关资料</h2></p>[<p>“Hibernate对Java Persistence乃至EJB　3.0的技术方向产生了巨大影响……本书必将成为广大开发人员的知识宝库。” <br/>　　　　　　　　　——Linda Demichiel，Sun公司EJB 3.0和Java Persistence标准负责人 <br/>　　“本书是终极解决方案。如果你是Hibernate开发人员，不要犹豫了，到书店去，买上一本！” <br/>　　　　　　　　　　　　　　　　　　　　　　　　　——JavaLobby</p>]<p><h2>本书特色</h2></p>[<p>
Hibernate之父亲自执笔，无可替代的Hibernate和ORM技术圣经，职业Java程序员**秘籍。<br/>持久化是现代企业级应用的核心特性。作为Java世界*流行的持久化框架，Hibernate已经成为开发Java EE应用系统中不可替代的支柱之一。随着EJB 3.0和Java Persistence标准的发布，Hibernate也迎来了更加成熟的新版本——Hibernate 3.2。新版本实现了Java Persistence标准，既可以用于流行的开源技术组合（如Spring、Struts和Seam等）。也可以与其他EJB 3.0组件和Java EE服务集成。<br/>本书是毋庸置疑的Hibernate和ORM（对象/关系映射）权威著作，由包括Hibernate之父在内的两位核心开发人员亲自执笔，详细讲述了Hibernate 3.2、Java Persistence和EJB 3.0标准。<br/>本书通过一个应用将数百个例子融合起来，不仅深入剖析了Hibernate 3.2和Java Persistence丰富的编程模型。还深刻阐述了数据库设计、ORM和优化等方面的基本原则、策略和*佳实践。书中处处闪烁着作者超凡的真知灼见，将大大升华读者对ORM乃至企业级应用开发的理解。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书全面讲述了Hibernate和Java Persistence，并对两者进行了详细的对比分析。书中通过一个应用将数百个例子融合起来，不仅深入剖析了Hibernate 3.2和Java Persistence丰富的编程模型，还深刻阐述了数据库设计、对象/关系映射（ORM）和优化等方面的基本原则、策略和*佳实践。书中处处闪烁着作者超凡的真知灼见，将大大升华读者对ORM乃至企业级应用开发的理解。<br/>　　本书适合广大的开发人员，从ORM的初学者到经验丰富的开发人员。</p>]<p><h2>作者简介</h2></p>[<p>Christian Bauer，Hibernate核心开发人员，并负责维护Hibernate的文档与网站。目前他是Red Hat公司JBoss部门负责Hibernate、EJB 3.0和Seam的产品经理。</p>]<p><h2>目录</h2></p>
    **部分 从Hibernate和EJB 3.0开始　第1章 理解对象/关系持久化　　　1.1 什么是持久化　　　　1.1.1 关系数据库　　　　1.1.2 理解SQL　　　　1.1.3 在Java中使用SQL　　　　1.1.4 面向对象应用程序中的持久化　　　1.2 范式不匹配　　　　1.2.1 粒度问题　　　　1.2.2 子类型问题　　　　1.2.3 同一性问题　　　　1.2.4 与关联相关的问题　　　　1.2.5 数据导航的问题　　　　1.2.6 不匹配的代价　　　1.3 持久层和其他层　　　　1.3.1 分层架构　　　　1.3.2 用SQL/JDBC手工编写持久层　　　　1.3.3 使用序列化　　　　1.3.4 面向对象的数据库系统　　　　1.3.5 其他选项　　　1.4 ORM　　　　1.4.1 什么是ORM　　　　1.4.2 一般的ORM问题　　　　1.4.3 为什么选择ORM　　　　1.4.4 Hibernate、EJB 3和JPA简介　　　1.5 小结　　第2章 启动项目　　　2.1 启动Hibernate项目　　　　2.1.1 选择开发过程　　　　2.1.2 建立项目　　　　2.1.3 Hibernate配置和启动　　　　2.1.4 运行和测试应用程序　　　2.2 启动Java Persistence项目　　　　2.2.1 使用Hibernate Annotations　　　　2.2.2 使用Hibernate EntityManager　　　　2.2.3 引入EJB组件　　　　2.2.4 切换到Hibernate接口　　　2.3 反向工程遗留数据库　　　　2.3.1 创建数据库配置　　　　2.3.2 定制反向工程　　　　2.3.3 生成Java源代码　　　2.4 与Java EE服务整合　　　　2.4.1 与JTA整合　　　　2.4.2 JNDI绑定的SessionFactory　　　　2.4.3 JMX服务部署　　　2.5 小结　　第3章 领域模型和元数据　　　3.1 CaveatEmptor应用程序　　　　3.1.1 分析业务领域　　　　3.1.2 CaveatEmptor领域模型　　　3.2 实现领域模型　　　　3.2.1 处理关注点渗漏　　　　3.2.2 透明和自动持久化　　　　3.2.3 编写POJO和持久化实体类　　　　3.2.4 实现POJO关联　　　　3.2.5 把逻辑添加到访问方法　　　3.3 ORM元数据　　　　3.3.1 XML中的元数据　　　　3.3.2 基于注解的元数据　　　　3.3.3 使用XDoclet　　　　3.3.4 处理全局的元数据　　　　3.3.5 运行时操作元数据　　　3.4 其他实体表示法　　　　3.4.1 创建动态的应用程序　　　　3.4.2 表示XML中的数据　　　3.5 小结　第二部分　映射概念和策略　第4章 映射持久化类　　　4.1 理解实体和值类型　　　　4.1.1 细粒度的领域模型　　　　4.1.2 定义概念　　　　4.1.3 识别实体和值类型　　　4.2 映射带有同一性的实体　　　　4.2.1 理解Java同一性和等同性　　　　4.2.2 处理数据库同一性　　　　4.2.3 数据库主键　　　4.3 类映射选项　　　　4.3.1 动态的SQL生成　　　　4.3.2 使实体不可变　　　　4.3.3 给查询命名实体　　　　4.3.4 声明包名称　　　　4.3.5 用引号把SQL标识符括起来　　　　4.3.6 实现命名约定　　　4.4 细粒度的模型和映射　　　　4.4.1 映射基础属性　　　　4.4.2 映射组件　　　4.5 小结　　第5章 继承和定制类型　　　5.1 映射类继承　　　　5.1.1 每个带有隐式多态的具体类一张表　　　　5.1.2 每个带有联合的具体类一张表　　　　5.1.3 每个类层次结构一张表　　　　5.1.4 每个子类一张表　　　　5.1.5 混合继承策略　　　　5.1.6 选择策略　　　5.2 Hibernate类型系统　　　　5.2.1 概述实体和值类型　　　　5.2.2 内建的映射类型　　　　5.2.3 使用映射类型　　　5.3 创建定制的映射类型　　　　5.3.1 考虑定制的映射类型　　　　5.3.2 扩展点　　　　5.3.3 定制映射类型的案例　　　　5.3.4 创建UserType　　　　5.3.5 创建CompositeUserType　　　　5.3.6 参数化定制类型　　　　5.3.7 映射枚举　　　5.4 小结　　第6章 映射集合和实体关联　　　6.1 值类型的set、bag、list和map　　　　6.1.1 选择集合接口　　　　6.1.2 映射set　　　　6.1.3 映射标识符bag　　　　6.1.4 映射list　　　　6.1.5 映射map　　　　6.1.6 排序集合和有序集合　6.2 组件的集合　　　　6.2.1 编写组件类　　　　6.2.2 映射集合　　　　6.2.3 启用双向导航　　　　6.2.4 避免非空列　　　6.3 用注解映射集合　　　　6.3.1 基本的集合映射　　　　6.3.2 排序集合和有序集合　　　　6.3.3 映射嵌入式对象的集合　　　6.4 映射父/子关系　　　　6.4.1 多样性　　　　6.4.2 *简单的可能关联　　　　6.4.3 使关联双向　　　　6.4.4 级联对象状态　　　6.5 小结　　第7章 高级实体关联映射　　　7.1 单值的实体关联　　　　7.1.1 共享的主键关联　　　　7.1.2 一对一的外键关联　　　　7.1.3 用联结表映射　　　7.2 多值的实体关联　　　　7.2.1 一对多关联　　　　7.2.2 多对多关联　　　　7.2.3 把列添加到联结表　　　　7.2.4 映射map　　　7.3 多态关联　　　　7.3.1 多态的多对一关联　　　　7.3.2 多态集合　　　　7.3.3 对联合的多态关联　　　　7.3.4 每个具体类一张多态表　　　7.4 小结　　第8章 遗留数据库和定制SQL　　　8.1 整合遗留数据库　　　　8.1.1 处理主键　　　　8.1.2 带有公式的任意联结条件　　　　8.1.3 联结任意的表　　　　8.1.4 使用触发器　　　8.2 定制SQL　　　　8.2.1 编写定制CRUD语句　　　　8.2.2 整合存储过程和函数　　　8.3 改进Schema DDL　　　　8.3.1 定制SQL名称和数据类型　　　　8.3.2 确保数据一致性　　　　8.3.3 添加领域约束和列约束　　　　8.3.4 表级约束　　　　8.3.5 数据库约束　　　　8.3.6 创建索引　　　　8.3.7 添加辅助的DDL　　　8.4 小结　第三部分　会话对象处理　第9章 使用对象　　　9.1 持久化生命周期　　　　9.1.1 对象状态　　　　9.1.2 持久化上下文　　　9.2 对象同一性和等同性　　　　9.2.1 引入对话　　　　9.2.2 对象同一性的范围　　　　9.2.3 脱管对象的同一性　　　　9.2.4 扩展持久化上下文　　　9.3 Hibernate接口　　　　9.3.1 保存和加载对象　　　　9.3.2 使用脱管对象　　　　9.3.3 管理持久化上下文　　　9.4 JPA　　　　9.4.1 保存和加载对象　　　　9.4.2 使用脱管的实体实例　　　9.5 在EJB组件中使用Java Persistence　　　　9.5.1 注入EntityManager　　　　9.5.2 查找EntityManager　　　　9.5.3 访问EntityManagerFactory　　　9.6 小结　　第10章 事务和并发　　　10.1 事务本质　　　　10.1.1 数据库和系统事务　　　　10.1.2 Hibernate应用程序中的事务　　　　10.1.3 使用Java Persistence的事务　　　10.2 控制并发访问　　　　10.2.1 理解数据库级并发　　　　10.2.2 乐观并发控制　　　　10.2.3 获得额外的隔离性保证　　　10.3 非事务数据访问　　　　10.3.1 揭开自动提交的神秘面纱　　　　10.3.2 使用Hibernate非事务地工作　　　　10.3.3 使用JTA的可选事务　　　10.4 小结　　第11章 实现对话　　　11.1 传播Hibernate Session　　　　11.1.1 Session传播的用例　　　　11.1.2 通过线程局部传播　　　　11.1.3 利用JTA传播　　　　11.1.4 利用EJB传播　　　11.2 利用Hibernate的对话　　　　11.2.1 提供对话保证　　　　11.2.2 利用脱管对象的对话　　　　11.2.3 给对话扩展Session　　　11.3 使用JPA的对话　　　　11.3.1 Java SE中的持久化上下文传播　　　　11.3.2 在对话中合并脱管对象　　　　11.3.3 在Java SE中扩展持久化上下文　　　11.4 使用EJB 3.0的对话　　　　11.4.1 使用EJB的上下文传播　　　　11.4.2 利用EJB扩展持久化上下文　　　11.5 小结　　第12章 有效修改对象　　　12.1 传播性持久化　　　　12.1.1 按可到达性持久化　　　　12.1.2 把级联应用到关联　　　　12.1.3 使用传播性状态　　　　12.1.4 利用JPA的传播性关联　　　12.2 大批量和批量操作　　　　12.2.1 使用HQL和JPA QL的大批量语句　　　　12.2.2 利用批量处理　　　　12.2.3 使用无状态的会话　　　12.3 数据过滤和拦截　　　　12.3.1 动态数据过滤　　　　12.3.2 拦截Hibernate事件　　　　12.3.3 内核事件系统　　　　12.3.4 实体监听器和回调　　　12.4 小结　　第13章 优化抓取和高速缓存　　　13.1 定义全局抓取计划　　　　13.1.1 对象获取选项　　　　13.1.2 延迟的默认抓取计划　　　　13.1.3 理解代理　　　　13.1.4 禁用代理生成　　　　13.1.5 关联和集合的即时加载　　　　13.1.6 通过拦截延迟加载　　　13.2 选择抓取策略　　　　13.2.1 批量预抓取数据　　　　13.2.2 通过子查询预抓取集合　　　　13.2.3 通过联结即时抓取　　　　13.2.4 给二级表优化抓取　　　　13.2.5 优化指导方针　　　13.3 高速缓存基本原理　　　　13.3.1 高速缓存策略和范围　　　　13.3.2 Hibernate高速缓存架构　　　13.4 高速缓存实践　　　　13.4.1 选择并发控制策略　　　　13.4.2 理解高速缓存区域　　　　13.4.3 设置本地的高速缓存提供程序　　　　13.4.4 设置重复的高速缓存　　　　13.4.5 控制二级高速缓存　　　13.5 小结　　第14章 利用HQL和JPA QL查询　　　14.1 创建和运行查询　　　　14.1.1 准备查询　　　　14.1.2 执行查询　　　　14.1.3 使用具名查询　　　14.2 基本的HQL和JPA QL查询　　　　14.2.1 选择　　　　14.2.2 限制　　　　14.2.3 投影　　　14.3 联结、报表查询和子查询　　　　14.3.1 联结关系和关联　　　　14.3.2 报表查询　　　　14.3.3 利用子查询　　　14.4 小结　　第15章 高级查询选项　　　15.1 利用条件和示例查询　　　　15.1.1 基本的条件查询　　　　15.1.2 联结和动态抓取　　　　15.1.3 投影和报表查询　　　　15.1.4 按示例查询　　　15.2 利用原生的SQL查询　　　　15.2.1 自动的结果集处理　　　　15.2.2 获取标量值　　　　15.2.3 Java Persistence中的原生SQL　　　15.3 过滤集合　　　15.4 高速缓存查询结果　　　　15.4.1 启用查询结果高速缓存　　　　15.4.2 理解查询高速缓存　　　　15.4.3 什么时候使用查询高速缓存　　　　15.4.4 自然标识符高速缓存查找　　　15.5 小结　　第16章 创建和测试分层的应用程序　　　16.1 Web应用程序中的Hibernate　　　　16.1.1 用例简介　　　　16.1.2 编写控制器　　　　16.1.3 OSIV模式　　　　16.1.4 设计巧妙的领域模型　　　16.2 创建持久层　　　　16.2.1 泛型的数据访问对象模式　　　　16.2.2 实现泛型CRUD接口　　　　16.2.3 实现实体DAO　　　　16.2.4 利用数据访问对象　　　16.3 命令模式简介　　　　16.3.1 基础接口　　　　16.3.2 执行命令对象　　　　16.3.3 命令模式的变形　　　16.4 利用EJB 3.0设计应用程序　　　　16.4.1 利用有状态的bean实现会话　　　　16.4.2 利用EJB编写DAO　　　　16.4.3 利用依赖注入　　　16.5 测试　　　　16.5.1 理解不同种类的测试　　　　16.5.2 TestNG简介　　　　16.5.3 测试持久层　　　　16.5.4 考虑性能基准　　　16.6 小结　　第17章 JBoss Seam简介　　　17.1 Java EE 5.0编程模型　　　　17.1.1 JSF详解　　　　17.1.2 EJB 3.0详解　　　　17.1.3 用JSF和EJB 3.0编写Web应用程序　　　　17.1.4 分析应用程序　　　17.2 用Seam改善应用程序　　　　17.2.1 配置Seam　　　　17.2.2 将页面绑定到有状态的Seam组件　　　　17.2.3 分析Seam应用程序　　　17.3 理解上下文组件　　　　17.3.1 编写登录页面　　　　17.3.2 创建组件　　　　17.3.3 给上下文变量起别名　　　　17.3.4 完成登录/注销特性　　　17.4 验证用户输入　　　　17.4.1 Hibernate Validator简介　　　　17.4.2 创建注册页面　　　　17.4.3 用Seam实现国际化　　　17.5 利用Seam简化持久化　　　　17.5.1 实现对话　　　　17.5.2 让Seam管理持久化上下文　　　17.6 小结　附录A SQL基础知识　附录B 映射快速参考
