Linux二进制分析 PDF下载 瑞安.奥尼尔 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546923
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546923
<p>书名:Linux二进制分析</p><p>作者:瑞安.奥尼尔</p><p>页数:254</p><p>定价:¥59.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-12-01</p><p>ISBN:9787115469236</p><p><h2>本书特色</h2></p>[<p>
二进制分析属于信息安全业界逆向工程中的一种技术，通过利用可执行的机器代码（二进制）来分析应用程序的控制结构和运行方式，有助于信息安全从业人员更好地分析各种漏洞、病毒以及恶意软件，从而找到相应的解决方案。
《Linux二进制分析》是一本剖析Linux ELF工作机制的图书，共分为9章，其内容涵盖了Linux环境和相关工具、ELF二进制格式、Linux进程追踪、ELF病毒技术、Linux二进制保护、Linux中的ELF二进制取证分析、进程内存取证分析、扩展核心文件快照技术、Linux proc kcore分析等。
《Linux二进制分析》适合具有一定的Linux操作知识，且了解C语言编程技巧的信息安全从业人员阅读。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书首先讲解了UNIX Linux中分析目标文件的实用工具和ELF二进制格式的相关内容，随后介绍了进程追踪、各种不同类型的Linux和UNIX病毒，以及如何使用ELF病毒技术进行处理。
本书的后半部分介绍了如何使用Kprobe工具进行内核破解、代码修补和调试，如何检测并处理内核模式的rootkit，以及如何分析静态代码；对复杂的用户级内存感染分析进行了相关讲解。
本书将带领读者探索甚至连一些专家都未曾接触的领域，正式进入计算机黑客世界。
本书读者对象
如果你是一名软件工程师或者逆向工程师，想要学习Linux二进制分析相关的内容，本书实为明智之选。本书提供了在安全、取证和杀毒领域中实施二进制分析的解决方案。本书也适合安全爱好者和系统工程师阅读。为了更好地理解本书内容，读者需要具备一定的C语言编程基础和Linux命令行知识。
本书内容
ELF二进制格式的内部工作原理；
UNIX病毒感染和分析的相关技术；
二进制加固和软件防篡改技术；
修补可执行文件和进程内存；
绕过恶意软件中的反调试；
二进制取证分析技术；
用C语言设计ELF相关的工具；
如何使用ptrace操作内存。
本书源码可通过www.epubit.com.cn book details 4696下载。 </p>]<p><h2>作者简介</h2></p>[<p>Ryan O'Neill（ELF大师）是一名计算机安全研究员兼软件工程师，具有逆向工程、软件开发、安全防御和取证分析技术方面的背景。他是在计算机黑客亚文化的世界中成长起来的——那个由EFnet、BBS系统以及系统可执行栈上的远程缓冲区溢出组成的世界。他在年轻时就接触了系统安全、开发和病毒编写等领域。他对计算机黑客的极大热情如今已经演变成了对软件开发和专业安全研究的热爱。Ryan在DEFCON和RuxCon等很多计算机安全会议上发表过演讲，还举办了一个为期两天的ELF二进制黑客研讨会。
他的职业生涯非常成功，曾就职于Pikewerks、Leviathan安全集团这样的大公司，最近在Backtrace担任软件工程师。
Ryan还未出版过其他图书，不过他在Phrack和VXHeaven这样的在线期刊上发表的论文让他声名远扬。还有许多其他的作品可以从他的网站（http:  www.bitlackeys.org）上找到。</p>]<p><h2>目录</h2></p>
    第1章  Linux环境和相关工具	1
1.1  Linux工具	1
1.1.1  GDB	2
1.1.2  GNU binutils中的objdump	2
1.1.3  GNU binutils中的objcopy	3
1.1.4  strace	3
1.1.5  ltrace	4
1.1.6  基本的ltrace命令	4
1.1.7  ftrace	4
1.1.8  readelf	4
1.1.9  ERESI——ELF反编译系统接口	5
1.2  有用的设备和文件	6
1.2.1   procmaps	6
1.2.2   proc kcore	6
1.2.3   boot System.map	6
1.2.4   proc kallsyms	7
1.2.5   proc iomem	7
1.2.6  ECFS	7
1.3  链接器相关环境指针	7
1.3.1  LD_PRELOAD环境变量	8
1.3.2  LD_SHOW_AUXV环境变量	8
1.3.3  链接器脚本	9
1.4  总结	10

第2章  ELF二进制格式	11
2.1  ELF文件类型	12
2.2  ELF程序头	14
2.2.1  PT_LOAD	14
2.2.2  PT_DYNAMIC——动态段的Phdr	15
2.2.3  PT_NOTE	17
2.2.4  PT_INTERP	17
2.2.5  PT_PHDR	17
2.3  ELF节头	18
2.3.1  .text节	20
2.3.2  .rodata节	20
2.3.3  .plt节	21
2.3.4  .data节	21
2.3.5  .bss节	21
2.3.6  .got.plt节	21
2.3.7  .dynsym节	21
2.3.8  .dynstr节	22
2.3.9  .rel.*节	22
2.3.10  .hash节	22
2.3.11  .symtab节	22
2.3.12  .strtab节	23
2.3.13  .shstrtab节	23
2.3.14  .ctors和.dtors节	23
2.4  ELF符号	27
2.4.1  st_name	28
2.4.2  st_value	28
2.4.3  st_size	28
2.4.4  st_other	28
2.4.5  st_shndx	29
2.4.6  st_info	29
2.5  ELF重定位	34
2.6  ELF动态链接	43
2.6.1  辅助向量	44
2.6.2  了解PLT GOT	46
2.6.3  重温动态段	49
2.7  编码一个ELF解析器	52
2.8  总结	55

第3章  Linux进程追踪	57
3.1  ptrace的重要性	57
3.2  ptrace请求	58
3.3  进程寄存器状态和标记	60
3.4  基于ptrace的调试器示例	61
3.5  ptrace调试器	67
3.6  高级函数追踪软件	75
3.7  ptrace和取证分析	75
3.8  进程镜像重建	77
3.8.1  重建进程到可执行文件的挑战	78
3.8.2  重建可执行文件的挑战	78
3.8.3  添加节头表	79
3.8.4  重建过程算法	79
3.8.5  在32位测试环境中使用Quenya重建进程	81
3.9  使用ptrace进行代码注入	83
3.10  简单的例子演示复杂的过程	91
3.11  code_inject工具演示	92
3.12  ptrace反调试技巧	92
3.13  总结	94

第4章  ELF病毒技术——Linux UNIX病毒	95
4.1  ELF病毒技术	96
4.2  设计ELF病毒面临的挑战	97
4.2.1  寄生代码必须是独立的	97
4.2.2  字符串存储的复杂度	99
4.2.3  寻找存放寄生代码的合理空间	100
4.2.4  将执行控制流传给寄生代码	100
4.3  ELF病毒寄生代码感染方法	101
4.3.1  Silvio填充感染	101
4.3.2  逆向text感染	106
4.3.3  data段感染	108
4.4  PT_NOTE到PT_LOAD转换感染	110
4.5  感染控制流	112
4.5.1  直接PLT感染	113
4.5.2  函数蹦床（function trampolines）	113
4.5.3  重写.ctors .dtors函数指针	114
4.5.4  GOT感染或PLT GOT重定向	115
4.5.5  感染数据结构	115
4.5.6  函数指针重写	115
4.6  进程内存病毒和rootkits——远程代码注入技术	115
4.6.1  共享库注入	116
4.6.2  text段代码注入	120
4.6.3  可执行文件注入	120
4.6.4  重定位代码注入——ET_REL注入	120
4.7  ELF反调试和封装技术	121
4.7.1  PTRACE_TRACEME技术	121
4.7.2  SIGTRAP处理技术	122
4.7.3   proc self status技术	122
4.7.4  代码混淆技术	123
4.7.5  字符串表转换技术	124
4.8  ELF病毒检测和杀毒	124
4.9  总结	126

第5章  Linux二进制保护	127
5.1  ELF二进制加壳器	127
5.2  存根机制和用户层执行	128
5.3  保护器存根的其他用途	133
5.4  现存的ELF二进制保护器	133
5.4.1  DacryFile——Grugq于2001年发布	134
5.4.2  Burneye——Scut于2002年发布	134
5.4.3  Shiva——Neil Mehta和Shawn Clowes于2003年发布	135
5.4.4  May's Veil——Ryan O'Neill于2014年发布	136
5.5  下载Maya保护的二进制文件	142
5.6  二进制保护中的反调试	142
5.7  防模拟技术	143
5.7.1  通过系统调用检测模拟	144
5.7.2  检测模拟的CPU不一致	144
5.7.3  检测特定指令之间的时延	144
5.8  混淆方法	145
5.9  保护控制流完整性	145
5.9.1  基于ptrace的攻击	145
5.9.2  基于安全漏洞的攻击	146
5.10  其他资源	147
5.11  总结	147

第6章  Linux下的ELF二进制取证分析	149
6.1  检测入口点修改技术	150
6.2  检测其他形式的控制流劫持	154
6.2.1  修改.ctors .init_array节	154
6.2.2  检测PLT GOT钩子	155
6.2.3  检测函数蹦床	158
6.3  识别寄生代码特征	159
6.4  检查动态段是否被DLL注入	161
6.5  识别逆向text填充感染	164
6.6  识别text段填充感染	166
6.7  识别被保护的二进制文件	170
6.8  IDA Pro	175
6.9  总结	175

第7章  进程内存取证分析	177
7.1  进程内存布局	178
7.1.1  可执行文件内存映射	179
7.1.2  程序堆	179
7.1.3  共享库映射	180
7.1.4  栈、VDSO和vsyscall	180
7.2  进程内存感染	181
7.2.1  进程感染工具	181
7.2.2  进程感染技术	182
7.3  检测ET_DYN注入	184
7.3.1  Azazel：用户级rootkit检测	184
7.3.2  映射出进程的地址空间	184
7.3.3  查找栈中的LD_PRELOAD	187
7.3.4  检测PLT GOT钩子	188
7.3.5  ET_DYN注入内部原理	190
7.3.6  操纵VDSO	194
7.3.7  共享目标文件加载	195
7.3.8  检测.so注入的启发方法	196
7.3.9  检测PLT GOT钩子的工具	197
7.4  Linux ELF核心文件	198
7.5  总结	204

第8章  ECFS——扩展核心文件快照技术	205
8.1  历史	205
8.2  ECFS原理	206
8.3  ECFS入门	206
8.3.1  将ECFS嵌入到核心处理器中	207
8.3.2  在不终止进程的情况下使用ECFS快照	208
8.4  libecfs——解析ECFS文件的库	208
8.5  readecfs工具	209
8.6  使用ECFS检测被感染的进程	210
8.6.1  感染主机进程	210
8.6.2  捕获并分析ECFS快照	211
8.6.3  使用readecfs提取寄生代码	215
8.6.4  Azazel用户级rootkit分析	216
8.7  ECFS参考指南	224
8.7.1  ECFS符号表重建	225
8.7.2  ECFS节头	226
8.7.3  使用ECFS文件作为常规的核心文件	229
8.7.4  libecfs API的使用	229
8.8  使用ECFS恢复中断的进程	230
8.9  了解更多ECFS相关内容	231
8.10  总结	232

第9章  Linux proc kcore分析	233
9.1  Linux内核取证分析和rootkit	233
9.2  没有符号的备份vmlinux	234
9.3  探索 proc kcore和GDB	236
9.4  直接修改sys_call_table	237
9.4.1  检测sys_call_table修改	238
9.4.2  内核函数蹦床	238
9.4.3  函数蹦床示例	239
9.4.4  检测函数蹦床	241
9.4.5  检测中断处理器修复	243
9.5  Kprobe rootkit	243
9.6  调试寄存器rootkit——DRR	244
9.7  VFS层rootkit	244
9.8  其他内核感染技术	245
9.9  vmlinux和.altinstructions修补	245
9.9.1  .altinstructions和.altinstr_replace	246
9.9.2  arch x86 include asm alternative.h代码片段	246
9.9.3  使用textify验证内核代码完整性	247
9.9.4  使用textify检查sys_call_table	247
9.10  使用taskverse查看隐藏进程	248
9.11  感染的LKM——内核驱动	249
9.11.1  方法一：感染LKM文件——符号劫持	249
9.11.2  方法二：感染LKM文件——函数劫持	249
9.11.3  检测被感染的LKM	250
9.12   dev kmem和 dev mem	250
9.12.1   dev mem	251
9.12.2  FreeBSD  dev kmem	251
9.13  K-ecfs ——内核ECFS	251
9.14  内核黑客工具	252
9.14.1  通用的逆向工程和调试	253
9.14.2  高级内核劫持 调试接口	253
9.14.3  本章提到的论文	253
9.15  总结	254
