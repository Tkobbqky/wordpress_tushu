C++ Templates 中文版 PDF下载 范德沃德 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711531281
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711531281
<p>书名:C++ Templates 中文版</p><p>作者:范德沃德</p><p>页数:497</p><p>定价:¥89.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2013-04-01</p><p>ISBN:9787115312815</p><p><h2>相关资料</h2></p>[<p>
                                    
                                        如果今年你只打算买一本c++的书，那就选这本吧！ ——josh walker，accu成员 c++世界期待已久的重量级著作。
——marc briand, c/c++ users journal前任总编一句话，模板圣经已经写就，请研习。 ——maxim
khesin, cvision technologies, llc                                    </p>]<p><h2>本书特色</h2></p>[<p>
　　《c++
templates中文版》是c++模板编程的完全指南，旨在通过基本概念、常用技巧和应用实例三方面的有用资料，为读者打下c++模板知识的坚实基础。　　全书共22章。第1章全面介绍了《c++
templates中文版》的内容结构和相关情况。第1部分(第2～7章)以教程的风格介绍了模板的基本概念，第2部分(第8～13章)阐述了模板的语言细节，第3部分(第14～18章)介绍了c++模板所支持的基本设计技术，第4部分(第19～22章)深入探讨了各种使用模板的普通应用程序。附录a和附录b分别为一处定义原则和重载解析的相关资料。　　《c++
templates中文版》适合c++模板技术的初学者阅读，也可供有一定编程经验的c++程序员参考。
                                        </p>]<p><h2>内容简介</h2></p>[<p>　　详细讲解c++模板语言的概念。
　　使用c++模板的常用设计技巧。
　　应用例证（其中一些是“高级”应用）。</p>]<p><h2>作者简介</h2></p>[<p>David Vandevoorde 有20多年的C++工作经验，C++标准委员会成员。曾因为审校The C++
Programming Language一书的草稿，获得Bjarne Stroustrup的推荐，编写了C++ Solutions。
Nicolai M. Josuttis The C++ Standard Library - A Tutorial and
Reference（中文版名为《C++标准库》）的作者，这本书出版以后成为实际上的标准读本。</p>]<p><h2>目录</h2></p>
第1章 关于本章1.1 阅读本书所需具备的知识1.2 本书的整体结构1.3 如何阅读本书1.4 关于编程风格的一些说明1.5 标准和现实1.6 代码例子和更多信息1.7 反馈第1部分 基础第2章 函数模板2.1 初探函数模板2.1.1 定义模板2.1.2 使用模板2.2 实参的演绎(deduction)2.3 模板参数2.4 重载函数模板2.5 小结第3章 类模板3.1 类模板stack的实现3.1.1 类模板的声明3.1.2 成员函数的实现3.2 类模板stack的使用3.3 类模板的特化3.4 局部特化3.5 缺省模板实参3.6 小结第4章 非类型模板参数4.1 非类型的类模板参数4.2 非类型的函数模板参数4.3 非类型模板参数的限制4.4 小结第5章 技巧性基础知识5.1 关键字typename5.2 使用this->5.3 成员模板5.4 模板的模板参数5.5 零初始化5.6 使用字符串作为函数模板的实参5.7 小结第6章 模板实战6.1 包含模型6.1.1 链接器错误6.1.2 头文件中的模板6.2 显式实例化6.2.1 显式实例化的例子6.2.2 整合包含模型和显式实例化6.3 分离模型6.3.1 关键字export6.3.2 分离模型的限制6.3.3 为分离模型做好准备6.4 模板和内联6.5 预编译头文件6.6 调试模板6.6.1 理解长段的错误信息6.6.2 浅式实例化6.6.3 长符号串6.6.4 跟踪程序6.6.5 oracles6.6.6 archetypes6.7 本章后记6.8 小结第7章 模板术语7.1 "类模板"还是"模板类"7.2 实例化和特化7.3 声明和定义7.4 一处定义原则7.5 模板实参和模板参数第2部分 深入模板第8章 深入模板基础8.1 参数化声明8.1.1 虚成员函数8.1.2 模板的链接8.1.3 基本模板8.2 模板参数8.2.1 类型参数8.2.2 非类型参数8.2.3 模板的模板参数8.2.4 缺省模板实参8.3 模板实参8.3.1 函数模板实参8.3.2 类型实参8.3.3 非类型实参8.3.4 模板的模板实参8.3.5 实参的等价性8.4 友元8.4.1 友元函数8.4.2 友元模板8.5 本章后记第9章 模板中的名称9.1 名称的分类9.2 名称查找9.2.1 argument-dependent lookup(adl)9.2.2 友元名称插入9.2.3 插入式类名称9.3 解析模板9.3.1 非模板中的上下文相关性9.3.2 依赖型类型名称9.3.3 依赖型模板名称9.3.4 using-declaration中的依赖型名称9.3.5 adl和显式模板实参9.4 派生和类模板9.4.1 非依赖型基类9.4.2 依赖型基类9.5 本章后记第10章 实例化10.1 on-demand实例化10.2 延迟实例化10.3 c++的实例化模型10.3.1 两阶段查找10.3.2 poi10.3.3 包含模型与分离模型10.3.4 跨翻译单元查找10.3.5 例子10.4 几种实现方案10.4.1 贪婪实例化10.4.2 询问实例化10.4.3 迭代实例化10.5 显式实例化10.6 本章后记第11章 模板实参演译11.1 演绎的过程11.2 演绎的上下文11.3 特殊的演绎情况11.4 可接受的实参转型11.5 类模板参数11.6 缺省调用实参11.7 barton-nackman方法11.8 本章后记第12章 特化与重载12.1 当泛型代码不再适用的时候12.1.1 透明自定义12.1.2 语义的透明性12.2 重载函数模板12.2.1 签名12.2.2 重载的函数模板的局部排序12.2.3 正式的排序原则12.2.4 模板和非模板12.3 显式特化12.3.1 全局的类模板特化12.3.2 全局的函数模板特化12.3.3 全局成员特化12.4 局部的类模板特化12.5 本章后记第13章 未来的方向13.1 尖括号hack13.2 放松typename的原则13.3 缺省函数模板实参13.4 字符串文字和浮点型模板实参13.5 放松模板的模板参数的匹配13.6 typedef模板13.7 函数模板的局部特化13.8 typeof运算符13.9 命名模板实参13.10 静态属性13.11 客户端的实例化诊断信息13.12 重载类模板13.13 list参数13.14 布局控制13.15 初始化器的演绎13.16 函数表达式13.17 本章后记第3部分 模板与设计第14章 模板的多态威力14.1 动多态14.2 静多态14.3 动多态和静多态14.3.1 术语14.3.2 优点和缺点14.3.3 组合这两种多态14.4 新形式的设计模板14.5 泛型程序设计14.6 本章后记第15章 trait与policy类15.1 一个实例：累加一个序列15.1.1 fixed traits15.1.2 value trait15.1.3 参数化trait15.1.4 policy和policy类15.1.5 trait和policy：区别在何处15.1.6 成员模板和模板的模板参数15.1.7 组合多个policie和/或trait15.1.8 运用普通的迭代器进行累积15.2 类型函数15.2.1 确定元素的类型15.2.2 确定class类型15.2.3 引用和限定符15.2.4 promotion trait15.3 policy trait15.3.1 只读的参数类型15.3.2 拷贝、交换和移动15.4 本章后记第16章 模板与继承16.1 命名模板参数16.2 空基类优化16.2.1 布局原则16.2.2 成员作基类16.3 奇特的递归模板模式16.4 参数化虚拟性16.5 本章后记第17章 metaprogram17.1 metaprogram的**个实例17.2 枚举值和静态常量17.3 第2个例子：计算平方根17.4 使用归纳变量17.5 计算完整性17.6 递归实例化和递归模板实参17.7 使用metaprogram来展开循环17.8 本章后记第18章 表示式模板18.1 临时变量和分割循环18.2 在模板实参中编码表达式18.2.1 表达式模板的操作数18.2.2 array类型18.2.3 运算符18.2.4 回顾18.2.5 表达式模板赋值18.3 表达式模板的性能与约束18.4 本章后记第4部分 高级应用程序第19章 类型区分19.1 辨别基本类型19.2 辨别组合类型19.3 辨别函数类型19.4 运用重载解析辨别枚举类型19.5 辨别class类型19.6 辨别所有类型的函数模板19.7 本章后记第20章 智能指针20.1 holder和trule20.1.1 安全处理异常20.1.2 holder20.1.3 作为成员的holder20.1.4 资源获取于初始化20.1.5 holder的局限20.1.6 复制holder20.1.7 跨函数调用来复制holder20.1.8 trule20.2 引用记数20.2.1 计数器在什么地方20.2.2 并发访问计数器20.2.3 析构和释放20.2.4 countingptr模板20.2.5 一个简单的非侵入式计数器20.2.6 一个简单的侵入式计数器模板20.2.7 常数性20.2.8 隐式转型20.2.9 比较20.3 本章后记第21章 tuple21.1 duo21.2 可递归duo21.2.1 域的个数21.2.2 域的类型21.2.3 域的值21.3 tuple构造21.4 本章后记第22章 函数对象和回调22.1 直接调用、间接调用与内联调用22.2 函数指针与函数引用22.3 成员函数指针22.4 class类型的仿函数22.4.1 class类型仿函数的第1个实例22.4.2 class类型仿函数的类型22.5 指定仿函数22.5.1 作为模板类型实参的仿函数22.5.2 作为函数调用实参的仿函数22.5.3 结合函数调用参数和模板类型参数22.5.4 作为非类型模板实参的仿函数22.5.5 函数指针的封装22.6 内省22.6.1 分析一个仿函数的类型22.6.2 访问参数的类型22.6.3 封装函数指针22.7 函数对象组合22.7.1 简单的组合22.7.2 混合类型的组合22.7.3 减少参数的个数22.8 值绑定22.8.1 选择绑定的目标22.8.2 绑定签名22.8.3 实参选择22.8.4 辅助函数22.9 仿函数操作：一个完整的实现22.10 本章后记附录a 一处定义原则a.1 翻译单元a.2 声明和定义a.3 一处定义原则的细节a.3.1 程序的一处定义约束a.3.2 翻译单元的一处定义约束a.3.3 跨翻译单元的等价性约束附录b 重载解析b.1 何时应用重载解析b.2 简化过的重载解析b.2.1 成员函数的隐含实参b.2.2 细化完美匹配b.3 重载的细节b.3.1 非模板优先b.3.2 转型序列b.3.3 指针的转型b.3.4 仿函数和代理函数b.3.5 其他的重载情况参考资料术语表
