C#神经网络编程 PDF下载 马特.R.课尔 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711162938
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711162938
<p>书名:C#神经网络编程</p><p>作者:马特.R.课尔</p><p>页数:224</p><p>定价:¥89.0</p><p>出版社:机械工业出版社</p><p>出版日期:2019-06-01</p><p>ISBN:9787111629382</p><p><h2>本书特色</h2></p>[<p>
本书遵循循序渐进、兼顾理论和实践的原则，从神经网络基本概念入手，以图文并茂的形式生动地讲解激活函数和反向传播等概念原理，并以人脸识别和动作检测为例，让读者直观地了解深度学习的应用场景，在知识内容方面，不但包含决策树、随机森林等常规算法，还重点讲解了LSTM、CNN神经网络等主流算法，在代码实践方面，比较深入地讲解开发细节，详细介绍了相关网络结构、参数调优和各种网络的对照比较，对程序员实际动手有比较强的参考意义。此外，本书还包含了常用激活函数，读者可以方便的在附录中查询相关函数特性，是一本集原理、实践与资料查询为一体的书籍。<br/>
</p>]<p><h2>内容简介</h2></p>[<p>在过去几年里，神经网络华丽回归，并为人工智能领域带来了重大的创新。<br/>    本书旨在为C#程序员使用神经网络、CNTK等C#库和TensorFlowSharp解决复杂的计算问题时，提供实践指导。本书逐步讲解编程实践，涵盖从数学到理论等神经网络的各个方面，帮助你运用C#和.NET框架构建深度神经网络。<br/>    本书从神经网络入门知识开始，详细介绍如何使用Encog、Aforge和Accord搭建一个神经网络，帮助你深入理解神经网络相关概念和技术，例如深度网络、感知器、优化算法、卷积网络和自动解码器。此外，还详细讲解如何向.NET应用程序中添加智能特性，例如面部和运动检测、对象检测和标注、语言理解、知识和智能搜索。<br/> <br/>通过阅读本书，你将学到：<br/>·理解感知器以及如何运用C#来实现。<br/>·使用认知服务训练并可视化神经网络。<br/>·运用C#和TensorFlowSharp对物体进行图像识别和标注。<br/>·使用Accord.Net检测面部等特定图像特征。<br/>·针对简单异或问题和Encog演示粒子群优化。<br/>·使用ConvNetSharp训练卷积神经网络。<br/>·运用数字和启发式优化技术为神经网络函数寻找*优参数。 </p>]<p><h2>作者简介</h2></p>[<p>马特·R.科尔（Matt R. Cole）是一名经验丰富的开发人员和作者，在Microsoft Windows、C、C  、 C#和.NET方面有30年的经验。他是Evolved AI Solutions公司的老板，该公司是高级机器学习/生物AI技术的主要供应商。他开发了第一个完全用C#和.NET编写的企业级微服务框架，该框架被纽约一家大型对冲基金生产。他还开发了第一个完全整合镜像和标准神经元的生物人工智能框架。</p>]<p><h2>目录</h2></p>
    译者序前言关于作者关于审校者第1章　快速预览    11.1　神经网络概述    21.1.1　神经网络训练    41.1.2　神经网络的结构指南    41.2　神经网络在当今企业中的作用    61.3　学习的类型    61.3.1　有监督学习    71.3.2　无监督学习    71.3.3　强化学习    71.4　了解感知器    71.5　了解激活函数    101.5.1　激活函数绘图    121.5.2　函数绘图    131.6　了解后向传播    161.7　小结    171.8　参考文献    17第2章　构建**个神经网络    182.1　一个简单的神经网络    182.2　神经网络训练    192.2.1　突触    202.2.2　神经元    212.2.3　前向传播    212.2.4　Sigmoid函数    212.2.5　后向传播    222.2.6　计算误差    232.2.7　计算梯度    232.2.8　更新权重    232.2.9　计算值    232.3　神经网络函数    242.3.1　创建新网络    242.3.2　导入现有网络    242.3.3　导入数据集    272.3.4　网络运算    272.3.5　导出网络    282.3.6　训练网络    282.3.7　测试网络    292.3.8　计算前向传播    292.3.9　将网络导出为JSON格式    292.3.10　导出数据集    302.4　神经网络    302.5　例子    312.5.1　训练到*小值    312.5.2　训练到*大值    312.6　小结    32第3章　决策树和随机森林    333.1　决策树    333.1.1　决策树的优点    343.1.2　决策树的缺点    353.1.3　何时应该使用决策树    353.2　随机森林    353.2.1　随机森林的优点    363.2.2　随机森林的缺点    363.2.3　何时应该使用随机森林    363.3　SharpLearning    373.3.1　术语    373.3.2　加载和保存模型    373.4　示例代码和应用程序    413.4.1　保存模型    413.4.2　均方差回归指标    413.4.3　F1分数    413.4.4　优化    423.4.5　示例应用程序1    423.4.6　示例应用程序2—葡萄酒质量    433.5　小结    453.6　参考文献    45第4章　面部和运动检测    464.1　面部检测    464.2　运动检测    544.3　小结    59第5章　使用ConvNetSharp训练CNN    605.1　热身    605.2　过滤器    645.3　创建网络    645.3.1　**个简单的例子    655.3.2　第二个简单的例子    665.3.3　第三个简单的例子    675.3.4　使用Fluent API    685.4　GPU    685.5　使用MNIST数据集进行流畅设计训练    685.6　训练网络    695.6.1　测试数据    705.6.2　预测数据    715.6.3 　计算图    715.7　小结    735.8　参考文献    73第6章　使用 RNNSharp训练自动编码器    746.1　什么是自动编码器    746.2　自动编码器的分类    746.2.1　标准自动编码器    756.2.2　变分自动编码器    766.2.3　降噪自动编码器    766.2.4　稀疏自动编码器    766.3　创建自己的自动编码器    766.4　小结    876.5　参考文献    88第7章　用PSO代替后向传播    897.1　基础理论    897.1.1　群体智能    907.1.2　粒子群优化算法    907.2　用粒子群优化算法代替后向传播    947.3　小结    98第8章　函数优化    998.1　入门    1008.2　函数*小化和*大化    1038.2.1　什么是粒子    1048.2.2　Swarm初始化    1068.2.3　图表初始化    1078.2.4　状态初始化    1088.2.5　控制随机性    1098.2.6　更新群体位置    1108.2.7　更新群速度    1108.2.8　主程序初始化    1108.2.9　运行粒子群优化    1118.2.10　用户界面    1128.3　超参数和调参    1138.3.1　函数    1138.3.2　策略    1148.3.3　维度大小    1158.3.4　上限    1158.3.5　下限    1168.3.6　上限速度    1168.3.7　下限速度    1178.3.8　小数位    1178.3.9　群体大小    1178.3.10　*大迭代次数    1188.3.11　惯性    1198.3.12　社交权重    1208.3.13　认知权重    1218.3.14　惯性权重    1228.4　可视化    1228.4.1　二维可视化    1228.4.2　三维可视化    1238.5　绘制结果    1288.5.1　回放结果    1288.5.2　更新信息树    1308.6　添加新的优化函数    1318.6.1　目的    1318.6.2　添加新函数的步骤    1318.6.3　添加新函数示例    1328.7　小结    135第9章　寻找*佳参数    1369.1　优化    1369.1.1　什么是适配函数    1379.1.2　约束    1379.1.3　元优化    1399.2　优化方法    1419.2.1　选择优化器    1419.2.2　梯度下降    1419.2.3　模式搜索    1419.2.4　局部单峰采样    1429.2.5　差异进化    1429.2.6　粒子群优化    1439.2.7　多优化联络员    1439.2.8　网格    1439.3　并行    1449.3.1　并行化优化问题    1449.3.2　并行优化方法    1449.3.3　编写代码    1449.3.4　执行元优化    1469.3.5　计算适配度    1469.3.6　测试自定义问题    1489
