C++程序设计-(英文版.第3版) PDF下载 （美）梁勇著 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711142505
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711142505
<p>书名:C++程序设计-(英文版.第3版)</p><p>作者:（美）梁勇　著</p><p>页数:689</p><p>定价:¥79.0</p><p>出版社:机械工业出版社</p><p>出版日期:2013-06-01</p><p>ISBN:9787111425052</p><p><h2>节选</h2></p>[<p>梁勇编著的《C++程序设计(英文版第3版)》是经典原版书库之一。本书的特色:1.更新了书中的实例和练习。以激发读者的编程兴趣。2.第4章介绍了string类型和简单输入/输出,可以使读者较早使用字符串和文件编写程序。3.第6章介绍函数,涵盖了所有与函数相关的问题。4.常见错误和陷阱部分可以帮助读者避免常见编程错误。5.扩充了算法技术方面的内容,采用新的实例阐释动态规划算法、分治策略、回溯法和贪婪算法,以设计高效算法。6.介绍了foreach循环、自动类型推断、Lambda表达式等C++11的新特性。</p>]<p><h2>本书特色</h2></p>[<p>

                                    
                                        
    梁勇编著的《c++程序设计(英文版第3版)》是经典原版书库之一。本书的特色：1.更新了书中的实例和练习。以激发读者的编程兴趣。2.第4章介绍了string类型和简单输入／输出，可以使读者较早使用字符串和文件编写程序。3.第6章介绍函数，涵盖了所有与函数相关的问题。4.常见错误和陷阱部分可以帮助读者避免常见编程错误。5.扩充了算法技术方面的内容，采用新的实例阐释动态规划算法、分治策略、回溯法和贪婪算法，以设计高效算法。6.介绍了foreach循环、自动类型推断、lambda表达式等c++11的新特性。                                    
                                        </p>]<p><h2>内容简介</h2></p>[<p>
                                    
                                            
梁勇编著的《c++程序设计(英文版第3版)》保持了liang博士系列丛书中一贯的标志性的教与学的哲学：以实例教，由实践学。通过使用他所提出的已经经过实践检验的“基础先行”的方法，liang博士在本书中通过大量实例阐明了基本的c++特性，使得学生可以通过实践来更有效地进行学习。

    
在引入面向对象程序设计思想之前，liang博士使用清晰简明的语言介绍了c++语言的基础概念和基本的程序设计技术，如循环、逐步求精等。这些概念都是使用简短且吸引人的实例来进行阐明的。他还在实例研究中给出了一些较大规模的例子，对这些实例，进行了整体的分析讨论和详细的逐行注解。

    
《c++程序设计(英文版第3版)》可以帮助学生循序渐进地学习所有必须和重要的基本概念，然后再进入到面向对象程序设计方法的学习，*终掌握构建具有异常处理和输入输出功能的有意义的应用程序的方法。贯穿全书的实例和练习都以问题求解为中心，试图培养学生开发可重用组件并创建实际项目的意识。                                    </p>]<p><h2>作者简介</h2></p>[<p>
                                    
                                             梁勇（Y.Daniel
Liang），普度大学终身教授，阿姆斯特朗亚特兰大州立大学计算机科学系教授他所编写的Java教程在美国大学Java课程中采用率极高，同时他还兼任Prentice
Hall Java系列丛书的编辑。                                    </p>]<p><h2>目录</h2></p>
                                    chapter 1 introduction to computers, programs, and c++ 1.1 introduction 1.2 what is a computer? 1.3 programming languages 1.4 operating systems 1.5 history of c++ 1.6 a simple c++ program 1.7 c++ program-development cycle 1.8 programming style and documentation 1.9 programming errorschapter 2 elementary programming 2.1 introduction 2.2 writing a simple program 2.3 reading input from the keyboard 2.4 identifiers 2.5 variables 2.6 assignment statements and assignment expressions 2.7 named constants 2,8 numeric data types and operations 2.9 evaluating expressions and operator precedence 2.10 case study: displaying the current time 2,11 augmented assignment operators 2.12 increment and decrement operators 2.13 numeric type conversions 2.14 software development process 2.15 case study: counting monetary units 2.16 common errorschapter 3 selections 3,1 introduction 3.2 the boo] data type 3.3 if statements 3,4 two-way if-else statements 3,5 nested if and multi-way if-else statements 3.6 common errors and pitfalls 3.7 case study: computing body mass index 3.8 case study: computing taxes 3.9 generating random numbers 3.10 logical operators 3.11 case study: determining leap year 3.12 case study: lottery 3.13 switch statements 3.14 conditional expressions 3.15 operator precedence and associativity 3.16 debuggingchapter 4 mathematical functions, characters, and strings 4.1 introduction 4.2 mathematical functions 4.3 character data type and operations 4.4 case study: generating random characters 4.5 case study: guessing birthdays 4.6 character functions 4.7 case study: converting a hexadecimal digit to a decimal value 4.8 the string type 4.9 case study: revising the lottery program using strings 4.10 formatting console output 4.11 simple file input and outputchapter 5 loops 5.1 introduction 5.2 the while loop 5.3 the do-while loop 5.4 the for loop 5.5 which loop to use? 5.6 nested loops 5.7 minimizing numeric errors 5.8 case studies 5.9 keywords break and continue 5.10 case study: checking palindromes 5.11 case study: displaying prime numberschapter 6 functions 6.1 introduction 6.2 defining a function 6.3 calling a function 6.4 void functions 6.5 passing arguments by value 6.6 modularizing code 6.7 overloading functions 6.8 function prototypes 6.9 default arguments 6.10 inline functions 6.11 local, global, and static local variables 6.12 passing arguments by reference 6.13 constant reference parameters 6.14 case study: converting hexadecimals to decimals 6.15 function abstraction and stepwise refinementchapter 7 single-dimensional arrays and c-strings 7.1 introduction 7.2 array basics 7.3 problem: lotto numbers. 7.4 problem: deck of cards 7.5 passing arrays to functions 7.6 preventing changes of array arguments in functions 7.7 returning arrays from functions 7.8 problem: counting the occurrences of each letter 7.9 searching arrays 7.10 sorting arrays 7.11 c-stringschapter 8 multidimensional arrays 8.1 introduction 8.2 declaring two-dimensional arrays 8.3 processing two-dimensional arrays 8.4 passing two-dimensional arrays to functions 8.5 problem: grading a multiple-choice test 8.6 problem: finding a closest pair 8.7 problem: sudoku 8.8 multidimensional arrayschapter 9 objects and classes 9.1 introduction 9.2 defining classes for objects 9.3 example: defining classes and creating objects 9.4 constructors 9.5 constructing and using objects 9.6 separating class definition from implementation 9.1 preventing multiple inclusions 9.8 inline functions in classes 9.9 data field encapsulation 9.10 the scope of variables 9.11 class abstraction and encapsulationchapter 10 object-oriented thinking 10.1 introduction 10.2 the string class 10.3 passing objects to functions 10.4 array of objects 10.5 instance and static members 10.6 constant member functions i0.7 thinking in objects 10.8 object composition 10.9 case study: the stackofintegers class 10.10 class design guidelineschapter h pointers and dynamic memory management 11.1 introduction 11.2 pointer basics 11.3 defining synonymous types using the typedef keyword 11.4 using const with pointers 11.5 arrays and pointers 11.6 passing pointer arguments in a function call 11.7 returning a pointer from functions 11.8 useful array functions 11.9 dynamic persistent memory allocation 1.10 creating and accessing dynamic objects 1.11 the this pointer 1.12 destructors 1.13 case study: the course class 1.14 copy constructors 1.15 customizing copy constructorschapter 12 templates, vectors, and stacks 12.1 introduction 12.2 templates basics 12.3 example: a generic sort 12.4 class templates 12.5 improving the stack class 12.6 the c++ vector class 12.7 replacing arrays using the vector class 12.8 case study: evaluating expressionschapter 13 file input and output 13.1 introduction 13.2 text i/o 13.3 formatting output 13.4 functions: getline, get, and put 13.5 fstream and file open modes 13.6 testing stream states 13.7 binary iio 13.8 random access file  13.9 updating fileschapter 14 operator overloading 14.1 introduction 14.2 the rational class 14.3 operator functions 14.4 overloading the subscript operator [] 14.5 overloading augmented assignment operators 14.6 overloading the unary operators 14.7 overloading the ++ and -- operators 14.8 friend functions and friend classes 14.9 overloading the << and >> operators 14.10 automatic type conversions 14.11 defining nonmember functions for overloading operators 14.12 the rational class with overloaded function operators 14.13 overloading the = operatorschapter 15 inheritance and polymorphism 15.1 introduction 15.2 base classes and derived classes 15.3 generic programming 15.4 constructors and destructors 15.5 redefining functions 15.6 polymorphism 15.7 virtual functions and dynamic binding 15.8 the protected keyword 15.9 abstract classes and pure virtual functions 15.10 casting: stati ccast versus dynami c_castchapter 16 exception handling 16.1 introduction 16.2 exception-handling overview 16.3 exception-handling advantages 16.4 exception classes 16.5 custom exception classes 16.6 multiple catches 16.7 exception propagation 16.8 rethrowing exceptions 16.9 exception specification 16.10 when'to use exceptionschapter 17 recursion. 17.1 introduction 17.2 example: factorials 17.3 case study: fibonacci numbers 17.4 problem solving using recursion 17.5 recursive helper functions 17.6 towers of hanoi 17.7 eight queens 17.8 recursion versus iteration 17.9 tail recursionthe following bonus chapters are on the book's companion website atwww.pearsonhighered.com/liang.chapter 18 devdoping efficient algorithmschapter 19 sortingchapter 20 linked lists, queues, and priority queueschapter 21 binary search treeschapter 22 stl containerschapter 23 stl algorithmschapter 24 graphs and applicationschapter 25 weighted graphs and applicationschapter 26 avl trees and splay treesappendixes appendix a c++ keywords appendix b the ascii character set appendix c operator precedence chart appendix d number systems appendix e bitwise operationsindexcredit                            
