Python 3面向对象编程-第2版-(影印版) PDF下载 杜斯提.菲利普 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#756417074
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#756417074
<p>书名:Python 3面向对象编程-第2版-(影印版)</p><p>作者:杜斯提.菲利普</p><p>页数:431</p><p>定价:¥88.0</p><p>出版社:东南大学出版社</p><p>出版日期:2017-04-01</p><p>ISBN:9787564170745</p><p><h2>本书特色</h2></p>[<p>
 杜斯提·菲利普编*的《Python3面向对象编程 （第2版影印版）（英文版）》讲解了类、数据封装 、继承、多态、抽象和异常，着重强调了在一款设计 良好的软件开发过程中使用每个原则的时机。除了学 习如何利用高层次的设计模式来创建可维护的应用程 序，你还可以了解到字符串和文件处理的复杂性以及 Python区分二进制数据和文本数据的方法。另外，单 元测试的乐趣以及并发编程的难题也是少不了的。<br/>    书中*新了大量的内容，以反映出近来核心 Python库的变化，这些新的特性在本书备受赞誉的第 1版面世时还无法使用。除此之外，全书的结构也进 行了重新调整和组织，提升了知识量，增强了阅读体 验。<br/>    目标读者    如果你是初次接触面向对象编程技术，或是只具 备基本的Python技能，希望能够深入学习如何正确地 使用Python面向对象编程技术来设计软件，那么这本 书就是为你准备的。<br/>    你将从本书中学到什么    通过创建类和定义方法来实现Python对象。<br/>    将相关的对象划分成不同的类，通过类接口来描 述这些对象的属性和行为。<br/>    使用继承来扩展类的功能。<br/>    明白什么时候使用面向对象特性，什么时候不使 用（后者*重要）。<br/>    了解什么是设计模式，为什么在Python中有这些 不同的设计模式。<br/>    揭示单元测试的简洁性及其在Python中的重要性 。<br/>    理解Python 3中常见的并发编程技术和陷阱。<br/>    探究用于开发大规模并发网络系统的新模块 Async10。
                                        </p>]<p><h2>作者简介</h2></p>[<p>Dusty Phillips is a Canadian software developer and author currently living in Seattle, Washington. He has been active in the open source community for a decade and a half and programming in Python for nearly all of it. He cofounded the popular Puget Sound Programming Python meetup group; drop by and say hi if you're in the area.                                 </p>]<p><h2>目录</h2></p>
    
Preface
Chapter 1: Object-oriented DesiqnIntroducing object-orientedObjects and classesSpecifying attributes and behaviorsData describes objectsBehaviors are actionsHiding details and creating the public interfaceCompositionInheritanceInheritance provides abstractionMultiple inheritanceCase studyExercisesSummary
Chapter 2: Objects in PythonCreating Python classesAdding attributesMaking it do somethingTalking to yourselfMore argumentsInitializing the objectExplaining yourselfModules and packagesOrganizing the modulesAbsolute importsRelative importsOrganizing module contentsWho can access my data?Third-party librariesCase studyExercisesSummary
Chapter 3: When Objects Are AlikeBasic inheritanceExtending built-insOverriding and superMultiple inheritanceThe diamond problemDifferent sets of argumentsPolymorphismAbstract base classesUsing an abstract base classCreating an abstract base classDemystifying the magicCase studyExercisesSummary
Chapter 4: Expecting the UnexpectedRaising exceptionsRaising an exceptionThe effects of an exceptionHandling exceptionsThe exception hierarchyDefining our own exceptionsCase studyExercisesSummary
Chapter 5: When to Use Object-oriented ProgrammingTreat objects as objectsAdding behavior to class data with propertiesProperties in detailDecorators - another way to create propertiesDeciding when to use propertiesManager objectsRemoving duplicate codeIn practiceCase studyExercisesSummary
Chapter 6: Python Data StructuresEmpty objectsTuples and named tuplesNamed tuplesDictionariesDictionary use casesUsing defaultdictCounterListsSorting listsSetsExtending built-insQueuesFIFO queuesLIFO queuesPriority queuesCase studyExercisesSummary
Chapter 7: Python Object-oriented ShortcutsPython built-in functionsThe len() functionReversedEnumerateFile I/OPlacing it in contextAn alternative to method overloadingDefault argumentsVariable argument listsUnpacking argumentsFunctions are objects tooUsing functions as attributesCallable objectsCase studyExercisesSummary
Chapter 8: Strings and SerializationStringsString manipulationString formattingEscaping bracesKeyword argumentsContainer IookupsObject IookupsMaking it look rightStrings are UnicodeConverting bytes to textConverting text to bytesMutable byte stringsRegular expressionsMatching patternsMatching a selection of charactersEscaping charactersMatching multiple charactersGrouping patterns togetherGetting information from regular expressionsMaking repeated regular expressions efficientSerializing objectsCustomizing picklesSerializing web objectsCase studyExercisesSummary
Chapter 9: The Iterator PatternDesign patterns in briefIteratorsThe iterator protocolComprehensionsList comprehensionsSet and dictionary comprehensionsGenerator expressionsGeneratorsYield items from another iterableCoroutinesBack to log parsingClosing coroutines and throwing exceptionsThe relationship between coroutines, generators, and functionsCase studyExercisesSummary
Chapter 10: Python Design Patterns IThe decorator patternA decorator exampleDecorators in PythonThe observer patternAn observer exampleThe strategy patternA strategy exampleStrategy in PythonThe state patternA state exampleState versus strategyState transition as coroutinesThe singleton patternSingleton implementationThe template patternA template exampleExercisesSummary
Chapter 11: Python Design Patterns IIThe adapter patternThe facade patternThe flyweight patternThe command patternThe abstract factory patternThe composite patternExercisesSummary
Chapter 12: Testing Object-oriented ProgramsWhy test?Test-driven developmentUnit testingAssertion methodsReducing boilerplate and cleaning upOrganizing and running testsIgnoring broken testsTesting with py.testOne way to do setup and cleanupA completely different way to set up variablesSkipping tests with py.testImitating expensive objectsHow much testing is enough?Case studyImplementing itExercisesSummary
Chapter 13: ConcurrencyThreadsThe many problems with threadsShared memoryThe global interpreter lockThread overheadMultiprocessingMultiprocessing poolsQueuesThe problems with multiprocessingFuturesAsynclOAsynclO in actionReading an AsynclO futureAsynclO for networkingUsing executors to wrap blocking codeStreamsExecutorsCase studyExercisesSummary
Index

