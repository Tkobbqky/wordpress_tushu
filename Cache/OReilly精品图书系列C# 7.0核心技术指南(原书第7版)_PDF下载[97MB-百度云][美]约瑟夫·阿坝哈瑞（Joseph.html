OReilly精品图书系列C# 7.0核心技术指南(原书第7版) PDF下载 [美]约瑟夫·阿坝哈瑞（Joseph 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711163134
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711163134
<p>书名:OReilly精品图书系列C# 7.0核心技术指南(原书第7版)</p><p>作者:[美] 约瑟夫·阿坝哈瑞（Joseph </p><p>页数:1072</p><p>定价:¥259.0</p><p>出版社:机械工业出版社</p><p>出版日期:2018-04-01</p><p>ISBN:9787111631347</p><p><h2>本书特色</h2></p>[<p>
本书前三章将集中介绍C#语言。首先介绍*基本的语法、类型和变量。而后会介绍一些高级的特性，如不安全代码以及预处理指令。如果你是C#语言的初学者，请循序渐进地阅读这些章节。
其余各章则涵盖了.NET
Framework的核心功能，包括LINQ、XML、集合、并发、I/O
和网络、内存管理、反射、动态编程、特性、安全、应用程序域和原生互操作性等主题。第6章和第7章是后续主题的基础，除这两章之外，其余各章可以按照需要以任何顺序阅读。LINQ相关的三个章节*好按顺序阅读。其中的一些章节需要一些并发相关的知识，这些知识将在第14章中介绍。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书是一本C#7.0的技术指南，通过26章的内容，系统、全面、细致地讲解了C#7.0从基础知识到各种不错特性的命令、语法和用法。本书的讲解深入浅出，同时为每一个知识点都专门设计了贴切、简单、易懂的学习案例，从而可以帮助读者准确地理解知识点的含义并快速地学以致用。</p>]<p><h2>作者简介</h2></p>[<p>Joseph
Albahari 是《C# 6.0 in a Nutshell》以及《LINQ Pocket Reference》的合著者。他编写了流行的代码执行器与 LINQ 查询辅助工具 LINQPad。
Ben
Albahari 是《C# 6.0 in a
Nutshell》的合著者。他曾就职于
Microsoft，并担任 Entity
Framework 的项目经理。</p>]<p><h2>目录</h2></p>
    
前言1
第1章　C#和.NET Framework简介7
1.1 面向对象7
1.2 类型安全性8
1.3 内存管理9
1.4 平台支持9
1.5 C#和CLR9
1.6 CLR和.NET Framework10
1.7 其他框架11
1.7.1遗留框架和小众框架12
1.7.2 Windows
Runtime12
1.8 C#简史13
1.8.1 C# 7.0新特性14
1.8.2 C# 6.0新特性17
1.8.3 C# 5.0新特性18
1.8.4 C# 4.0新特性19
1.8.5 C# 3.0新特性19
1.8.6 C# 2.0新特性20
第2章　C#语言基础21
2.1 **个C#程序21
2.2 语法24
2.2.1 标识符和关键字24
2.2.2 字面量、标点与运算符26
2.2.3 注释26
2.3 类型基础27
2.3.1 预定义类型示例27
2.3.2 自定义类型示例28
2.3.3 转换30
2.3.4 值类型与引用类型31
2.3.5 预定义类型分类34
2.4 数值类型35
2.4.1 数值字面量36
2.4.2 数值转换38
2.4.3 算术运算符39
2.4.4 自增和自减运算符39
2.4.5 特殊整数类型运算39
2.4.6 8位和16位整数类型41
2.4.7 特殊的float和double值41
2.4.8 double和decimal的对比42
2.4.9 实数的舍入误差43
2.5 布尔类型和运算符43
2.5.1 布尔类型转换43
2.5.2 相等和比较运算符44
2.5.3 条件运算符44
2.6 字符串和字符45
2.6.1 char转换46
2.6.2 字符串类型46
2.7 数组48
2.7.1 默认数组元素初始化49
2.7.2 多维数组49
2.7.3 简化数组初始化表达式51
2.7.4 边界检查52
2.8 变量和参数52
2.8.1 栈和堆52
2.8.2 明确赋值54
2.8.3 默认值54
2.8.4 参数55
2.8.5 引用局部变量（C# 7）61
2.8.6 引用返回值（C# 7）61
2.8.7 var隐式类型局部变量61
2.9 表达式和运算符62
2.9.1 基础表达式63
2.9.2 空表达式63
2.9.3 赋值表达式63
2.9.4 运算符优先级和结合性64
2.9.5 运算符表64
2.10 null运算符68
2.10.1 null合并运算符68
2.10.2 null条件运算符（C# 6）68
2.11 语句69
2.11.1 声明语句69
2.11.2 表达式语句70
2.11.3 选择语句71
2.11.4 迭代语句75
2.11.5 跳转语句77
2.11.6其他语句78
2.12 命名空间79
2.12.1 using指令80
2.12.2 using
static指令（C# 6）80
2.12.3 命名空间中的规则81
2.12.4 类型和命名空间别名83
2.12.5 高级命名空间特性83
第3章　在C#中创建类型86
3.1 类86
3.1.1 字段86
3.1.2 方法87
3.1.3 实例构造器89
3.1.4 对象初始化器92
3.1.5 this引用94
3.1.6 属性94
3.1.7 索引器97
3.1.8 常量98
3.1.9 静态构造器99
3.1.10 静态类100
3.1.11 终结器101
3.1.12 分部类型和方法101
3.1.13 nameof运算符（C#6）102
3.2 继承103
3.2.1 多态104
3.2.2 类型转换和引用转换104
3.2.3 虚函数成员107
3.2.4 抽象类和抽象成员108
3.2.5 隐藏继承成员108
3.2.6 密封函数和类110
3.2.7 base关键字110
3.2.8 构造器和继承110
3.2.9 重载和解析112
3.3 object类型112
3.3.1 装箱和拆箱113
3.3.2 静态和运行时类型检查114
3.3.3 GetType方法和typeof运算符115
3.3.4 ToString方法115
3.3.5 object的成员列表116
3.4 结构体116
3.5 访问权限修饰符118
3.5.1 示例118
3.5.2 友元程序集119
3.5.3 可访问性封顶119
3.5.4 访问权限修饰符的限制119
3.6 接口120
3.6.1 扩展接口121
3.6.2 显式接口实现121
3.6.3 虚方法实现接口成员122
3.6.4 在子类中重新实现接口122
3.6.5 接口和装箱124
3.7 枚举类型125
3.7.1 枚举类型转换126
3.7.2 标志枚举类型126
3.7.3 枚举运算符127
3.7.4 类型安全问题127
3.8 嵌套类型128
3.9 泛型130
3.9.1 泛型类型130
3.9.2 为什么需要泛型131
3.9.3 泛型方法132
3.9.4 声明类型参数133
3.9.5 typeof和未绑定泛型类型133
3.9.6 泛型的默认值134
3.9.7 泛型的约束134
3.9.8 继承泛型类型136
3.9.9 自引用泛型声明136
3.9.10 静态数据136
3.9.11 类型参数的转换137
3.9.12 协变138
3.9.13 逆变141
3.9.14 C#泛型和C  模板对比142
第4章　C#的高级特性143
4.1 委托143
4.1.1 用委托书写插件方法144
4.1.2 多播委托145
4.1.3 实例目标方法和静态目标方法147
4.1.4 泛型委托类型147
4.1.5 Func和Action委托148
4.1.6 委托和接口149
4.1.7 委托的兼容性150
4.2 事件152
4.2.1 标准事件模式154
4.2.2 事件访问器158
4.2.3 事件的修饰符159
4.3 Lambda表达式159
4.3.1 显式指定Lambda参数的类型160
4.3.2 捕获外部变量161
4.3.3 Lambda表达式和局部方法的对比163
4.4 匿名方法164
4.5 try语句和异常165
4.5.1 catch子句167
4.5.2 finally块168
4.5.3 抛出异常170
4.5.4
System.Exception的关键属性172
4.5.5 常用的异常类型172
4.5.6 TryXXX方法模式173
4.5.7 异常的替代方式173
4.6 可枚举类型和迭代器174
4.6.1 可枚举类型174
4.6.2 集合的初始化器175
4.6.3 迭代器176
4.6.4 迭代器语义177
4.6.5 组合序列178
4.7 可空类型180
4.7.1
Nullable结构体180
4.7.2 隐式和显式的可空对象转换180
4.7.3 装箱拆箱可空值181
4.7.4 运算符优先级提升181
4.7.5 在bool?上使用&和|运算符183
4.7.6 可空类型和null运算符183
4.7.7 可空类型的应用场景184
4.7.8 可空类型的替代方案184
4.8 扩展方法185
4.8.1 扩展方法链186
4.8.2 二义性与解析186
4.9 匿名类型188
4.10 元组（C# 7）189
4.10.1 元组元素命名190
4.10.2
ValueTuple.Create192
4.10.3 元组的解构192
4.10.4 元组的比较193
4.10.5
System.Tuple类193
4.11 特性193
4.11.1 特性类194
4.11.2 命名和位置特性参数194
4.11.3 特性的目标195
4.11.4 指定多个特性195
4.12 调用者信息特性195
4.13 动态绑定197
4.13.1 静态绑定与动态绑定197
4.13.2 自定义绑定198
4.13.3 语言绑定199
4.13.4
RuntimeBinderException200
4.13.5 动态类型的运行时表示200
4.13.6 动态转换201
4.13.7 var与dynamic201
4.13.8 动态表达式202
4.13.9 无动态接收者的动态调用202
4.13.10 动态表达式中的静态类型203
4.13.11 不可调用的函数204
4.14 运算符重载205
4.14.1 运算符函数206
4.14.2 重载等号和比较运算符206
4.14.3 自定义隐式和显式转换207
4.14.4 重载true和false208
4.15 不安全的代码和指针209
4.15.1 指针基础209
4.15.2 不安全的代码209
4.15.3 fixed语句209
4.15.4 指针取成员运算符210
4.15.5 数组210
4.15.6 void*211
4.15.7 指向非托管代码的指针212
4.16 预处理指令212
4.16.1 Conditional特性213
4.16.2 Pragma警告214
4.17 XML文档214
4.17.1 标准的XML文档标签215
4.17.2 用户定义标签217
4.17.3 类型或成员交叉引用217
第5章　框架概述219
5.1 .NET标准2.0221
5.1.1 旧版本.NET标准222
5.1.2 引用程序集222
5.2 CLR和核心框架223
5.2.1 系统类型223
5.2.2 文本处理223
5.2.3 集合223
5.2.4 查询224
5.2.5 XML224
5.2.6 诊断224
5.2.7 并发与异步225
5.2.8 流与I/O225
5.2.9 网络225
5.2.10 序列化225
5.2.11 程序集、反射和特性226
5.2.12 动态编程226
5.2.13 安全性226
5.2.14 高级线程功能226
5.2.15 并行编程227
5.2.16 应用程序域227
5.2.17 原生互操作性与COM互操作性227
5.3 应用技术227
5.3.1 用户界面API227
5.3.2 后台技术230
5.3.3 分布式系统技术232
第6章　框架基础234
6.1 字符串与文本处理234
6.1.1 字符234
6.1.2 字符串236
6.1.3 字符串的比较240
6.1.4
StringBuilder243
6.1.5 文本编码和Unicode244
6.2 日期和时间248
6.2.1 TimeSpan248
6.2.2 DateTime和DateTimeOffset249
6.3 日期和时区255
6.3.1 DateTime与时区256
6.3.2
DateTimeOffset与时区256
6.3.3 TimeZone和TimeZoneInfo257
6.3.4 夏令时与DateTime261
6.4 格式化和解析262
6.4.1 ToString和Parse263
6.4.2 格式提供器263
6.5 标准格式字符串与解析标记268
6.5.1 数字格式字符串268
6.5.2
NumberStyles270
6.5.3 Date/Time格式字符串272
6.5.4
DateTimeStyles275
6.5.5 枚举的格式字符串275
6.6 其他转换机制275
6.6.1 Convert类276
6.6.2
XmlConvert278
6.6.3 类型转换器278
6.6.4
BitConverter279
6.7 全球化279
6.7.1 全球化检查清单280
6.7.2 测试280
6.8 操作数字281
6.8.1 转换281
6.8.2 Math281
6.8.3
BigInteger282
6.8.4 Complex283
6.8.5 Random284
6.9 枚举285
6.9.1 枚举值转换285
6.9.2 列举枚举值287
6.9.3 枚举的工作方式288
6.10 Guid结构体288
6.11 相等比较289
6.11.1 值相等和引用相等289
6.11.2 标准等值比较协议290
6.11.3 相等比较和自定义类型295
6.12 顺序比较300
6.12.1
IComparable300
6.12.2 301
6.12.3 实现IComparable接口302
6.13实用类303
6.13.1 Console类303
6.13.2
Environment类304
6.13.3 Process类304
6.13.4 AppContext类306
第7章　集合307
7.1 枚举307
7.1.1 IEnumerable和IEnumerator308
7.1.2
IEnumerable和IEnumerator309
7.1.3 实现枚举接口311
7.2 ICollection和IList接口315
7.2.1
ICollection和ICollection316
7.2.2
IList和IList317
7.2.3
IReadOnlyList318
7.3 Array类318
7.3.1 创建和索引321
7.3.2 枚举322
7.3.3 长度和维数323
7.3.4 搜索323
7.3.5 排序325
7.3.6 反转数组元素326
7.3.7 复制数组326
7.3.8 转换和调整大小326
7.4 List、Queue、Stack和Set327
7.4.1
List和ArrayList327
7.4.2
LinkedList330
7.4.3
Queue和Queue332
7.4.4
Stack和Stack332
7.4.5 BitArray333
7.4.6
HashSet和SortedSet334
7.5 字典336
7.5.1 IDictionary336
7.5.2
IDictionary338
7.5.3
Dictionary和HashTable339
7.5.4
OrderedDictionary340
7.5.5
ListDictionary和HybridDictionary340
7.5.6 排序字典341
7.6 自定义集合与代理342
7.6.1
Collection和CollectionBase343
7.6.2
KeyedCollection和DictionaryBase345
7.6.3
ReadOnlyCollection348
7.7 扩展相等比较和排序操作349
7.7.1
IEqualityComparer和EqualityComparer350
7.7.2 IComparer和Comparer352
7.7.3
StringComparer353
7.7.4
IStructuralEquatable和IStructuralComparable355
第8章　LINQ查询356
8.1 入门356
8.2 流式语法358
8.2.1 查询运算符链359
8.2.2 使用Lambda表达式361
8.2.3 原始顺序364
8.2.4 其他运算符364
8.3 查询表达式365
8.3.1 范围变量367
8.3.2 LINQ查询语法与SQL语法368
8.3.3 查询语法和流式语法368
8.3.4 混合查询语法369
8.4 延迟执行369
8.4.1 重复执行370
8.4.2 捕获变量371
8.4.3 延迟执行的工作原理372
8.4.4 串联装饰器373
8.4.5 查询语句的执行方式375
8.5 子查询376
8.6 构造方式379
8.6.1 渐进式查询构造379
8.6.2 into关键字380
8.6.3 查询的包装381
8.7 映射方式382
8.7.1 对象初始化器382
8.7.2 匿名类型383
8.7.3 let关键字384
8.8 解释型查询385
8.8.1 解释型查询的工作机制387
8.8.2 综合使用解释型查询和本地查询389
8.8.3
AsEnumerable方法390
8.9 LINQ to SQL和Entity Framework391
8.9.1 LINQ to SQL的实体类392
8.9.2 Entity
Framework的实体类393
8.9.3 DataContext和ObjectContext395
8.9.4 关联399
8.9.5 L2S和EF的延迟执行400
8.9.6
DataLoadOptions401
8.9.7 Entity
Framework中的立即加载功能403
8.9.8 更新403
8.9.9 L2S和EF的API对比405
8.10 构建查询表达式406
8.10.1 委托与表达式树406
8.10.2 表达式树408
第9章　LINQ运算符412
9.1 概述413
9.1.1 序列→序列414
9.1.2 序列→元素或标量值415
9.1.3 void →序列416
9.2 筛选416
9.2.1 Where417
9.2.2 Take和Skip运算符419
9.2.3 TakeWhile和SkipWhile420
9.2.4 Distinct420
9.3 映射420
9.3.1 Select421
9.3.2
SelectMany425
9.4 连接433
9.4.1 Join和GroupJoin433
9.4.2 Zip运算符441
9.5 排序441
9.6 分组444
9.7 集合运算符448
9.7.1 Concat和Union448
9.7.2 Intersect和Except448
9.8 转换方法449
9.8.1 OfType和Cast449
9.8.2 ToArray、ToList、ToDictionary和ToLookup451
9.8.3
AsEnumerable和AsQueryable451
9.9 元素运算符452
9.9.1 First、Last和Single452
9.9.2 ElementAt运算符453
9.9.3
DefaultIfEmpty453
9.10 聚合方法454
9.10.1 Count和LongCount454
9.10.2 Min和Max454
9.10.3 Sum和Average455
9.10.4
Aggregate456
9.11 量词运算符458
9.11.1 Contains和Any459
9.11.2 All和SequenceEqual459
9.12 生成集合的方法460
9.12.1 Empty460
9.12.2 Range和Repeat460
第10章　LINQ to
XML461
10.1 架构概述461
10.1.1 什么是DOM461
10.1.2 LINQ to
XML的DOM462
10.2 X-DOM概述462
10.2.1 加载和解析464
10.2.2 保存和序列化465
10.3 实例化X-DOM466
10.3.1 函数式构建466
10.3.2 指定内容467
10.3.3 自动深度克隆468
10.4 导航和查询468
10.4.1 导航至子节点469
10.4.2 导航至父节点472
10.4.3 导航至同级节点473
10.4.4 导航至节点的属性473
10.5 更新X-DOM474
10.5.1 简单的值更新474
10.5.2 更新子节点和属性474
10.5.3 通过父节点更新子节点475
10.6 使用Value477
10.6.1 设置Value477
10.6.2 获得Value478
10.6.3 值与混合内容节点479
10.6.4 自动连接XText节点479
10.7 文档和声明480
10.7.1
XDocument480
10.7.2 XML声明482
10.8 名称和命名空间483
10.8.1 XML中的命名空间484
10.8.2 在X-DOM中指定命名空间486
10.8.3 X-DOM和默认命名空间487
10.8.4 前缀488
10.9 注解489
10.10 将数据映射到X-DOM490
10.10.1 排除空元素492
10.10.2 流映射493
10.10.3 转换X-DOM494
第11章　其他XML技术497
11.1 XmlReader497
11.1.1 读取节点499
11.1.2 读取元素501
11.1.3 读取属性505
11.1.4 命名空间和前缀506
11.2 XmlWriter507
11.2.1 写入属性508
11.2.2 写入其他类型节点508
11.2.3 命名空间和前缀509
11.3
XmlReader/XmlWriter的使用模式509
11.3.1 处理多层次结构数据509
11.3.2 混合使用XmlReader/XmlWriter和X-DOM512
11.4 XSD和大纲的验证513
11.5 XSLT516
第12章　对象销毁与垃圾回收518
12.1 IDisposable接口、Dispose方法和Close方法518
12.1.1 标准销毁语义519
12.1.2 销毁对象的时机520
12.1.3 选择性销毁522
12.1.4 在销毁时清理字段523
12.2 自动垃圾回收524
12.2.1 根525
12.2.2 垃圾回收和WinRT525
12.3 终结器525
12.3.1 在终结器中调用Dispose527
12.3.2 对象的复活528
12.4 垃圾回收器的工作方式530
12.4.1 优化技术531
12.4.2 强制垃圾回收534
12.4.3 垃圾回收过程的调整534
12.4.4 内存压力535
12.5 托管内存泄露535
12.5.1 定时器536
12.5.2 诊断内存泄露538
12.6 弱引用538
12.6.1 弱引用和缓存539
12.6.2 弱引用和事件540
第13章　诊断543
13.1 条件编译543
13.1.1 条件编译与静态变量标志544
13.1.2
Conditional特性545
13.2 Debug和Trace类547
13.2.1 Fail和Assert方法547
13.2.2
TraceListener类548
13.2.3 刷新并关闭监听器550
13.3 调试器的集成550
13.3.1 附加和断点551
13.3.2 Debugger特性551
13.4 进程与线程处理551
13.4.1 检查运行中的进程552
13.4.2 在进程中检查线程552
13.5 StackTrace和StackFrame类552
13.6 Windows事件日志554
13.6.1 写入事件日志555
13.6.2 读取事件日志555
13.6.3 监视事件日志556
13.7 性能计数器557
13.7.1 遍历可用的计数器557
13.7.2 检索性能计数器558
13.7.3 创建计数器并写入性能数据560
13.8 Stopwatch类562
第14章　并发与异步563
14.1 概述563
14.2 线程564
14.2.1 创建线程564
14.2.2 汇合与休眠566
14.2.3 阻塞566
14.2.4 本地状态与共享状态568
14.2.5 锁与线程安全570
14.2.6 向线程传递数据571
14.2.7 异常处理573
14.2.8 前台线程与后台线程574
14.2.9 线程的优先级575
14.2.10 信号发送576
14.2.11 富客户端应用程序的线程576
14.2.12 同步上下文578
14.2.13 线程池579
14.3 任务581
14.3.1 启动任务582
14.3.2 返回值583
14.3.3 异常584
14.3.4 延续585
14.3.5
TaskCompletionSource类587
14.3.6 Task.Delay方法589
14.4 异步原则590
14.4.1 同步操作与异步操作590
14.4.2 什么是异步编程590
14.4.3 异步编程与延续591
14.4.4 语言支持的重要性593
14.5 C#的异步函数595
14.5.1 等待595
14.5.2 编写异步函数601
14.5.3 异步Lambda表达式605
14.5.4 WinRT中的异步方法606
14.5.5 异步与同步上下文606
14.5.6 优化608
14.6 异步模式610
14.6.1 取消操作610
14.6.2 进度报告612
14.6.3 基于任务的异步模式614
14.6.4 任务组合器614
14.7 已废弃的模式618
14.7.1 异步编程模型（APM）618
14.7.2 基于事件的异步模式（EAP）619
14.7.3 BackgroundWorker类620
第15章　流与I/O622
15.1 .NET流的架构622
15.2 使用流624
15.2.1 读取和写入626
15.2.2 查找627
15.2.3 关闭和刷新627
15.2.4 超时628
15.2.5 线程安全628
15.2.6 后台存储流628
15.2.7 FileStream类629
15.2.8
MemoryStream632
15.2.9
PipeStream633
15.2.10
BufferedStream636
15.3 流适配器637
15.3.1 文本适配器638
15.3.2 二进制适配器643
15.3.3 关闭和销毁流适配器644
15.4 压缩流646
15.5 操作ZIP文件648
15.6 文件与目录操作649
15.6.1 File类649
15.6.2 Directory类652
15.6.3 FileInfo类和DirectoryInfo类653
15.6.4 Path类型654
15.6.5 特殊文件夹655
15.6.6 查询卷信息658
15.6.7 捕获文件系统事件658
15.7 在UWP中进行文件I/O操作659
15.7.1 操作目录660
15.7.2 操作文件661
15.7.3 UWP应用的独立存储区662
15.8 内存映射文件662
15.8.1 内存映射文件和随机I/O662
15.8.2 内存映射文件和共享内存663
15.8.3 使用视图访问器663
15.9 独立存储区664
第16章　网络665
16.1 .NET网络架构665
16.2 地址与端口667
16.3 URI668
16.4 客户端类型670
16.4.1 WebClient类671
16.4.2 WebRequest和WebResponse673
16.4.3 HttpClient类675
16.4.4 代理679
16.4.5 身份验证680
16.4.6 异常处理682
16.5 使用HTTP684
16.5.1 头部信息684
16.5.2 查询字符串685
16.5.3 上传表单数据686
16.5.4 cookie687
16.5.5 表单验证688
16.5.6 SSL690
16.6 编写HTTP服务器690
16.7 使用FTP693
16.8 使用DNS695
16.9 通过SmtpClient类发送邮件696
16.10 使用TCP697
16.11 使用TCP接收POP3邮件700
16.12 在Windows Runtime中使用TCP702
第17章　序列化704
17.1 序列化的概念704
17.1.1 序列化引擎704
17.1.2 格式化器707
17.1.3 显式和隐式序列化707
17.2 数据契约的序列化708
17.2.1
DataContractSerializer与NetDataContractSerializer708
17.2.2 使用序列化器709
17.2.3 序列化子类712
17.2.4 对象引用713
17.2.5 版本容错性716
17.2.6 成员顺序716
17.2.7 null和空值717
17.3 数据契约与集合718
17.3.1 子类集合元素719
17.3.2 自定义集合与元素名称719
17.4 扩展数据契约720
17.4.1 序列化与反序列化钩子721
17.4.2 与[Serializable] 的互操作722
17.4.3 与IXmlSerializable的互操作724
17.5 二进制序列化器724
17.6 二进制序列化特性726
17.6.1
[NonSerialized]726
17.6.2
[OnDeserializing]和[OnDeserialized]726
17.6.3
[OnSerializing]和[OnSerialized]727
17.6.4
[OptionalField]特性和版本728
17.7 使用ISerializable接口进行二进制序列化729
17.8 XML序列化733
17.8.1 基于特性的序列化入门733
17.8.2 子类和子对象735
17.8.3 序列化集合738
17.8.4 IXmlSerializable接口741
第18章　程序集743
18.1 程序集的组成部分743
18.1.1 程序集清单744
18.1.2 应用程序清单745
18.1.3 模块746
18.1.4 Assembly类747
18.2 强名称和程序集签名748
18.2.1 如何为程序集添加强名称749
18.2.2 延迟签名750
18.3 程序集名称751
18.3.1 完全限定名称751
18.3.2
AssemblyName类752
18.3.3 程序集的信息版本和文件版本753
18.4 认证代码签名753
18.4.1 如何进行认证代码签名755
18.4.2 认证代码验证756
18.5 全局程序集缓存757
18.5.1 如何将程序集安装到GAC758
18.5.2 GAC和版本控制759
18.6 资源和附属程序集759
18.6.1 直接嵌入资源760
18.6.2 .resources文件762
18.6.3 .resx文件762
18.6.4 附属程序集765
18.6.5 文化和子文化767
18.7 程序集的解析和加载768
18.7.1 程序集和类型解析规则769
18.7.2 AssemblyResolve事件769
18.7.3 加载程序集770
18.8 在基础目录之外部署程序集774
18.9 打包单个可执行文件775
18.10 处理未引用的程序集776
第19章　反射和元数据779
19.1 反射和激活类型780
19.1.1 获取类型780
19.1.2 类型名称782
19.1.3 基本类型和接口784
19.1.4 实例化类型785
19.1.5 泛型类型786
19.2 反射并调用成员787
19.2.1 成员类型790
19.2.2 C#成员与CLR成员791
19.2.3 泛型类型成员793
19.2.4 动态调用成员793
19.2.5 方法的参数794
19.2.6 使用委托提高性能796
19.2.7 访问非公有成员796
19.2.8 泛型方法798
19.2.9 调用未知类型的泛型接口成员798
19.3 反射程序集800
19.3.1 将程序集加载至只反射的上下文中801
19.3.2 模块802
19.4 使用特性802
19.4.1 特性基础802
19.4.2
AttributeUsage特性804
19.4.3 定义自定义的特性804
19.4.4 在运行时检索特性805
19.4.5 在只反射上下文下检索特性807
19.5 动态生成代码808
19.5.1 使用DynamicMethod生成IL808
19.5.2 评估栈810
19.5.3 向动态方法传递参数810
19.5.4 生成局部变量811
19.5.5 分支812
19.5.6 实例化对象和调用实例方法813
19.5.7 异常处理815
19.6 生成程序集和类型815
19.6.1 保存生成的程序集817
19.6.2
Reflection.Emit对象模型818
19.7 生成类型成员819
19.7.1 生成方法820
19.7.2 生成字段和属性822
19.7.3 生成构造器824
19.7.4 附加特性825
19.8 生成泛型方法和类型825
19.8.1 定义泛型方法825
19.8.2 定义泛型类型827
19.9 复杂的生成目标827
19.9.1 未创建的封闭式泛型827
19.9.2 循环依赖829
19.10 解析IL831
第20章　动态编程837
20.1 动态语言运行时837
20.2 数值类型统一839
20.3 动态成员重载解析840
20.3.1 简化访问者模式840
20.3.2 调用未知类型的泛型类型成员844
20.4 实现动态对象846
20.4.1
DynamicObject847
20.4.2
ExpandoObject849
20.5 与动态语言进行互操作849
第21章　安全852
21.1 代码访问安全性852
21.2 身份和角色安全853
21.2.1 权限853
21.2.2 声明式安全性与命令式安全性854
21.2.3 实现身份和角色安全855
21.2.4 设定用户和角色855
21.3 操作系统安全性856
21.3.1 在标准用户账户下运行程序857
21.3.2 管理员权限提升与虚拟化858
21.4 加密概述859
21.5 Windows数据保护859
21.6 散列法860
21.7 对称加密862
21.7.1 内存加密863
21.7.2 串联加密流864
21.7.3 销毁加密对象866
21.7.4 密钥管理866
21.8 公钥加密和签名867
21.8.1 RSA类868
21.8.2 数字签名869
第22章　高级线程处理871
22.1 同步概述871
22.2 排它锁872
22.2.1 lock语句872
22.2.2
Monitor.Enter方法和Monitor.Exit方法873
22.2.3 选择同步对象874
22.2.4 使用锁的时机875
22.2.5 锁与原子性876
22.2.6 嵌套锁877
22.2.7 死锁878
22.2.8 性能879
22.2.9 Mutex879
22.3 锁和线程安全性880
22.3.1 线程安全和.NET Framework类型882
22.3.2 应用服务器的线程安全性884
22.3.3 不可变对象885
22.4 非排它锁886
22.4.1 信号量886
22.4.2 读写锁887
22.5 使用事件等待句柄发送信号892
22.5.1
AutoResetEvent892
22.5.2
ManualResetEvent895
22.5.3
CountdownEvent896
22.5.4 创建跨进程的EventWaitHandle897
22.5.5 等待句柄和延续操作897
22.5.6 将等待句柄转换为任务898
22.5.7 WaitAny、WaitAll和SignalAndWait899
22.6 Barrier类900
22.7 延迟初始化902
22.7.1
Lazy903
22.7.2
LazyInitializer类903
22.8 线程本地存储904
22.8.1
[ThreadStatic]特性905
22.8.2
ThreadLocal类905
22.8.3 GetData方法和SetData方法906
22.9 Interrupt和Abort方法906
22.10 Suspend和Resume方法908
22.11 定时器908
22.11.1 多线程定时器909
22.11.2 单线程定时器911
第23章　并行编程913
23.1 选择PFX的原因913
23.1.1 PFX的概念914
23.1.2 PFX组件914
23.1.3 使用PFX的场合916
23.2 PLINQ916
23.2.1 并行执行的特性918
23.2.2 PLINQ与顺序919
23.2.3 PLINQ的限制919
23.2.4 示例：并行拼写检查器920
23.2.5 纯函数922
23.2.6 设置并行级别922
23.2.7 取消操作923
23.2.8 PLINQ优化924
23.3 Parallel类929
23.3.1
Parallel.Invoke方法929
23.3.2
Parallel.For方法和Parallel.ForEach方法930
23.4 任务并行935
23.4.1 创建并启动任务936
23.4.2 等待多个任务938
23.4.3 取消任务939
23.4.4 延续任务940
23.4.5 任务调度器944
23.4.6
TaskFactory类945
23.5 处理AggregateException945
23.6 并发集合948
23.6.1
IProducerConsumerCollection接口949
23.6.2
ConcurrentBag类950
23.7
BlockingCollection类951
第24章　应用程序域955
24.1 应用程序域的架构955
24.2 创建和销毁应用程序域956
24.3 使用多个应用程序域958
24.4 DoCallBack方法960
24.5 监视应用程序域961
24.6 应用程序域和线程961
24.7 在应用程序域间共享数据963
24.7.1 通过“槽”共享数据963
24.7.2 进程内Remoting通信964
24.7.3 隔离类型与程序集965
第25章　原生程序和COM组件互操作性969
25.1 调用原生DLL969
25.2 类型的封送970
25.2.1 常见类型的封送970
25.2.2 类和结构体的封送971
25.2.3 in和out参数封送973
25.3 非托管代码中的回调函数973
25.4 模拟C共用体974
25.5 共享内存975
25.6 将结构体映射到非托管内存中977
25.7 COM互操作性981
25.7.1 COM的目的981
25.7.2 COM类型系统基础982
25.8 在C#中调用COM组件983
25.8.1 可选参数和命名参数984
25.8.2 隐式ref参数985
25.8.3 索引器985
25.8.4 动态绑定986
25.9 内嵌互操作类型987
25.10 主互操作程序集988
25.11 在COM中调用C#对象988
第26章　正则表达式989
26.1 正则表达式基础990
26.1.1 编译正则表达式991
26.1.2
RegexOptions属性991
26.1.3 字符转义992
26.1.4 字符集合993
26.2 量词符号994
26.3 零宽度断言995
26.3.1 前向条件和后向条件995
26.3.2 锚点996
26.3.3 单词边界997
26.4 分组998
26.5 替换并分割文本1000
26.5.1
MatchEvaluator委托1000
26.5.2 拆分文本1001
26.6 正则表达式实例1001
26.6.1 匹配美国社会保险号/电话号码1001
26.6.2 提取“name=value”中的名称和值（一行一个）1001
26.6.3 强密码验证1002
26.6.4 每行至少80个字符1002
26.6.5 解析日期/时间（N/N/N H:M:S AM/PM）1002
26.6.6 匹配罗马字符1003
26.6.7 删除重复单词1003
26.6.8 统计单词数目1003
26.6.9 匹配Guid1003
26.6.10 解析XML/HTML标签1003
26.6.11 分隔驼峰命名单词1004
26.6.12 获得合法的文件名1004
26.6.13 将Unicode字符转义为HTML1004
26.6.14 反转义HTTP查询字符串中的字符1004
26.6.15 从网站统计日志中解析谷歌搜索关键词1005
26.7 正则表达式语言参考1005
第27章　Roslyn编译器1009
27.1 Roslyn架构1010
27.2 语法树1011
27.2.1 语法树的结构1011
27.2.2 获取语法树1014
27.2.3 语法树的遍历和搜索1015
27.2.4 非关键信息1019
27.2.5 语法树的转换1022
27.3 编译过程和语义模型1026
27.3.1 创建编译过程1026
27.3.2 生成程序集1028
27.3.3 查询语义模型1028
27.3.4 示例：修改符号名称1033

