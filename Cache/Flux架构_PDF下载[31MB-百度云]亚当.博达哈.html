Flux架构 PDF下载 亚当.博达哈 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712131600
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712131600
<p>书名:Flux架构</p><p>作者:亚当.博达哈</p><p>页数:304</p><p>定价:¥89.0</p><p>出版社:电子工业出版社</p><p>出版日期:2017-07-01</p><p>ISBN:9787121316005</p><p><h2>本书特色</h2></p>[<p>
Flux 是一套架构模型，将Web 应用的各个主要功能以组件的形式进行划分，并进一步划分子组件。而各组件又以动作、存储器和视图来进行架构分层。整体采用单向数据流的形式进行事件的响应，各组件间也强制按照单向数据流进行相互影响，直至数据流结束。在本书中，先向大家介绍了Flux 是什么，以及简单展示了其基本构建模式。然后从动作、存储器、视图、分发器等核心概念，更为详细地阐述了Flux的架构模式。*后，介绍了Flux 库、测试工具和其对其他相关技术栈的影响。本书适用于前端开发者，以及希望对Flux 架构有深入了解的人群。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书将引导你了解 Flux 设计模式的方方面面，如何去设计和开发基于此的强大的 Web 应用，并构建一个真实的 React 应用来突出 Flux 的强大和简洁，以及 Alt 和 Redux如何使 React 和 Flux 开发变得更加简单。
理解 Flux 模式，同时对你的 React 应用产生影响。
使用 Flux 构建真实的 Web 应用。
在你的应用中处理异步动作。
使用 Immutable.js 实现不可变的存储器。
用可替代的视图组件代替 React.js，比如 jQuery 和 Handlebars。
使用 Jest——Facebook 实现的一个对 Jasmine 的增强库，去对 Flux 架构进行各种测试和基准测试。 </p>]<p><h2>作者简介</h2></p>[<p>　　Adam Boduch 从事大规模JavaScript 开发已经将近10 年。在转行前端之前，他曾使用Python 和Linux 编写过几个大规模的云计算产品。Adam 对复杂度有一些了解，在真实世界的软件系统和应对其扩展上的挑战方面具有实际经验。他写过几本JavaScript 的书，包括《JavaScript 并发》（JavaScript Concurrency），他在研究用户体验创新和高性能方面充满热情。
 
本书由段金辰、马雪琴、李胜、马飞、孙辉翻译。
段金辰从事软件开发大约10年，曾供职于微软、*等世界知名公司，参与或主持过多项大型软件系统的架构和开发，涉及基础类库、云、Web前端、On-premises服务、App等众多方向，精通包括JavaScript在内的多种编程语言。
马雪琴，研究生就读于华中科技大学通信工程专业，其间有幸接触到前端、数据可视化等方向，并且对这些技术感到相见恨晚。现就职于*集团客户体验事业群前端开发团队。平时喜欢宅着看书，学着画画，更喜欢去外面走走看看，安静而不安分。
李胜，前端开发工程师。就职于*集团客户体验事业群前端开发团队，曾在饿了么大前端部门参与实习，热衷于追寻前沿技术。除前端相关技术以外，对游戏开发，Go以及其他后端技术也有一定了解。平时的爱好有动漫和科幻。
马飞，*前端工程师，半路出家进入了互联网行业，热衷于Web技术，同时对工业控制，ARM嵌入式开发有一定的研究，喜欢旅行、电子游戏、运动以及摄影。其微博为@最亚伦。
孙辉，现为*的一只“前端攻城狮”，有多年的物联网及 Web 前端开发经验。爱美食、爱摄影，热爱一切富有创造性的事物。个人主页为http://www.sundway.me。
</p>]<p><h2>目录</h2></p>
    目录 前言 .................................. XIX 1 Flux是什么 .................... 1 Flux是一套模式 ......................... 1数据入口 ............................. 1状态管理 ............................. 2保持同步更新 ..................... 3信息架构 ............................. 4 Flux并不是一个框架 ................. 4 Flux的设计思路问题解决方案 . 5数据流向 ............................. 5可回溯性 ............................. 7通知的一致性 ..................... 8简捷的架构分层 ................. 9低耦合渲染 ......................... 9 Flux组件 ................................... 10动作 ................................... 10分发器 ............................... 11存储器 ............................... 12视图 ................................... 12安装 Flux软件包 ...................... 14小结 ........................................... 16 2 Flux的原则 .................. 17 MV*所面临的挑战 ................... 17关注点分离 ....................... 18级联更新 ........................... 19模型更新的职责 ............... 20单向数据 ................................... 21从开始到结束 ................... 22无毒无害 ........................... 23显式优于隐式 ........................... 23暗藏隐患的更新 ............... 24集中修改状态的地方 ....... 26太多动作？ ....................... 26分层优于嵌套 ........................... 27多组件嵌套 ....................... 27嵌套深度与副作用 ........... 28数据流和分层 ................... 28应用数据和界面状态 ............... 29两个相同的东西 ............... 29强耦合转换 ....................... 30功能中心化 ....................... 31小结 ........................................... 31 3 搭建骨架架构 ............... 32总体组织 ................................... 32目录结构 ........................... 33依赖管理 ........................... 33信息设计 ................................... 34用户不需要了解模型 ....... 34存储器映射用户看到的内容 ......................................... 35和哪些东西协同工作 ....... 36在动作中注入存储器 ............... 36获取 API数据 ................... 36 改变 API资源状态 ........... 42本地动作 ........................... 47存储器和功能域 ....................... 50梳理顶层功能 ................... 50无关紧要的 API数据 ....... 51构造存储器数据 ............... 53模拟视图 ................................... 53找寻失去的数据 ............... 53定位动作 ........................... 54端到端场景 ............................... 56动作清单 ........................... 56存储器清单 ....................... 56视图清单 ........................... 57小结 ........................................... 57 4 创建动作 ...................... 58动作的名称和常量 ................... 58动作命名约定 ................... 58静态动作数据 ................... 59组织动作常量 ................... 62特性动作生成器 ....................... 63什么时候需要模块化 ....... 63模块化架构 ....................... 64模拟数据 ................................... 65模拟已存在的接口 ........... 65模拟新接口 ....................... 66替换动作生成器 ............... 70状态动作生成器 ....................... 71整合其他系统 ................... 72 web socket连接 ................ 73参数化动作生成器 ................... 76删除多余的动作 ............... 76 保持动作的通用性 ........... 77创建衍生动作 ................... 80小结 ........................................... 81 5 异步动作 ...................... 83保持 Flux同步 .......................... 83为什么要同步 ................... 83压缩异步行为 ................... 84异步动作语义 ................... 85创建 API调用 ........................... 87 API是常见的情况 ............ 87 API调用和用户交互 ........ 88结合 API调用 ........................... 92复杂的动作生成器 ........... 93组合动作生成器 ............... 96返回 promise ............................. 97不含 promise的同步 ........ 98组织异步行为 ................... 99错误处理 ......................... 101小结 ......................................... 103 6 改变 Flux存储器的状态 .............................................105适应不断变化的信息 ............. 105变化的 API数据 ............. 105变化的功能 ..................... 106受影响的组件 ................. 107减少重复的存储器数据 ......... 107通用存储器数据 ............. 107注册通用存储器 ............. 108结合通用和专用数据 ..... 112处理存储器的依赖关系 ......... 116等待存储器 ..................... 116 数据依赖 ......................... 118 UI依赖 ............................ 119视图的更新顺序 ..................... 125存储器的注册顺序 ......... 125视图渲染的优先级排序 . 125处理存储器复杂度 ................. 126存储器太多 ..................... 126反思功能域 ..................... 126小结 ......................................... 127 7 视图信息 .....................128传递视图数据 ......................... 128 change事件中的数据 ..... 128视图决定何时渲染 ......... 132保持视图无状态 ..................... 135 UI状态属于存储器 ........ 135不用查询 DOM ............... 135视图的职责 ............................. 136渲染存储器数据 ............. 136子视图结构 ..................... 137用户交互 ......................... 138在 Flux中使用 ReactJS .......... 138设置视图状态 ................. 139组成视图 ......................... 143响应事件 ......................... 146路由和动作 ..................... 149小结 ......................................... 154 8 信息的生命周期 ...........155组件生命周期难题 ................. 155回收不再使用的资源 ..... 156隐藏依赖 ......................... 157 内存泄漏 ......................... 157 Flux结构是静态的 ................. 158单例模式 ......................... 158与模型进行比较 ............. 161静态视图 ......................... 161扩展信息 ................................. 165如何很好地扩展 ............. 165昀小化所需信息 ............. 169扩展的动作 ..................... 169闲置的存储器 ......................... 170删除存储器数据 ............. 170优化闲置的存储器 ......... 173保持存储器数据 ............. 174小结 ......................................... 182 9 不可变的存储器 ...........183放弃隐藏的更新 ..................... 183如何破坏 Flux架构 ........ 184获取存储器数据 ............. 186一切皆不可变 ................. 187强制执行单向数据流 ............. 187纵横交错的单向数据流 . 188过多的存储器？ ............. 189没有足够的动作 ............. 189强制不可变性 ................. 190不可变数据的成本 ................. 195垃圾回收是昂贵的 ......... 196批量转换 ......................... 196抵消成本 ......................... 197使用 Immutable.js ................... 197不可变列表和映射 ......... 198不可变的转换 ................. 201 变化检测 ......................... 204小结 ......................................... 208 10 实现分发器 ................209抽象分发器接口 ..................... 209存储器的注册地 ............. 209分发负载 ......................... 210依赖关系的处理 ............. 211分发器所面临的挑战 ............. 212教育的目的 ..................... 212单例模式的分发器 ......... 212手动注册存储器 ............. 213容易出错的依赖管理 ..... 213构建分发器模块 ..................... 214封装存储器的引用 ......... 214处理依赖 ......................... 215分发动作 ......................... 217优化存储器的注册 ................. 220基础存储器类 ................. 221一个动作方法 ................
