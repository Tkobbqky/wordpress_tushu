MATLAB面向对象编程--从入门到设计模式(第2版) PDF下载 徐潇 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#751242402
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#751242402
<p>书名:MATLAB面向对象编程--从入门到设计模式(第2版)</p><p>作者:徐潇</p><p>页数:未知</p><p>定价:¥69.0</p><p>出版社:北京航空航天大学出版社</p><p>出版日期:2017-10-01</p><p>ISBN:9787512424029</p><p><h2>本书特色</h2></p>[<p>
本书分为4 部分：第1 部分是面向对象编程初级篇，主要介绍MATLAB 面向对象编程的基础知识和语法；第2 部分是面向对象编程中级篇，主要介绍面向对象编程的中高级概念，方便读者在编程中遇到问题时查询；第3 部分是设计模式篇，把面向对象的编程方法应用到实际问题中，并从实际问题中抽象出一般的解决方法，即设计模式；第4 部分是框架篇，主要介绍构建在面向对象和设计模式基础之上的MATLAB测试框架，包括单元测试框架和性能测试框架。
本书既可作为高等院校MATLAB 课程的辅助读物，也可作为从事科学计算、程序设计等工作的科研人员的参考用书。
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书是由MATLAB语言开发工程师撰写的MATLAB编程书籍，凝结了作者多年的科研和工作经验以及对MATLAB语言的深刻理解，旨在推动软件工程的手段在MATLAB科学工程计算项目中的应用，帮助科学家和工程师更有效的解决复杂的科研问题。<br/>本书是市面上*由MATLAB语言开发工程师撰写的MATLAB编程书籍，凝结了作者多年的科研和工作经验以及对MATLAB语言的深刻理解，旨在推动软件工程的手段在MATLAB科学工程计算项目中的应用，帮助科学家和工程师更有效地解决复杂的科研问题。<br/>第2版较第1版增加了100多页的内容，包括单元测试系统、高级数据结构、APP Designer等新版本中才有的内容，更全面，更实用。<br/>本书上一版部分读者评论如下：<br/>MATLAB大型程序开发**，比市面上抄Help的书强太多。这本书主要是讲设计模式的，特别适合有用户界面、存储、计算等多个复杂功能模块的大型程序。用MATLAB的面向对象功能，比用c  之类开发速度能快很多，还能利用积累的MATLAB代码。<br/>这书思路很好，要成为MATLAB高手，此书必读。<br/>——北京网友，*网书评<br/> <br/>实用，通俗易懂，强烈推荐， MATLAB 5年以上编程经验，强烈推荐这本书。<br/>不同于市面上其他一些MATLAB书籍基本靠翻译Help文档，这本书的作者确实花了很多精力介绍自己的经验和理解。在作者通俗易懂的案例下，我对于MATLAB面向对象编程技术有了更加深刻的理解，现在已经开始使用面向对象编程技术，强烈推荐，MATLAB高级编程者使用此书。<br/>——广东网友，*网书评<br/> <br/>通俗易懂，极具实用价值，读得非常畅快。<br/>——北京网友，*网书评<br/>本书是由MATLAB语言开发工程师撰写的MATLAB编程书籍，凝结了作者多年的科研和工作经验以及对MATLAB语言的深刻理解，旨在推动软件工程的手段在MATLAB科学工程计算项目中的应用，帮助科学家和工程师更有效的解决复杂的科研问题。
本书是市面上*由MATLAB语言开发工程师撰写的MATLAB编程书籍，凝结了作者多年的科研和工作经验以及对MATLAB语言的深刻理解，旨在推动软件工程的手段在MATLAB科学工程计算项目中的应用，帮助科学家和工程师更有效地解决复杂的科研问题。
第2版较第1版增加了100多页的内容，包括单元测试系统、高级数据结构、APP Designer等新版本中才有的内容，更全面，更实用。
本书上一版部分读者评论如下：
MATLAB大型程序开发**，比市面上抄Help的书强太多。这本书主要是讲设计模式的，特别适合有用户界面、存储、计算等多个复杂功能模块的大型程序。用MATLAB的面向对象功能，比用c  之类开发速度能快很多，还能利用积累的MATLAB代码。
这书思路很好，要成为MATLAB高手，此书必读。
——北京网友，*网书评
 
实用，通俗易懂，强烈推荐， MATLAB 5年以上编程经验，强烈推荐这本书。
不同于市面上其他一些MATLAB书籍基本靠翻译Help文档，这本书的作者确实花了很多精力介绍自己的经验和理解。
在作者通俗易懂的案例下，我对于MATLAB面向对象编程技术有了更加深刻的理解，现在已经开始使用面向对象编程技术，
强烈推荐，MATLAB高级编程者使用此书。
——广东网友，*网书评
 
通俗易懂，极具实用价值，读得非常畅快。
——北京网友，*网书评
 
本书非常实用，之前一直使用面向过程编程，总是无法合理调节各项参数。看了面向对象才知道什么是高端优雅编程！
——江苏网友， *网书评
 
这本书我买了，以我仅上过一个学期的c  的水平来看 ，很适合初学者，思路较官方手册更简洁（对于入门足够）。我个人觉得，后边的模式设计又对工程来说给了很多设计思路上的指导。
——小木虫网友，程序语言论坛书评
 
作为一名学生，我一直很喜欢北航出的技术类书籍，不仅质量比较好，内容充实，与其他的书籍*的不同就是能从初学者学习的角度来阐述问题，是学习时不可多得的好书。本书也一样，由浅入深，逐层剖析，又不局限于编程和实现细节，加入了很多编程思想和方法，这是一般技术书籍不具备的。
——全文试读网友书评
 
书很好，对于习惯了面向过程的编程人，转换思路可以获取事半功倍的效果。特别是本书不仅介绍语法，更注重面向对象的思想。
——江苏网友，*网书评
 
这本书等了很久了。math一发朋友圈。就果断买了。
——北京网友，*网书评
 
这本书的阅读对象主要是初级用户。本人的知识结构比较老了，正式学的语言是Fortran，像C  、Java这些时髦语言了解较少，仅知道“面向对象编程”的说法，不了解其内涵。因项目需要，想采用MATLAB做二次开发软件的界面（对直观的图形显示要求较高），开始自学MATLAB。起初也看了许多入门的书籍，包括张志涌老师的那本，感觉知识点很多，通读起来比较困难。这本书出版后买了一本，作者作为MATLAB的资深应用者，通过通俗的例子（非专业）将面向对象的含义解释得很清楚，看完有一种豁然开朗的感觉，而且感觉上升了一个档次（当然仅是意识上，离实战还差得远）。
其实面向对象是一种思想，一种解决问题的思路和方法，无论做什么项目都用的到。开展项目前规划好其架构无疑是非常重要的。
——小木虫网友，程序语言论坛书评
 
关于MATLAB面向对象编程的非常推荐的一本书。
——安徽网友，*网书评
 
后面的介绍面向对象的功能真的很引人入胜。
——全文试读网友书评
 
粗略看了一遍，感觉不错，所选“面馆”的例子生动形象，贯穿始终，将面向对象的思想讲得很透彻，原来许多模棱两可的概念现在清楚了，感谢作者的辛勤劳动！
——ilovematlab论坛网友 </p>]<p><h2>作者简介</h2></p>[<p>徐潇：MathWorks开发部MATLAB架构C  高级软件工程师。计算物理学博士，研究方向为电子结构计算、密度泛函算法开发；计算机硕士，研究方向为图像处理。2004年，开始使用MATLAB，在科研编程中遇到了开发大型程序难以维护的困难，花了很多时间用于改进程序但效果总不尽如人意。2009年，开始使用MATLAB面向对象编程，发现工程进度被迅速加快，于是萌生了写一本介绍MATLAB 面向对象编程书的念头。2011年，在美国取得博士学位之后入职MathWorks，从理科科研工作者和多年的MATLAB爱好者，成为一名MATLAB语言的设计开发和实现的软件工程师。2016年，作者在MATLAB中文论坛开辟了技术专栏（http://www.ilovematlab.cn/forum-219-1.html），和大家分享最新的行业应用技术和MATLAB编程理念，旨在推动软件工程中的现代手段在MATLAB科学工程计算项目中的使用，帮助科学家和工程师们更有效地解决复杂的科研问题。本书凝结了作者多年的科研和工作经验以及对MATLAB语言的理解，希望能对各种规模的科学工程计算项目的MATLAB使用者有所启发。
李远：本、硕毕业于北方交通大学，在美国的维克弗斯特大学取得物理学博士学位。2014年回国创建北醒（北京）光子科技有限公司，专注于固态激光雷达的研发和生产，产品应用于无人驾驶、无人机和机器人等领域。希望这本《MATLAB面向对象编程——从入门到设计模式（第2版）》能够给工程科学领域的工作者带来方便，尤其对于一些需要长期使用而且不断更新的程序。</p>]<p><h2>目录</h2></p>
    第1 部分面向对象编程初级篇
第1 章面向过程编程和面向对象编程. . . . . . . . . . . . . . . . . . . . . . . . 3
1.1
什么是面向过程编程. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 3
1.2
什么是面向对象编程. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 4
1.2.1
什么是对象. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 4
1.2.2
什么是类. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 4
1.2.3
什么是统一建模语言. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 6
1.3
面向过程编程有哪些局限性. . . . . . . . . . . . . . . . . .
. . . . . . . . . . 9
1.4
面向对象编程有哪些优点. . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 13
第2 章MATLAB 面向对象编程入门. . . . . . . . . . . . . . .
. . . . . . . . . 16
2.1
如何定义一个类. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 16
2.2
如何创建一个对象. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 17
2.3
类的属性. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . 19
2.3.1
如何访问对象的属性. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 19
2.3.2
什么是属性的默认值. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . 19
2.3.3
什么是常量属性. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 21
2.3.4
什么是非独立属性. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 21
2.3.5
什么是隐藏属性. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 25
2.4
类的方法. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . 26
2.4.1
如何定义类的方法. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 26
2.4.2
如何调用类的方法. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 27
2.4.3
点调用和函数调用类方法的区别. . . . . . . . . . . . . . . . .
. . . . . . . 29
2.4.4
什么是方法的签名. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 29
2.4.5
类、对象、属性和方法之间的关系. . . . . . . . . . . . . . . .
. . . . . . . 32
2.4.6
如何用disp 方法定制对象的显示. . .
. . . . . . . . . . . . . . . . . . . . . 32
2.5
类的构造函数. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 35
2.5.1
什么是构造函数. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 35
2.5.2
如何在构造函数中给属性赋值. . . . . . . . . . . . . . . . .
. . . . . . . . 36
2.5.3
如何让构造函数接受不同数目的参数. . . . . . . . . . . . . . . .
. . . . . . 36
2.5.4
什么是默认构造函数. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 37
2.5.5
用户一定要定义构造函数吗. . . . . . . . . . . . . . . . . .
. . . . . . . . . 38
2.6
类的继承. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . 39
2.6.1
什么是继承. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 39
2.6.2
为什么子类构造函数需要先调用父类构造函数. . . . . . . . . . . . . .
. . . . 43
2.6.3
在子类方法中如何调用父类同名方法. . . . . . . . . . . . . . . .
. . . . . . 45
2.6.4
什么是多态. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 46
2.7
类之间的基本关系：继承、组合和聚集. . . . . . . . . . . . . . .
. . . . . . 47
2.7.1
如何判断B 能否继承A . . . . . .
. . . . . . . . . . . . . . . . . . . . . . 47
2.7.2
企鹅和鸟之间是不是继承关系. . . . . . . . . . . . . . . . .
. . . . . . . . 48
2.7.3
如何把类组合起来. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 49
2.7.4
什么是组合聚集关系. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 51
2.8
Handle 类的set 和get 方法. . . . . . . . . . . . . . . . . . . . . . . . . . . 52
2.8.1
什么是set 方法. . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . 52
2.8.2
什么是get 方法. . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . 54
2.9
类的属性和方法的访问权限. . . . . . . . . . . . . . . . . .
. . . . . . . . . . 56
2.9.1
什么是public、protected 和private 权限. . . . . . . . . . . . . . . . .
. . 56
2.9.2
如何设置类的属性和方法的访问权限. . . . . . . . . . . . . . . .
. . . . . . 59
2.9.3
如何更细粒度地控制访问权限. . . . . . . . . . . . . . . . .
. . . . . . . . 60
2.9.4
MATLAB 对属性访问的控制与C  和Java 有什么不同. . . . . . . . . . . . 62
2.10
clear classes 到底清除了什么. . . . . . . . . . . . . . . . . . . .
. . . . . . . 63
2.11
对象根据类定义的改变而自动更新. . . . . . . . . . . . . . . .
. . . . . . . . 64
第3 章MATLAB 的句柄类和实体值类. . . . . . . . . . . . . .
. . . . . . . . 66
3.1
引子：参数是如何传递到函数空间中去的. . . . . . . . . . . . . . .
. . . . . 66
3.2
MATLAB 的Value 类和Handle 类. . . . . . . . . . . . . . . . . . . . . . . 70
3.2.1
什么是Value 类和Handle 类. . . . . . . . . . . . . . . . . . . . . . . . . 70
3.2.2
Value 类对象和Handle 类对象复制有什么区别.
. . . . . . . . . . . . . . . . 72
3.2.3
Value 类对象和Handle 类对象赋值有什么区别.
. . . . . . . . . . . . . . . . 73
3.2.4
Value 类对象和Handle 类对象当作函数参数有什么区别. . . . . . . . . . . . . 76
3.2.5
Value 类对象和Handle 类对象作为默认值有什么区别. . . . . . . . . . . . . . 77
3.2.6
什么情况下使用Value 类或Handle 类. . . . . . . . . . . . . . . . . . . . . 78
3.3
类的析构函数（Destructor） . .
. . . . . . . . . . . . . . . . . . . . . . . . . 83
3.3.1
什么是对象的生存周期. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . 83
3.3.2
什么是析构函数. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 84
3.3.3
对Object 使用clear 会发生什么. . . . . . . . . . . . . . . . . . . . . . . . 84
3.3.4
对Object 使用delete 会发生什么. . . . . . . . . . . . . . . . . . . . . . . 85
3.3.5
什么情况下delete 方法会被自动调用. .
. . . . . . . . . . . . . . . . . . . . 88
3.3.6
出现异常时delete 函数如何被调用. .
. . . . . . . . . . . . . . . . . . . . . 91
3.3.7
什么情况下用户需要自己定义一个delete 方法. . . . . . . . . . . . . . . . . 92
第4 章事件和响应. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
95
4.1
事件. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . 95
4.1.1
什么是事件. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 95
4.1.2
如何定义事件和监听事件. . . . . . . . . . . . . . . . . .
. . . . . . . . . . 96
4.1.3
为什么需要事件机制. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 97
4.2
发布者通知观察者，但不传递消息. . . . . . . . . . . . . . . .
. . . . . . . . 98
4.3
发布者通知观察者，并且传递消息. . . . . . . . . . . . . . . .
. . . . . . . . 100
4.4
删除listener . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . 103
第5 章MATLAB 类文件的组织结构. . . . . . . . . . . . . . .
. . . . . . . . . 104
5.1
如何使用其他文件夹中类的定义. . . . . . . . . . . . . . . . .
. . . . . . . . 104
5.2
如何把类的定义和成员方法的定义分开. . . . . . . . . . . . . . .
. . . . . . 105
5.3
如何定义类的局部函数. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 106
5.4
如何使用Package 文件夹管理类. . .
. . . . . . . . . . . . . . . . . . . . . . 108
5.4.1
Package 中的类是如何组织的. . . . . . . . . . . . . . . . . . .
. . . . . . 108
5.4.2
如何使用Package 中的某个类. . .
. . . . . . . . . . . . . . . . . . . . . . 109
5.4.3
如何导入Package 中的所有类. . .
. . . . . . . . . . . . . . . . . . . . . . 109
5.5
函数和类方法重名到底调用谁. . . . . . . . . . . . . . . . .
. . . . . . . . . 109
5.6
Package 中的函数和当前路径上的同名函数谁有优先级. . . . . . . . . . . . 110
第6 章MATLAB 对象的保存和载入. . . . . . . . . . . . . . .
. . . . . . . . . 112
6.1
save 和load 命令. . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . 112
6.1.1
对象的save 和load 操作. . . . . . . . . . . . . . . . . . . . . . . . . . . 112
6.1.2
MAT 文件中保存了对象中的哪些内容. . . . . . . . . . . . . . . . .
. . . . 112
6.1.3
如果类的定义在save 操作之后发生了变化.
. . . . . . . . . . . . . . . . . . 116
6.2
saveobj 和loadobj 方法. . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . 118
6.2.1
如何定义saveobj 方法. . . . .
. . . . . . . . . . . . . . . . . . . . . . . . 118
6.2.2
如何定义loadobj 方法. . . . .
. . . . . . . . . . . . . . . . . . . . . . . . 119
6.3
继承情况下的saveobj 和loadobj 方法. . . . . . . . . . . . . . . . . . . . . . 120
6.3.1
存在继承时如何设计saveobj 方法. .
. . . . . . . . . . . . . . . . . . . . . 120
6.3.2
存在继承时如何设计loadobj 方法. .
. . . . . . . . . . . . . . . . . . . . . 122
6.4
什么是瞬态属性. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 123
6.5
什么是装载时构造（ConstructOnLoad） . . . . . . . . . . . . . . . . . . . . 125
第7 章面向对象的GUI 编程：分离用户界面和模型. . . . . . . . . . . . . .
. . 127
7.1
如何用GUIDE 进行GUI 编程. . . . . . . . . . . . . . . . . . . . . . . . . . 127
7.2
如何用面向过程的方式进行GUI 编程. . .
. . . . . . . . . . . . . . . . . . . 129
7.3
如何用面向对象的方式进行GUI 编程. . .
. . . . . . . . . . . . . . . . . . . 132
4
MATLAB 面向对象编程——从入门到设计模式（第2 版）
7.4
模型类中应该包括什么. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 134
7.5
视图类中应该包括什么. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 135
7.6
控制器类中应该包括什么. . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 138
7.7
如何把Model、View 和Controller 结合起来. . . . . . . . . . . . . . .
. . . 139
7.8
如何测试MVC 的GUI 程序. . . . . . . . . . . . . . . . . . . . . . . . . . . 141
7.9
如何设计多视图的GUI 以及共享数据. . .
. . . . . . . . . . . . . . . . . . . 142
7.10
如何设计GUI 逻辑架构. . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . 147
7.11
如何使用GUI Layout Toolbox 对界面自动布局. . . . . . . . . . . . . . . . 151
7.11.1
为什么需要布局管理器. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . 151
7.11.2
纵向布局器VBox 类. . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . 152
7.11.3
横向布局器HBox 类. . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . 154
7.11.4
选项卡布局器TabPanel 类. . . .
. . . . . . . . . . . . . . . . . . . . . . . 155
7.11.5
网格布局器Grid 类. . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . 156
7.11.6
GUI Layout 的复合布局. . . . . . . . . . . . . . . . . . . . .
. . . . . . . 157
7.11.7
把GUI Layout Toolbox 和MVC
模式结合起来. . . . . . . . . . . . . . . . 158
7.11.8
GUI Layout Toolbox 两个版本的说明. . . . . . . . . .
. . . . . . . . . . . 160
第2 部分面向对象编程中级篇
第8 章类的继承进阶. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
163
8.1
继承结构下的构造函数和析构函数. . . . . . . . . . . . . . . .
. . . . . . . . 163
8.1.1
什么情况需要手动调用基类的构造函数. . . . . . . . . . . . . . .
. . . . . . 163
8.1.2
什么情况可以让MATLAB 自动调用基类的构造函数. . . . . . . . . . . . . . 164
8.1.3
常见错误：没有提供默认构造函数. . . . . . . . . . . . . . . .
. . . . . . . 166
8.1.4
在构造函数中调用哪个成员方法. . . . . . . . . . . . . . . . .
. . . . . . . 167
8.1.5
析构函数被调用的顺序是什么. . . . . . . . . . . . . . . . .
. . . . . . . . 168
8.2
MATLAB 的多重继承. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . 169
8.2.1
什么情况下需要多重继承. . . . . . . . . . . . . . . . . .
. . . . . . . . . . 169
8.2.2
什么是多重继承. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 170
8.2.3
构造函数被调用的顺序是什么. . . . . . . . . . . . . . . . .
. . . . . . . . 172
8.2.4
多重继承如何处理属性重名. . . . . . . . . . . . . . . . . .
. . . . . . . . . 172
8.2.5
多重继承如何处理方法重名. . . . . . . . . . . . . . . . . .
. . . . . . . . . 174
8.2.6
什么是钻石继承. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 175
8.2.7
如何同时继承Value 类和Handle 类. . . . . . . . . . . . . . . . . . . . . . 178
8.3
如何禁止类被继承. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 180
第9 章类的成员方法进阶. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
9.1
Derived 类和Base 类同名方法之间有哪几种关系. .
. . . . . . . . . . . . . . 182
9.1.1
Derived 类的方法覆盖Base 类的方法. . . .
. . . . . . . . . . . . . . . . . 182
9.1.2
Derived 类的方法可以扩充Base 类的同名方法. .
. . . . . . . . . . . . . . . 183
9.1.3
Base 类的方法可以禁止被Derived 类重写. .
. . . . . . . . . . . . . . . . . 184
9.2
什么是静态方法. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 184
9.3
同一个类的各个对象如何共享变量. . . . . . . . . . . . . . . .
. . . . . . . . 186
9.3.1
什么情况下各个对象需要共享变量. . . . . . . . . . . . . . . .
. . . . . . . 186
9.3.2
如何共享Constant 属性. . . .
. . . . . . . . . . . . . . . . . . . . . . . . 186
9.3.3
如何共享变量. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 187
第10 章抽象类. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . 189
10.1
什么是抽象类和抽象方法. . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 189
10.2
为什么需要抽象类. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 190
10.3
如何使用抽象类. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 191
10.3.1
抽象类不能直接用来声明对象. . . . . . . . . . . . . . . . .
. . . . . . . . 191
10.3.2
子类要实现所有的抽象方法. . . . . . . . . . . . . . . . . .
. . . . . . . . . 192
第11 章对象数组. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. 195
11.1
如何把对象串接成数组. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 195
11.2
如何直接声明对象数组. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 196
11.3
如何使用findobj 函数寻找特定的对象.
. . . . . . . . . . . . . . . . . . . . . 199
11.4
如何利用元胞数组把不同类的对象组合到一起. . . . . . . . . . . . . .
. . . 201
11.5
什么是转换函数. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 203
11.6
如何利用转换函数把不同类的对象组合到一起. . . . . . . . . . . . . .
. . . 204
11.7
如何用非同类（Heterogeneous）数组盛放不同类对象. . . . . . . . . . . . . 205
11.7.1
为什么需要非同类数组. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . 205
11.7.2
含有不同类对象的数组类型. . . . . . . . . . . . . . . . . .
. . . . . . . . . 207
11.7.3
使用非同类要避免哪些情况. . . . . . . . . . . . . . . . . .
. . . . . . . . . 209
11.7.4
如何向量化遍历数组中对象的属性. . . . . . . . . . . . . . . .
. . . . . . . 209
11.7.5
如何设计成员方法使其支持向量化遍历. . . . . . . . . . . . . . .
. . . . . . 211
第12 章类的运算符重载. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
12.1
理解MATLAB 的subsref 和subsasgn 函数. . . . . . . . . . . . . . . . .
. 213
12.1.1
MATLAB 如何处理形如a(1,:) 的表达式. . .
. . . . . . . . . . . . . . . . . 213
12.1.2
MATLAB 如何处理形如a{1,:} 的表达式. . .
. . . . . . . . . . . . . . . . . 214
12.1.3
MATLAB 如何处理形如s.f 的表达式. . . . .
. . . . . . . . . . . . . . . . . 215
12.2
如何重载subsref 函数. . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . 216
6
MATLAB 面向对象编程——从入门到设计模式（第2 版）
12.3
如何重载subsasgn 函数. . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . 217
12.4
什么情况下重载下标运算符. . . . . . . . . . . . . . . . . .
. . . . . . . . . . 218
12.5
如何重载plus 函数. . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . 219
12.6
MATLAB 的Dispatching 规则是什么. . .
. . . . . . . . . . . . . . . . . . . 220
12.7
如何判断两个对象是否相同. . . . . . . . . . . . . . . . . .
. . . . . . . . . . 221
12.8
如何让一个对象在行为上像一个函数. . . . . . . . . . . . . . . .
. . . . . . . 223
12.9
MATLAB 中哪些运算符允许重载. . . . . . . . . . . . . . . . . . .
. . . . . 226
12.10
实例：运算符重载和量纲分析. . . . . . . . . . . . . . . . .
. . . . . . . . . 227
12.10.1
如何表示量纲. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 227
12.10.2
需求和设计：加法和减法. . . . . . . . . . . . . . . . . .
. . . . . . . . . 229
12.10.3
需求和设计：乘法和除法. . . . . . . . . . . . . . . . . .
. . . . . . . . . 232
第13 章枚举类型. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. 237
13.1
为什么需要枚举类型(Enumeration) . . . . . . . . . . . .
. . . . . . . . . . . 237
13.2
什么是枚举类型. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 241
13.3
枚举类型应用实例. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 243
13.3.1
枚举类型的属性. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 243
13.3.2
枚举类型的方法. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 244
13.3.3
枚举类型对象数组. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 246
13.3.4
从基本数据类型中派生枚举类型. . . . . . . . . . . . . . . . .
. . . . . . . 247
第14 章超类. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . 249
14.1
什么是超类. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . 249
14.2
如何获得一个类的meta.class 对象.
. . . . . . . . . . . . . . . . . . . . . . . 250
14.3
meta.class 对象中有些什么内容. . . . . . . . . . . . . . . . . . .
. . . . . . 252
14.4
如何手动克隆一个对象. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 253
14.5
如何使用matlab.mixin.Copyable 自动克隆一个对象. . . . . . . . . . . . . . 259
第3 部分设计模式篇
第15 章面向对象程序设计的基本思想. . . . . . . . . . . . . . . . . . . . . . . . 265
15.1
单一职责原则. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 266
15.2
开放与封闭原则. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 268
15.3
多用组合少用继承原则. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 269
15.4
面向接口编程. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 271
第16 章创建型模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
276
16.1
工厂模式：构造不同种类的面条. . . . . . . . . . . . . . . . .
. . . . . . . . 276
16.1.1
简单工厂模式. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 276
16.1.2
工厂模式. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 280
16.1.3
工厂模式总结. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 282
16.1.4
如何进一步去掉switch/if 语句. .
. . . . . . . . . . . . . . . . . . . . . . . 283
16.1.5
抽象工厂. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 285
16.1.6
抽象工厂模式总结. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 287
16.2
单例模式：给工程计算添加一个LOG 文件. .
. . . . . . . . . . . . . . . . . 288
16.2.1
如何控制对象的数量. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 288
16.2.2
如何删除一个Singleton 对象. . .
. . . . . . . . . . . . . . . . . . . . . . . 290
16.2.3
应用：如何包装一个对象供全局使用. . . . . . . . . . . . . . . .
. . . . . . 291
16.3
建造者模式：如何用MATLAB 构造一辆自行车.
. . . . . . . . . . . . . . . 293
16.3.1
问题的提出. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 293
16.3.2
应用：建造者模式为大规模计算做准备工作. . . . . . . . . . . . . .
. . . . . 297
16.3.3
建造者模式总结. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 298
第17 章装饰者模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
302
17.1
装饰者模式的引入. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 302
17.2
面馆菜单代码. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 304
17.3
装饰者模式总结. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 306
第18 章行为模式. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. 308
18.1
观察者模式：用MATLAB 实现观察者模式.
. . . . . . . . . . . . . . . . . . 308
18.1.1
发布和订阅的基本模型. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . 308
18.1.2
订阅者查询发布者的状态. . . . . . . . . . . . . . . . . .
. . . . . . . . . . 311
18.1.3
把发布者和订阅者抽象出来. . . . . . . . . . . . . . . . . .
. . . . . . . . . 312
18.1.4
观察者模式总结. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 313
18.2
策略模式：分离图像数据和图像处理算法. . . . . . . . . . . . . . .
. . . . . 316
18.2.1
问题的提出. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 316
18.2.2
应用：更复杂的分离数据和算法的例子. . . . . . . . . . . . . . .
. . . . . . 320
18.2.3
策略模式总结. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 321
18.3
遍历器模式：工程科学计算中如何遍历大量数据. . . . . . . . . . . . .
. . . 323
18.3.1
问题的提出. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 323
18.3.2
聚集和遍历器. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 324
18.3.3
遍历器模式总结. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 328
18.4
状态模式：用MATLAB 模拟自动贩卖机. .
. . . . . . . . . . . . . . . . . . 329
18.4.1
使用if 语句的自动贩卖机. . . . .
. . . . . . . . . . . . . . . . . . . . . . 329
8
MATLAB 面向对象编程——从入门到设计模式（第2 版）
18.4.2
使用状态模式的自动贩卖机. . . . . . . . . . . . . . . . . .
. . . . . . . . . 335
18.4.3
状态模式总结. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 340
18.5
模板模式：下面条和煮水饺有什么共同之处. . . . . . . . . . . . . .
. . . . . 341
18.5.1
抽象下面条和煮水饺的过程. . . . . . . . . . . . . . . . . .
. . . . . . . . . 341
18.5.2
应用：把策略和模板模式结合起来. . . . . . . . . . . . . . . .
. . . . . . . 346
18.5.3
模板模式总结. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 347
18.6
备忘录模式：实现GUI 的undo 功能. . . . . . . . . . . . . . . . . . . . . . 348
18.6.1
如何记录对象的内部状态. . . . . . . . . . . . . . . . . .
. . . . . . . . . . 348
18.6.2
应用：如何利用备忘录模式实现GUI 的do 和undo 操作. . . . . . . . . . . . 351
18.6.3
备忘录模式总结. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 356
第4 部分框架篇
第19 章MATLAB 单元测试框架. . . . . . . . . . . . . . . .
. . . . . . . . . . 359
19.1
框架概述. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . 359
19.2
基于函数的单元测试构造. . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 359
19.3
getArea 函数的单元测试: 版本I . . . . .
. . . . . . . . . . . . . . . . . . . . 361
19.4
getArea 函数的单元测试: 版本II 和版本III . . . . . . . . . . . . . . . . . . 366
19.5
测试的准备和清理工作: Test Fixture . . . . . . . . . . .
. . . . . . . . . . . 369
19.6
验证方法: Types of Qualification . . . . . . . . .
. . . . . . . . . . . . . . . . 371
19.7
测试方法论和用测试驱动开发. . . . . . . . . . . . . . . . .
. . . . . . . . . 375
19.7.1
开发流程概述. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 375
19.7.2
用测试驱动开发：fibonacci 例. .
. . . . . . . . . . . . . . . . . . . . . . . 377
19.7.3
用测试驱动开发：运算符重载和量纲分析. . . . . . . . . . . . . . .
. . . . . 381
19.8
基于类的单元测试. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 393
19.8.1
getArea 函数的基于类的单元测试. . . . . . . . . . . . . . . . . .
. . . . . 393
19.8.2
MVC GUI 的基于类的单元测试. . . . . . . . . . . . . . . . . . .
. . . . . 395
第20 章MATLAB 性能测试框架. . . . . . . . . . . . . . . .
. . . . . . . . . . 401
20.1
为什么需要MATLAB 性能测试框架. . .
. . . . . . . . . . . . . . . . . . . . 401
20.2
基于类的性能测试框架. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 403
20.2.1
构造测试类. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 403
20.2.2
测试结果解析. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . 405
20.3
误差范围和置信区间. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 407
20.4
性能测试的适用范围讨论. . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 410
附录
附录A 综合实例：如何把面向过程的程序转成面向对象的程序. . . . . . . . . . . 413
附录B MATLAB 高级数据结构：containers.Map . . . . . . . . . . . . . . . 425
B.1
containers.Map 简介. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . 425
B.2
数组、元胞数组和结构体的局限性. . . . . . . . . . . . . . . .
. . . . . . . . 426
B.3
用containers.Map 来记录电话号码簿. . . . . . . . . . . . . . . . . . . . . . 428
B.4
containers.Map 的属性和成员方法. . . . . . . . . . . . . . . . . . . .
. . . . 429
B.5
containers.Map 的特点. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . 430
B.5.1
containers.Map 可以不断地扩张且不需要预分配. . . . . . . . . . . . . . . .
430
B.5.2
containers.Map 可以作为参数在函数内部直接修改. . . . . . . . . . . . . . .
431
B.5.3
containers.Map 可以增强程序的可读性. . . . . . . . . . . . . . . . . . .
. . 431
B.5.4
containers.Map 提供对数据的快速查找. . . . . . . . . . . . . . . . . . .
. . 431
B.6
containers.Map 的使用实例. . . . . . . . . . . . . . . . . . . . .
. . . . . . . 433
B.6.1
用来存放元素周期表. . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 433
B.6.2
用来实现快速检索. . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . 433
附录C MATLAB 高级数据结构：table . . . . . . . . . . . . . . . . . . . . . . 435
C.1
table 简介. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 435
C.1.1
为什么需要table 数据结构. . . .
. . . . . . . . . . . . . . . . . . . . . . . 435
C.1.2
通过导入数据构造table 对象. . . .
. . . . . . . . . . . . . . . . . . . . . . 436
C.1.3
调用table 构造函数来构造table 对象. . . . . . . . . . . . . . . . . . . . . 436
C.1.4
通过转换函数构造table 对象. . . .
. . . . . . . . . . . . . . . . . . . . . . 437
C.2
访问table 中的数据. . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . 438
C.3
table 的操作. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . 439
C.3.1
删除行列. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 439
C.3.2
添加行列. . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 440
C.3.3
合并table . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . 441
C.3.4
操作列数据. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 442
C.3.5
排序. . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 444
C.3.6
筛选和查找. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 445
C.3.7
输出到文件. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 445
C.4
其他数据类型之间和table 相互转换. .
. . . . . . . . . . . . . . . . . . . . . 446
C.5
table 之间的操作. . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . 449
C.6
table 的属性和支持的操作. . . . . . . . . . . . . . . . . . .
. . . . . . . . . 452
10
MATLAB 面向对象编程——从入门到设计模式（第2 版）
附录D 对函数的输入进行检查和解析. . . . . . . . . . . . . . . . . . . . . . . . 454
D.1
为什么要对函数的输入进行检查. . . . . . . . . . . . . . . . .
. . . . . . . . 454
D.2
validateattributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . 454
D.2.1
validateattributes 的基本使用. . . . . . . . . . .
. . . . . . . . . . . . . . 454
D.2.2
validateattributes 的额外提示信息. . . . . . . . . .
. . . . . . . . . . . . . 455
D.2.3
validateattributes 支持的检查类型和属性. . . . . . . .
. . . . . . . . . . . . 457
D.3
validatestring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . 458
D.4
inputParser . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . 459
D.4.1
inputParser 的基本使用. . . . . . . . . . . . . . . . . . . . .
. . . . . . . 459
D.4.2
inputParser 的可选参数和默认参数值设置. . . . . . . . . . . . . . . . .
. . 461
D.4.3
inputParser 和validateattributes 联合使用. . . . . . . . . . . . . . . . . . . 462
D.4.4
inputParser 的参数名–参数值对的设置. . . . . . . . . . . . . . . . . .
. . . 462
D.4.5
inputParser 解析结构体的输入. . . . . . . . . . . . . . . . . . . .
. . . . . 465
D.5
引子：为什么需要MATLAB 的单元测试系统.
. . . . . . . . . . . . . . . . 466
参考文献. . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 468
写在*后. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . 469
