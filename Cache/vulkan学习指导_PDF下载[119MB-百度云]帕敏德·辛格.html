vulkan学习指导 PDF下载 帕敏德·辛格 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711164786
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711164786
<p>书名:vulkan学习指导</p><p>作者:帕敏德·辛格</p><p>页数:348</p><p>定价:¥99.0</p><p>出版社:机械工业出版社</p><p>出版日期:2020-04-28</p><p>ISBN:9787111647867</p><p><h2>本书特色</h2></p>[<p>
Vulkan是新一代的图形和计算API，是Khronos推出的产品。该API继承自OpenGL，为开发者提供了极大的灵活性与高性能。<br/>本书将首先介绍Vulkan系统的基本原理，尝试与硬件设备进行连接并查询可用的队列、内存类型，以及提供的功能。Vulkan很冗长，所以在深入编程之前，开发者需要首先理解相关的调试技巧，这样即使是新手也可以使用Vulkan的层和扩展特性来排除一些常见错误。<br/>通过阅读本书，你将学到：<br/>学习Vulkan编程模型的基本知识，理解现代GPU设备的基本功能。<br/>实现设备、指令缓存，以及队列的功能，与物理硬件设备进行连接。<br/>了解Vulkan中的验证层概念，学习调试方法与技巧。<br/>深入理解内存管理的知识，控制宿主机和设备端的内存操作。<br/>理解和实现缓存与图像资源的类型。使用线性和优化类型的纹理。Vulkan是新一代的图形和计算API，是Khronos推出的产品。该API继承自OpenGL，为开发者提供了极大的灵活性与高性能。
本书将首先介绍Vulkan系统的基本原理，尝试与硬件设备进行连接并查询可用的队列、内存类型，以及提供的功能。Vulkan很冗长，所以在深入编程之前，开发者需要首先理解相关的调试技巧，这样即使是新手也可以使用Vulkan的层和扩展特性来排除一些常见错误。
通过阅读本书，你将学到：学习Vulkan编程模型的基本知识，理解现代GPU设备的基本功能。
实现设备、指令缓存，以及队列的功能，与物理硬件设备进行连接。
了解Vulkan中的验证层概念，学习调试方法与技巧。
深入理解内存管理的知识，控制宿主机和设备端的内存操作。
理解和实现缓存与图像资源的类型。使用线性和优化类型的纹理。
定义渲染通道中的绘制操作，实现完整的图形流水线。
通过SPIR-V管理GLSL着色器，使用描述符集和推送常数来更新着色器资源。
学习绘制的过程、同步资源，并通过交换链将3D场景渲染到屏幕上。

                                        </p>]<p><h2>内容简介</h2></p>[<p>本书将帮助你从零开始学习Vulkan。
Vulkan是新一代的跨平台图形和计算API接口。尽管它是以OpenGL API的继承者的身份出现的，但是它实际上是一套经过了底层全部重新设计的API，可以满足使用者的更多竞争性需求，并且与底层GPU硬件之间的联系更为紧密。
本书将手把手地帮助初学者逐步掌握这些内容，通过简单易懂的例子来完成每个章节的学习。本书的各个章节之间是循序渐进的，新的一章总是构建于前一章的内容之上，这样读者可以更好地理解各个功能模块之间的细节差异。
本书实战性很强，目的就是帮助读者学习Vulkan的思想、概念以及API标准，并且通过随书的案例来进行实践。本书中涉及大量的参考文献，读者可以从中了解到更多的相关概念，在学习和实践过程中巩固自己的基础知识。 </p>]<p><h2>作者简介</h2></p>[<p>敏德·辛格（Parminder Singh）
新加坡Blackmagic Design公司的计算机图形学工程师。在过去的十年里，他一直致力于网络模拟、几何建模、导航、自动驾驶、信息娱乐系统、图像处理及后期制作等领域的图形学软件开发。他的研究主要包括泛图形的GPU编程、通用计算，平台移植以及性能优化技术。</p>]<p><h2>目录</h2></p>
    
第1章　开始学习新一代3D图形API 11.1　Vulkan及其演化史1
1.2　Vulkan与OpenGL的对比2
1.3　重要术语4
1.4　Vulkan的原理5
1.4.1　Vulkan的执行模型5
1.4.2　Vulkan的队列6
1.4.3　对象模型7
1.4.4　对象生命周期与指令语法7
1.4.5　错误检查与验证8
1.5　理解Vulkan应用程序8
 1.5.1　驱动8
1.5.2　应用程序9
1.5.3　WSI9
1.5.4　SPIR-V9
1.5.5　LunarG SDK9
1.6　开始学习Vulkan编程模型9
1.6.1　硬件初始化10
1.6.2　窗口展示表面11
1.6.3　资源设置12
1.6.4　流水线设置14
1.7　总结18
 第2章　你的**个Vulkan伪代码程序192.1　Vulkan的安装19
2.2　Hello World伪代码20
2.2.1　初始化—与设备握手的过程21
2.2.2　交换链初始化—查询WSI扩展24
2.2.3　着色器支持—将着色器编译到SPIR-V32
2.2.4　构建布局—描述符与流水线布局33
2.2.5　创建渲染通道—定义通道属性34
2.2.6　帧缓存—将绘制图像关联到渲染通道35
2.2.7　产生几何体—在GPU内存中保存一个顶点36
2.2.8　流水线状态管理—创建流水线38
2.2.9　执行渲染通道—显示Hello World!!!41
2.2.10　队列的提交和同步—发送任务43
2.2.11　使用展示层进行显示—渲染三角形44
2.3　全部整合到一起45
2.4　总结46
 第3章　连接硬件设备473.1　学习使用LunarG SDK48
3.2　使用CMake设置我们的**个工程49
3.3　扩展简介53
3.4　创建一个Vulkan实例58
3.5　理解物理设备和逻辑设备65
3.5.1　物理设备65
3.5.2　逻辑设备69
3.6　理解队列和队列族71
3.6.1　查询队列族72
3.6.2　创建队列74
3.7　整合设备和队列的代码76
3.8　总结78
 第4章　调试Vulkan程序804.1　初探Vulkan中的调试方法81
4.2　了解LunarG验证层及其特性82
4.3　在Vulkan程序中实现调试83
4.4　总结90
 第5章　Vulkan中的指令缓存和内存管理915.1　开始使用指令缓存91
5.1.1　显式同步92
5.1.2　指令缓存中的指令类型93
5.1.3　指令缓存与队列94
5.2　理解指令池和指令缓存API94
5.2.1　创建指令池95
5.2.2　指令缓存的分配97
5.3　记录指令缓存99
5.3.1　队列提交100
5.3.2　队列等待101
5.4　实现指令缓存的封装类101
5.4.1　实现指令缓存的分配过程102
5.4.2　记录指令缓存的分配过程103
5.4.3　提交指令到队列104
5.5　管理Vulkan内存105
5.5.1　宿主机内存105
5.5.2　设备内存106
5.5.3　分配设备内存108
5.5.4　释放设备内存110
5.5.5　从宿主机访问设备内存110
5.5.6　延迟分配内存111
5.6　总结112
 第6章　图像资源分配与交换链构建1136.1　什么是图像资源113
6.2　了解图像资源116
6.2.1　创建图像116
6.2.2　理解图像的布局120
6.2.3　创建图像视图121
6.3　内存分配和图像资源的绑定122
6.3.1　获取内存分配的需求条件123
6.3.2　在设备端分配物理内存123
6.3.3　将分配的内存绑定到图像对象124
6.4　交换链简介124
6.4.1　了解交换链实现的工作流125
6.4.2　交换链实现类的框图127
6.4.3　渲染器—窗口管理的自定义类127
6.4.4　VulkanSwapChain—交换链的管理类132
6.4.5　使用WSI创建表面并关联到窗口135
6.4.6　支持画面展示的图形队列137
6.4.7　查询交换链的图像格式138
6.4.8　创建交换链139
6.5　创建一个深度图147
6.5.1　平铺简介147
6.5.2　创建深度缓存图像对象149
6.5.3　获取深度图的内存需求150
6.5.4　判断内存的类型151
6.5.5　将物理内存分配并绑定到深度图像151
6.5.6　图像布局变换152
6.5.7　图像布局变换与内存屏障152
6.5.8　创建图像视图156
6.6　总结程序流程157
6.6.1　初始化157
6.6.2　渲染—显示输出窗口158
6.7　总结158
 第7章　缓存资源、渲染通道、帧缓存以及SPIR-V着色器1607.1　理解Vulkan的缓存资源类型161
7.1.1　创建缓存资源对象161
7.1.2　创建缓存视图162
7.2　使用缓存资源创建几何体164
7.2.1　准备几何体数据164
7.2.2　创建顶点缓存164
7.2.3　缓存创建概述165
7.2.4　实现一个缓存资源—创建几何体的顶点缓存166
7.2.5　理解代码流线169
7.3　理解渲染通道171
7.3.1　附件171
7.3.2　子通道172
7.3.3　渲染通道对应的Vulkan API172
7.3.4　实现渲染通道176
7.4　使用渲染通道来创建帧缓存179
7.5　清除背景颜色182
7.5.1　设置渲染通道实例的背景颜色183
7.5.2　渲染颜色背景185
7.6　在Vulkan中实现着色器186
7.6.1　SPIR-V简介187
7.6.2　将GLSL着色器编译为SPIR-V188
7.6.3　实现着色器190
7.7　总结197
 第8章　流水线和流水线状态管理1998.1　开始学习流水线199
8.2　通过PCO缓冲流水线对象203
8.2.1　创建流水线缓冲对象203
8.2.2　合并流水线缓冲204
8.2.3　从流水线缓冲获取数据205
8.2.4　实现PCO206
8.3　创建图形流水线207
8.3.1　实现图形流水线209
8.3.2　销毁流水线211
8.4　理解计算流水线211
8.5　Vulkan的流水线状态对象213
8.5.1　动态状态214
8.5.2　顶点输入状态216
8.5.3　输入装配状态217
8.5.4　光栅化224
8.5.5　融混226
8.5.6　视口管理229
8.5.7　深度测试和模板测试230
8.5.8　多重采样状态232
8.6　实现流水线235
8.7　总结237
 第9章　绘制对象2389.1　概述Vulkan中的绘制过程238
9.2　准备绘制对象240
9.2.1　录制渲染通道指令240
9.2.2　绑定流水线对象244
9.2.3　设置绘制对象的几何体信息245
9.2.4　定义动态视口246
9.2.5　裁切248
9.2.6　绘制指令249
9.2.7　可绘制对象的准备过程250
9.3　渲染当前可绘制对象252
9.3.1　获取交换链图像253
9.3.2　执行绘制的指令缓存对象254
9.3.3　使用展示引擎显示输出内容254
9.3.4　实现可绘制对象的渲染256
9.4　渲染索引几何体259
9.5　理解Vulkan中的同步图元262
9.5.1　栅栏262
9.5.2　信号量265
9.5.3　事件266
9.6　改变显示窗口的大小269
9.7　总结271
 第10章　描述符与推送常数27310.1　理解描述符的概念273
10.1.1　VulkanDescriptor—用户自定义的描述符类274
10.1.2　描述符集布局275
10.1.3　理解流水线布局279
10.1.4　描述符池281
10.1.5　创建描述符集的资源283
10.1.6　创建描述符集287
10.2　如何在Vulkan中实现一致变量292
10.2.1　预备条件292
10.2.2　执行模型概述293
10.2.3　初始化294
10.2.4　渲染296
10.2.5　更新297
10.3　推送常数的更新299
10.3.1　定义着色器中的推送常数299
10.3.2　更新流水线布局以及推送常数300
10.3.3　更新资源数据301
10.4　总结304
 第11章　绘制纹理30511.1　图像资源快速回顾305
11.2　纹理绘制的准备工作306
11.2.1　设置纹理坐标307
11.2.2　更新着色器程序307
11.2.3　加载图像文件308
11.2.4　本地图像数据结构309
11.3　实现线性平铺的图像资源310
11.3.1　加载图像文件311
11.3.2　创建图像对象311
11.3.3　内存分配和绑定313
11.3.4　存储数据到设备内存314
11.3.5　创建指令缓存对象315
11.3.6　设置图像布局315
11.3.7　提交指令缓存315
11.3.8　创建一个图像采样器316
11.3.9　滤波318
11.3.10　边界截取方式319
11.3.11　创建图像视图321
11.4　使用优化平铺实现图像资源322
11.4.1　加载图像文件322
11.4.2　缓存对象的内存分配和绑定322
11.4.3　存储数据到设备内存323
11.4.4　创建图像对象324
11.4.5　图像对象内存的分配和绑定324
11.4.6　创建指令缓存对象325
11.4.7　设置图像布局325
11.4.8　缓存到图像副本325
11.4.9　设置优化的图像布局参数326
11.4.10　提交指令缓存327
11.4.11　创建图像采样器327
11.4.12　创建图像视图328
11.5　在图像和缓存之间复制数据329
11.6　更新描述符集330
11.7　总结332
