EFFECTIVE JAVA(第3版)(英文版) PDF下载 （美）JoshuaBloch（约书亚· 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712134260
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712134260
<p>书名:EFFECTIVE JAVA(第3版)(英文版)</p><p>作者:（美）Joshua Bloch（约书亚·</p><p>页数:404</p><p>定价:¥99.0</p><p>出版社:电子工业出版社</p><p>出版日期:2017-06-01</p><p>ISBN:9787121342608</p><p><h2>本书特色</h2></p>[<p>
自从Java 6发布之后，Java又有了翻天覆地的变化。本书涵盖了Java 7、Java 8和Java 9中语言和库的各种新特性。让你能够深入了解Java平台的细微之处。通过对每一个项目的全面描述和解释，告诉你应该做什么、不应该做什么，以及为什么要这样做。
                                        </p>]<p><h2>内容简介</h2></p>[<p>自从Java 6发布之后，Java又有了翻天覆地的变化。本书涵盖了Java 7、Java 8和Java 9中语言和库的各种新特性。让你能够深入了解Java平台的细微之处。通过对每一个项目的全面描述和解释，告诉你应该做什么、不应该做什么，以及为什么要这样做。</p>]<p><h2>作者简介</h2></p>[<p>Joshua Bloch是Java 集合框架创办人，领导了很多 Java 平台特性的设计和实现，包括 JDK 5.0 语言增强以及屡获殊荣的 Java 集合框架。2004年6月他离开了SUN公司并成为 Google 的首席 Java 架构师。此外他还因为《Effective Java》一书获得著名的 Jolt 大奖。<br/>Joshua Bloch是Java 集合框架创办人，领导了很多 Java 平台特性的设计和实现，包括 JDK 5.0 语言增强以及屡获殊荣的 Java 集合框架。2004年6月他离开了SUN公司并成为 Google 的首席 Java 架构师。此外他还因为《Effective Java》一书获得著名的 Jolt 大奖。</p>]<p><h2>目录</h2></p>
    1 Introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12 Creating and Destroying Objects . . . . . . . . . . . . . . . . . . . . . 5Item 1: Consider static factory methods instead of constructors . . . 5Item 2: Consider a builder when faced with many constructor parameters . .. . . . . . . . 10Item 3: Enforce the singleton property with a private constructor or an enum type . . .  . . . . . . . .  . . . . 17Item 4: Enforce noninstantiability with a private constructor . . . . 19Item 5: Prefer dependency injection to hardwiring resources . . . . 20Item 6: Avoid creating unnecessary objects . . . . . . . . . . . . . . . . . 22Item 7: Eliminate obsolete object references . . . . . . . . . . . . . . . . . 26Item 8: Avoid finalizers and cleaners . . . . . . . . . . . . . . . . . . . . . . 29Item 9: Prefer try-with-resources to try-finally. . . . . . . . . . . . 343 Methods Common to All Objects . . . . . . . . . . . . . . . . . . . . 37Item 10: Obey the general contract when overriding equals . . . . . 37Item 11: Always override hashCode when you override equals . . 50Item 12: Always override toString . . . . . . . . . . . . . . . . . . . . . . . . 55Item 13: Override clone judiciously . . . . . . . . . . . . . . . . . . . . . . . . 58Item 14: Consider implementing Comparable . . . . . . . . . . . . . . . . 664 Classes and Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 73Item 15: Minimize the accessibility of classes and members . . . . . 73Item 16: In public classes, use accessor methods, not public fields 78Item 17: Minimize mutability . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80Item 18: Favor composition over inheritance . . . . . . . . . . . . . . . . . 87Item 19: Design and document for inheritance or else prohibit it 93Item 20: Prefer interfaces to abstract classes . . . . . . . . . . . . . . . . . 99Item 21: Design interfaces for posterity . . . . . . . . . . . . . . . . . . . . 104Item 22: Use interfaces only to define types. . . . . . . . . . . . . . . . . 107Item 23: Prefer class hierarchies to tagged classes . . . . . . . . . . . . 109Item 24: Favor static member classes over nonstatic . . . . . . . . . . 112Item 25: Limit source files to a single top-level class . . . . . . . . . 1155 Generics. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117Item 26: Don’t use raw types . . . . . . . . . . . . . . . . . . . . . . . . . . . . 117Item 27: Eliminate unchecked warnings. . . . . . . . . . . . . . . . . . . . 123Item 28: Prefer lists to arrays . . . . . . . . . . . . . . . . . . . . . . . . . . . . 126Item 29: Favor generic types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 130Item 30: Favor generic methods . . . . . . . . . . . . . . . . . . . . . . . . . . 135Item 31: Use bounded wildcards to increase API flexibility . . . . 139Item 32: Combine generics and varargs judiciously. . . . . . . . . . . 146Item 33: Consider typesafe heterogeneous containers . . . . . . . . . 1516 Enums and Annotations . . . . . . . . . . . . . . . . . . . . . . . . . . . 157Item 34: Use enums instead of int constants. . . . . . . . . . . . . . . . 157Item 35: Use instance fields instead of ordinals . . . . . . . . . . . . . . 168Item 36: Use EnumSet instead of bit fields . . . . . . . . . . . . . . . . . . 169Item 37: Use EnumMap instead of ordinal indexing. . . . . . . . . . . . 171Item 38: Emulate extensible enums with interfaces . . . . . . . . . . . 176Item 39: Prefer annotations to naming patterns . . . . . . . . . . . . . . 180Item 40: Consistently use the Override annotation. . . . . . . . . . . 188Item 41: Use marker interfaces to define types . . . . . . . . . . . . . . 1917 Lambdas and Streams . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193Item 42: Prefer lambdas to anonymous classes . . . . . . . . . . . . . . 193Item 43: Prefer method references to lambdas . . . . . . . . . . . . . . . 197Item 44: Favor the use of standard functional interfaces . . . . . . . 199Item 45: Use streams judiciously . . . . . . . . . . . . . . . . . . . . . . . . . 203Item 46: Prefer side-effect-free functions in streams . . . . . . . . . . 210Item 47: Prefer Collection to Stream as a return type. . . . . . . . . . 216Item 48: Use caution when making streams parallel . . . . . . . . . . 2228 Methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 227Item 49: Check parameters for validity . . . . . . . . . . . . . . . . . . . . . 227Item 50: Make defensive copies when needed . . . . . . . . . . . . . . . 231Item 51: Design method signatures carefully . . . . . . . . . . . . . . . . 236Item 52: Use overloading judiciously . . . . . . . . . . . . . . . . . . . . . . 238Item 53: Use varargs judiciously . . . . . . . . . . . . . . . . . . . . . . . . . . 245Item 54: Return empty collections or arrays, not nulls . . . . . . . . . 247Item 55: Return optionals judiciously . . . . . . . . . . . . . . . . . . . . . . 249Item 56: Write doc comments for all exposed API elements . . . . 2549 General Programming . . . . . . . . . . . . . . . . . . . . . . . . . . . . 261Item 57: Minimize the scope of local variables . . . . . . . . . . . . . . . 261Item 58: Prefer for-each loops to traditional for loops . . . . . . . . . 264Item 59: Know and use the libraries . . . . . . . . . . . . . . . . . . . . . . . 267Item 60: Avoid float and double if exact answers are required . 270Item 61: Prefer primitive types to boxed primitives . . . . . . . . . . . 273Item 62: Avoid strings where other types are more appropriate . . 276Item 63: Beware the performance of string concatenation . . . . . . 279Item 64: Refer to objects by their interfaces . . . . . . . . . . . . . . . . . 280Item 65: Prefer interfaces to reflection . . . . . . . . . . . . . . . . . . . . . 282Item 66: Use native methods judiciously. . . . . . . . . . . . . . . . . . . . 285Item 67: Optimize judiciously . . . . . . . . . . . . . . . . . . . . . . . . . . . . 286Item 68: Adhere to generally accepted naming conventions . . . . . 28910 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293Item 69: Use exceptions only for exceptional conditions . . . . . . . 293Item 70: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors . .  296Item 71: Avoid unnecessary use of checked exceptions . . . . . . . . 298Item 72: Favor the use of standard exceptions. . . . . . . . . . . . . . . . 300Item 73: Throw exceptions appropriate to the abstraction. . . . . . . 302Item 74: Document all exceptions thrown by each method. . . . . . 304Item 75: Include failure-capture information in detail messages. . 306Item 76: Strive for failure atomicity . . . . . . . . . . . . . . . . . . . . . . . 308Item 77: Don’t ignore exceptions . . . . . . . . . . . . . . . . . . . . . . . . . 31011 Concurrency . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311Item 78: Synchronize access to shared mutable data . . . . . . . . . . 311Item 79: Avoid excessive synchronization . . . . . . . . . . . . . . . . . . 317Item 80: Prefer executors, tasks, and streams to threads . . . . . . . 323Item 81: Prefer concurrency utilities to wait and notify . . . . . . 325Item 82: Document thread safety . . . . . . . . . . . . . . . . . . . . . . . . . 330Item 83: Use lazy initialization judiciously . . . . . . . . . . . . . . . . . 333Item 84: Don’t depend on the thread scheduler . . . . . . . . . . . . . . 33612 Serialization
