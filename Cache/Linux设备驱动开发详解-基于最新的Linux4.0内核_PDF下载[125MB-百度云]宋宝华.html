Linux设备驱动开发详解-基于最新的Linux4.0内核 PDF下载 宋宝华 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711150789
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711150789
<p>书名:Linux设备驱动开发详解-基于最新的Linux4.0内核</p><p>作者:宋宝华</p><p>页数:618</p><p>定价:¥89.0</p><p>出版社:机械工业出版社</p><p>出版日期:2015-08-01</p><p>ISBN:9787111507895</p><p><h2>本书特色</h2></p>[<p>
本书介绍了linux设备驱动开发理论、框架与实例，详细说明了自旋锁、信号量、完成量、中断顶/底半部、定时器、内存和i/o映射以及异步通知、阻塞i/o、非阻塞i/o等linux设备驱动理论,以及字符设备、块设备、tty设备、i2c设备、lcd设备、音频设备、usb设备、网络设备、pci设备等linux设备驱动架构中各个复杂数据结构和函数的关系，并讲解了linux驱动开发的大量实例，使读者能够独立开发各类linux设备驱动。
                                        </p>]<p><h2>目录</h2></p>
	赞誉推荐序一推荐序二前言第1章 linux设备驱动概述及开发环境构建1.1 设备驱动的作用1.2 无操作系统时的设备驱动1.3 有操作系统时的设备驱动1.4 linux设备驱动1.4.1 设备的分类及特点1.4.2 linux设备驱动与整个软硬件系统的关系1.4.3 linux设备驱动的重点、难点1.5 linux设备驱动的开发环境构建1.5.1 pc上的linux环境1.5.2 qemu实验平台1.5.3 源代码阅读和编辑1.6 设备驱动hello world：led驱动1.6.1 无操作系统时的led驱动1.6.2 linux下的led驱动 第2章 驱动设计的硬件基础2.1 处理器2.1.1 通用处理器2.1.2 数字信号处理器2.2 存储器2.3 接口与总线2.3.1 串口2.3.2 i2c2.3.3 spi2.3.4 usb2.3.5 以太网接口2.3.6 pci和pcie2.3.7 sd和sdio2.4 cpld和fpga2.5 原理图分析2.6 硬件时序分析2.6.1 时序分析的概念2.6.2 典型的硬件时序2.7 芯片数据手册阅读方法2.8 仪器仪表使用2.8.1 万用表2.8.2 示波器2.8.3 逻辑分析仪2.9 总结 第3章 linux内核及内核编程3.1 linux内核的发展与演变3.2 linux 2.6后的内核特点3.3 linux内核的组成3.3.1 linux内核源代码的目录结构3.3.2 linux内核的组成部分3.3.3 linux内核空间与用户空间3.4 linux内核的编译及加载3.4.1 linux内核的编译3.4.2 kconfig和makefile3.4.3 linux内核的引导3.5 linux下的c编程特点3.5.1 linux编码风格3.5.2 gnu c与ansi c3.5.3 do { } while（0） 语句3.5.4 goto语句3.6 工具链3.7 实验室建设3.8 串口工具3.9 总结 第4章 linux内核模块4.1 linux内核模块简介4.2 linux内核模块程序结构4.3 模块加载函数4.4 模块卸载函数4.5 模块参数4.6 导出符号4.7 模块声明与描述4.8 模块的使用计数4.9 模块的编译4.10 使用模块“绕开”gpl4.11 总结 第5章 linux文件系统与设备文件5.1 linux文件操作5.1.1 文件操作系统调用5.1.2 c库文件操作5.2 linux文件系统5.2.1 linux文件系统目录结构5.2.2 linux文件系统与设备驱动5.3 devfs5.4 udev用户空间设备管理5.4.1 udev与devfs的区别5.4.2 sysfs文件系统与linux设备模型5.4.3 udev的组成5.4.4 udev规则文件5.5 总结 第6章 字符设备驱动6.1 linux字符设备驱动结构6.1.1 cdev结构体6.1.2 分配和释放设备号6.1.3 f?ile_operations结构体6.1.4 linux字符设备驱动的组成6.2 globalmem虚拟设备实例描述6.3 globalmem设备驱动6.3.1 头文件、宏及设备结构体6.3.2 加载与卸载设备驱动6.3.3 读写函数6.3.4 seek函数6.3.5 ioctl函数6.3.6 使用文件私有数据6.4 globalmem驱动在用户空间中的验证6.5 总结 第7章 linux设备驱动中的并发控制7.1 并发与竞态7.2 编译乱序和执行乱序7.3 中断屏蔽7.4 原子操作7.4.1 整型原子操作7.4.2 位原子操作7.5 自旋锁7.5.1 自旋锁的使用7.5.2 读写自旋锁7.5.3 顺序锁7.5.4 读复制更新7.6 信号量7.7 互斥体7.8 完成量7.9 增加并发控制后的globalmem的设备驱动7.10 总结 第8章 linux设备驱动中的阻塞与非阻塞i/o8.1 阻塞与非阻塞i/o8.1.1 等待队列8.1.2 支持阻塞操作的globalf?ifo设备驱动8.1.3 在用户空间验证globalf?ifo的读写8.2 轮询操作8.2.1 轮询的概念与作用8.2.2 应用程序中的轮询编程8.2.3 设备驱动中的轮询编程8.3 支持轮询操作的globalf?ifo驱动8.3.1 在globalf?ifo驱动中增加轮询操作8.3.2 在用户空间中验证globalf?ifo设备的轮询8.4 总结 第9章 linux设备驱动中的异步通知与异步i/o9.1 异步通知的概念与作用9.2 linux异步通知编程9.2.1 linux信号9.2.2 信号的接收9.2.3 信号的释放9.3 支持异步通知的globalf?ifo驱动9.3.1 在globalf?ifo驱动中增加异步通知9.3.2 在用户空间中验证globalf?ifo的异步通知9.4 linux异步i/o9.4.1 aio概念与gnu c库aio9.4.2 linux内核aio与libaio9.4.3 aio与设备驱动9.5 总结 第10章 中断与时钟10.1 中断与定时器10.2 linux中断处理程序架构10.3 linux中断编程10.3.1 申请和释放中断10.3.2 使能和屏蔽中断10.3.3 底半部机制10.3.4 实例：gpio按键的中断10.4 中断共享10.5 内核定时器10.5.1 内核定时器编程10.5.2 内核中延迟的工作delayed_work10.5.3 实例：秒字符设备10.6 内核延时10.6.1 短延迟10.6.2 长延迟10.6.3 睡着延迟10.7 总结 第11章 内存与i/o访问11.1 cpu与内存、i/o11.1.1 内存空间与i/o空间11.1.2 内存管理单元11.2 linux内存管理11.3 内存存取11.3.1 用户空间内存动态申请11.3.2 内核空间内存动态申请11.4 设备i/o端口和i/o内存的访问11.4.1 linux i/o端口和i/o内存访问接口11.4.2 申请与释放设备的i/o端口和i/o内存11.4.3 设备i/o端口和i/o内存访问流程11.4.4 将设备地址映射到用户空间11.5 i/o内存静态映射11.6 dma11.6.1 dma与cache一致性11.6.2 linux下的dma编程11.7 总结 第12章 linux设备驱动的软件架构思想12.1 linux驱动的软件架构12.2 platform设备驱动12.2.1 platform总线、设备与驱动12.2.2 将globalf?ifo作为platform设备12.2.3 platform设备资源和数据12.3 设备驱动的分层思想12.3.1 设备驱动核心层和例化12.3.2 输入设备驱动12.3.3 rtc设备驱动12.3.4 framebuffer设备驱动12.3.5 终端设备驱动12.3.6 misc设备驱动12.3.7 驱动核心层12.4 主机驱动与外设驱动分离的设计思想12.4.1 主机驱动与外设驱动分离12.4.2 linux spi主机和设备驱动12.5 总结 第13章 linux块设备驱动13.1 块设备的i/o操作特点13.2 linux块设备驱动结构13.2.1 block_device_operations结构体13.2.2 gendisk结构体13.2.3 bio、request和request_queue13.2.4 i/o调度器13.3 linux块设备驱动的初始化13.4 块设备的打开与释放13.5 块设备驱动的ioctl函数13.6 块设备驱动的i/o请求处理13.6.1 使用请求队列13.6.2 不使用请求队列13.7 实例：vmem_disk驱动13.7.1 vmem_disk的硬件原理13.7.2 vmem_disk驱动模块的加载与卸载13.7.3 vmem_disk设备驱动的block_device_operations13.7.4 vmem_disk的i/o请求处理13.8 linux mmc子系统13.9 总结 第14章 linux网络设备驱动14.1 linux网络设备驱动的结构14.1.1 网络协议接口层14.1.2 网络设备接口层14.1.3 设备驱动功能层14.2 网络设备驱动的注册与注销14.3 网络设备的初始化14.4 网络设备的打开与释放14.5 数据发送流程14.6 数据接收流程14.7 网络连接状态14.8 参数设置和统计数据14.9 dm9000网卡设备驱动实例14.9.1 dm9000网卡硬件描述14.9.2 dm9000网卡驱动设计分析14.10 总结 第15章 linux i2c核心、总线与设备驱动15.1 linux i2c体系结构15.2 linux i2c核心15.3 linux i2c适配器驱动15.3.1 i2c适配器驱动的注册与注销15.3.2 i2c总线的通信方法15.4 linux i2c设备驱动15.4.1 linux i2c设备驱动的模块加载与卸载15.4.2 linux i2c设备驱动的数据传输15.4.3 linux的i2cdev.c文件分析15.5 tegra i2c总线驱动实例15.6 at24xx eeprom的i2c设备驱动实例15.7 总结 第16章 usb主机、设备与gadget驱动16.1 linux usb驱动层次16.1.1 主机侧与设备侧usb驱动16.1.2 设备、配置、接口、端点16.2 usb主机控制器驱动16.2.1 usb主机控制器驱动的整体结构16.2.2 实例：chipidea usb主机驱动16.3 usb设备驱动16.3.1 usb设备驱动的整体结构16.3.2 usb请求块16.3.3 探测和断开函数16.3.4 usb骨架程序16.3.5 实例：usb键盘驱动16.4 usb udc与gadget驱动16.4.1 udc和gadget驱动的关键数据结构与api16.4.2 实例：chipidea usb udc驱动16.4.3 实例：loopback function驱动16.5 usb otg驱动16.6 总结 第17章 i2c、spi、usb驱动架构类比17.1 i2c、spi、usb驱动架构17.2 i2c主机和外设眼里的linux世界 第18章 arm linux设备树18.1 arm设备树起源18.2 设备树的组成和结构18.2.1 dts、dtc和dtb等18.2.2 根节点兼容性18.2.3 设备节点兼容性18.2.4 设备节点及label的命名18.2.5 地址编码18.2.6 中断连接18.2.7 gpio、时钟、pinmux连接18.3 由设备树引发的bsp和驱动变更18.4 常用的of api18.5 总结 第19章 linux电源管理的系统架构和驱动19.1 linux电源管理的全局架构19.2 cpufreq驱动19.2.1 soc的cpufreq驱动实现19.2.2 cpufreq的策略19.2.3 cpufreq的性能测试和调优19.2.4 cpufreq通知19.3 cpuidle驱动19.4 powertop19.5 regulator驱动19.6 opp19.7 pm qos19.8 cpu热插拔19.9 挂起到ram19.10 运行时的pm19.11 总结 第20章 linux芯片级移植及底层驱动20.1 arm linux底层驱动的组成和现状20.2 内核节拍驱动20.3 中断控制器驱动20.4 smp多核启动以及cpu热插拔驱动20.5 debug_ll和early_printk的设置20.6 gpio驱动20.7 pinctrl驱动20.8 时钟驱动20.9 dmaengine驱动20.10 总结 第21章 linux设备驱动的调试21.1 gdb调试器的用法21.1.1 gdb的基本用法21.1.2 ddd图形界面调试工具21.2 linux内核调试21.3 内核打印信息--printk（）21.4 debug_ll和early_printk21.5 使用“/proc”21.6 oops21.7 bug_on（）和warn_on（）21.8 strace21.9 kgdb21.10 使用仿真器调试内核21.11 应用程序调试21.12 linux性能监控与调优工具21.13 总结
