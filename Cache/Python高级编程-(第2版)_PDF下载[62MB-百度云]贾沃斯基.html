Python高级编程-(第2版) PDF下载 贾沃斯基 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546015
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711546015
<p>书名:Python高级编程-(第2版)</p><p>作者:贾沃斯基</p><p>页数:403</p><p>定价:¥89.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-10-01</p><p>ISBN:9787115460158</p><p><h2>本书特色</h2></p>[<p>
Python作为一种高-级程序设计语言，凭借其简洁、易读及可扩展性日渐成为程序设计领域备受推崇的语言之一。
本书基于Python 3.5版本进行讲解，通过13章的内容，深度揭示了Python编程的高-级技巧。本书从Python语言及其社区的现状开始介绍，对Python语法、命名规则、Python包的编写、部署代码、扩展程序开发、管理代码、文档编写、测试开发、代码优化、并发编程、设计模式等重要话题进行了全面系统化的讲解。
本书适合想要进一步提高自身Python编程技能的读者阅读，也适合对Python编程感兴趣的读者参考学习。全书结合典型且实用的开发案例，可以帮助读者创建高性能的、可靠且可维护的Python应用。
                                        </p>]<p><h2>内容简介</h2></p>[<p>Python是一门动态编程语言，它简单而又强大，适用于众多领域。尽管编写Python代码比较容易，但是编写高效且易于维护和复用的代码是一个挑战。
本书的重点是让你熟悉zui佳实践、有用的工具以及标准，这都是Python专业人士每天使用的。首先，你将了解Python 3.5中新增加的功能以及可以提高生产力的快速技巧。接下来，你将学习使用这个新版本中的高-级且有用的Python语法元素，以及实现元编程的不同方法。本书讲解了代码管理工具、编写清晰文档的方法和测试驱动开发，这些都是编写代码的重要因素。通过学习优化的一般原则、查找瓶颈的策略以及应用优化的选定工具，你可以对如何编写高效的代码有更深入的理解。
读完本书后，你会成为一名可以编写高效且可维护代码的专家。
通过阅读本书，你将能够：
了解在Python社区中广泛采用的约定和zui佳实践；
高效打包Python代码，以便将其应用于社区和生产；
应用在远程系统上自动化部署代码的简单且轻量的方法；
提高代码的质量、可靠性及性能；
在Python中编写并发代码；
使用其他语言编写的代码来扩展Python。 </p>]<p><h2>作者简介</h2></p>[<p>Micha? Jaworski有着7年Python编程的经验。他还是graceful的创建者，这是一个构建于falcon之上的REST框架。他曾在不同的公司担任过多种角色，从一名普通的全栈开发人员到软件架构师再到一家快节奏创业公司的工程副总裁。他目前是Opera软件公司TV Store（电视应用商店）团队的首-席后端工程师。他在设计高性能的分布式服务方面拥有丰富的经验。他还是一些流行的Python开源项目的活跃贡献者。
Tarek Ziade?是Mozilla的工程经理，与一个专门用Python为Firefox构建大规模Web应用的团队合作。他对Python打包做出过贡献，而且从早期Zope开始就使用过各种不同的Python Web框架。
Tarek还创建了Afpy——法国的Python用户组，并且用法语写过两本关于Python的书。他还在诸如Solutions Linux、PyCon、OSCON和EuroPython等国际活动中做过多次法语演讲和教学。</p>]<p><h2>目录</h2></p>
     目录
第1章  Python现状     1
1.1 
Python的现状与未来   1
1.2 
Python升级及其原因   2
1.3  追踪Python*新变化——PEP文档    2
1.4  当前Python 3的普及程度    3
1.5 
Python 3和Python 2的主要差异 4
1.5.1 
为什么要关注这些差异    4
1.5.2 
主要的语法差异和常见陷阱    4
1.5.3 
用于保持跨版本兼容性的常用工具和技术    6
1.6  不只是CPython     9
1.6.1 
为什么要关注Python实现        10
1.6.2 
Stackless Python 10
1.6.3 
Jython 10
1.6.4 
IronPython  11
1.6.5 
PyPy     11
1.7 
Python开发的现代方法        12
1.8  应用层Python环境隔离       13
1.8.1 
为什么要隔离    14
1.8.2 
常用解决方案    15
1.8.3 
选择哪种工具    18
1.9  系统级环境隔离   19
1.9.1 
使用Vagrant的虚拟开发环境 20
1.9.2 
容器化与虚拟化的对比    21
1.10 
常用的生产力工具      21
1.10.1 
自定义Python shell—  IPython、bpython、  ptpython等 22
1.10.2 
交互式调试器  24
1.11 
有用的资源 25
1.12 
小结      25
第2章  语法*佳实践——类级别以下     26
2.1 
Python的内置类型        26
2.1.1 
字符串与字节    27
2.1.2 
集合类型    30
2.2  高级语法        39
2.2.1 
迭代器         40
2.2.2 
yield语句    41
2.2.3 
装饰器         44
2.2.4 
上下文管理器—with语句         54
2.3  你可能还不知道的其他语法元素        58
2.3.1 
for...else...语句  58
2.3.2 
函数注解    59
2.4  小结        60
第3章  语法*佳实践—类级别以上 61
3.1  子类化内置类型   61
3.2  访问超类中的方法        63
3.2.1 
Python 2中的旧式类与super   65
3.2.2 
理解Python的方法解析顺序   66
3.2.3 
使用super易犯的错误      70
3.2.4 
*佳实践    73
3.3  高级属性访问模式        73
3.3.1 
描述符         74
3.3.2 
property       79
3.3.3 
槽         81
3.4  元编程   82
3.4.1 
装饰器—
一种元编程方法       83
3.4.2 
类装饰器    83
3.4.3 
使用__new__()方法覆写实例创建过程   85
3.4.4 
元类    87
3.4.5 
一些关于代码生成的提示         94
3.5  小结        100
第4章  选择好的名称 101
4.1 
PEP 8与命名*佳实践 101
4.1.1 
为何要遵守PEP 8以及何时遵守PEP 8    101
4.1.2 
超越PEP 8—团队的风格指南  102
4.2  命名风格        102
4.3  命名指南        110
4.3.1 
用“has”或“is”前缀命名布尔元素    111
4.3.2 
用复数形式命名集合变量         111
4.3.3 
用显式名称命名字典         111
4.3.4 
避免通用名称    111
4.3.5 
避免现有名称    112
4.4  参数的*佳实践   113
4.4.1 
通过迭代设计构建参数    113
4.4.2 
信任参数和测试         114
4.4.3 
小心使用*args和**kwargs魔法参数      115
4.5  类的名称        117
4.6  模块和包的名称   117
4.7  有用的工具   118
4.7.1 
Pylint   118
4.7.2 
pep8和flake8     120
4.8  小结        120
第5章  编写一个包     121
5.1  创建一个包   121
5.1.1 
Python打包工具的混乱状态    122
5.1.2 
项目配置    123
5.1.3 
自定义setup命令      131
5.1.4 
在开发期间使用包    132
5.2  命名空间包   133
5.2.1 
为什么有用         133
5.2.2 
PEP 420—隐式命名空间包        135
5.2.3 
以前Python版本中的命名空间包   136
5.3  上传一个包   137
5.3.1 
PyPI—Python包索引 137
5.3.2 
源代码包与构建包    139
5.4  独立可执行文件   142
5.4.1 
独立可执行文件何时有用         143
5.4.2 
常用工具    143
5.4.3 
可执行包中Python代码的安全性   150
5.5  小结        151
第6章  部署代码 152
6.1  十二要素应用        152
6.2  用Fabric进行自动化部署    154
6.3  你自己的包索引或索引镜像        158
6.3.1 
PyPI镜像     159
6.3.2 
使用包进行部署         160
6.4  常见约定与实践   168
6.4.1 
文件系统层次结构    168
6.4.2 
隔离    168
6.4.3 
使用进程管理工具    169
6.4.4 
应该在用户空间运行应用代码         170
6.4.5 
使用HTTP反向代理  171
6.4.6 
优雅地重新加载进程         171
6.5  代码检测与监控   172
6.5.1 
记录错误—sentry/raven   173
6.5.2 
监控系统与应用指标         175
6.5.3 
处理应用日志    177
6.6  小结        181
第7章  使用其他语言开发Python扩展    182
7.1  使用C或者C  编写扩展    182
7.2  为什么你想用扩展        184
7.2.1 
提高关键代码段的性能    185
7.2.2 
集成现有的使用不同语言编写的代码    185
7.2.3 
集成第三方动态库    185
7.2.4 
创建自定义数据类型         186
7.3  编写扩展        186
7.3.1 
纯C扩展    187
7.3.2 
Cython 201
7.4  挑战        205
7.4.1 
额外的复杂性    205
7.4.2 
调试    206
7.5  无扩展的动态库接口   206
7.5.1 
ctypes 207
7.5.2 
CFFI      212
7.6  小结        214
第8章  管理代码 215
8.1  版本控制系统        215
8.1.1 
集中式系统         215
8.1.2 
分布式系统         217
8.1.3 
集中式还是分布式    219
8.1.4 
尽可能使用Git  219
8.1.5 
Git工作流程与GitHub工作流程      220
8.2  持续的开发过程   223
8.2.1 
持续集成    224
8.2.2 
持续交付    227
8.2.3 
持续部署    227
8.2.4 
常用的持续集成工具         228
8.2.5 
选择正确的工具和常见的陷阱         234
8.3  小结        236
第9章  文档化你的项目     237
9.1 
7项技术写作规则         237
9.1.1 
两步写作    238
9.1.2 
定位读者    238
9.1.3 
使用简单的风格         239
9.1.4 
限制信息范围    240
9.1.5 
使用现实中的代码示例    240
9.1.6 
使用轻量且充分的方法    241
9.1.7 
使用模板    241
9.2 
reStructuredText入门   242
9.2.1 
章节结构    243
9.2.2 
列表    245
9.2.3 
行内标记    246
9.2.4 
文字块         246
9.2.5 
链接    247
9.3  构建文档        248
9.4  构建自己的文档集        254
9.4.1 
构建格局    254
9.4.2 
文档构建与持续集成         259
9.5  小结        260
第10章  测试驱动开发       261
10.1 
我不测试      261
10.1.1 
测试开发的原则       261
10.1.2 
什么样的测试  265
10.1.3 
达式Python标准测试工具      268
10.2 
我做测试      273
10.2.1 
unittest陷阱     273
10.2.2 
unittest的替代品     274
10.2.3 
测试覆盖率       280
10.2.4 
仿真与模拟       282
10.2.5 
测试环境与依赖兼容性  289
10.2.6 
文档驱动开发  292
10.3 
小结      294
第11章  优化——一般原则与分析技术   295
11.1 
3个优化规则       295
11.1.1 
首先要能工作  295
11.1.2 
从用户的角度考虑  296
11.1.3 
保持代码的可读性和可维护性       297
11.2 
优化策略      297
11.2.1 
找到另外的罪魁祸首       297
11.2.2 
扩展硬件  298
11.2.3 
编写速度测试  298
11.3 
查找瓶颈      299
11.3.1 
分析CPU使用情况 299
11.3.2 
分析内存使用  307
11.3.3 
分析网络使用情况  315
11.4 
小结      316
第12章  优化——一些强大的技术   317
12.1 
降低复杂度 318
12.1.1 
循环复杂度       319
12.1.2 
大O记法  320
12.2 
简化      322
12.3 
使用集合模块      323
12.3.1 
deque         324
12.3.2 
defaultdict 325
12.3.3 
namedtuple       326
12.4 
架构体系的权衡 327
12.4.1 
使用启发式和近似算法  327
12.4.2 
使用任务队列和延迟
处理         328
12.4.3 
使用概率型数据结构       331
12.5 
缓存      331
12.5.1 
确定性缓存       332
12.5.2 
非确定性缓存  335
12.5.3 
缓存服务  336
12.6 
小结      338
第13章  并发       339
13.1 
为什么需要并发 339
13.2 
多线程 340
13.2.1 
什么是多线程  340
13.2.2 
Python如何处理多线程  341
13.2.3 
何时应该使用多线程       342
13.3 
多进程 356
13.4 
异步编程      364
13.4.1 
协同多任务与异步I/O    364
13.4.2 
Python中的async和await关键字         365
13.4.3 
老Python版本中的asyncio     369
13.4.4 
异步编程实例  369
13.4.5 
使用futures将异步代码同步化     372
13.5 
小结      374
第14章  有用的设计模式   376
14.1 
创建型模式 376
14.2 
结构型模式 379
14.2.1 
适配器       380
14.2.2 
代理  394
14.2.3 
外观  395
14.3 
行为模式      395
14.3.1 
观察者       396
14.3.2 
访问者       398
14.3.3 
模板  400
14.4 
小结      403 
 

