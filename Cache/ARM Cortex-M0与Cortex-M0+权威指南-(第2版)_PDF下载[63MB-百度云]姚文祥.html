ARM Cortex-M0与Cortex-M0+权威指南-(第2版) PDF下载 姚文祥 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730247331
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730247331
<p>书名:ARM Cortex-M0与Cortex-M0+权威指南-(第2版)</p><p>作者:姚文祥</p><p>页数:608</p><p>定价:¥128.0</p><p>出版社:清华大学出版社</p><p>出版日期:2018-01-01</p><p>ISBN:9787302473312</p><p><h2>本书特色</h2></p>[<p>
本书是ARM公司微控制器系统级设计专家Joseph Yiu的作品。本书全面系统论述Cortex-M0与Cortex-M0 的内核、体系结构、指令集、编译器、程序设计及软件移植。全书共23章，近700页。深度剖析系统模型、指令集以及中断处理，以利于理解ARM Cortex-M0与Cortex-M0 的工作方式；综合运用汇编语言和C语言实现的丰富的ARM Cortex-M0与Cortex-M0 编程案例，有助于快速动手实践；系统论述软件的开发流程，并以常用软件开发工具为例，介绍程序设计的实例及如何定位程序代码问题和软件移植等方面的知识；全面揭秘从其他架构处理器进行软件移植的方法，包括ARM7TDMI、ARM Cortex-M3以及8051微控制器移植的实例；深入解析Cortex-M0和Cortex-M0 处理器架构特性的差异（如非特权执行等级、向量表重定位）；细致分析了Cortex-M0 处理器的优势，比如新的单周期I/O接口、更优的能耗效率、更高的性能以及微跟踪缓冲（MTB）特性；详尽介绍了软件开发工具方面的新内容，如Keil MDK版本5、IAR Embedded Workbench for ARM、ARM gcc、CooCox及mbed的实例。另外，为便于读者学习，全书提供了完整的案例源代码！
                                        </p>]<p><h2>内容简介</h2></p>[<p>本书是系统论述ARM Cortex-M0与Cortex-M0 处理器及其编程的图书，作者Joseph Yiu是英国ARM公司的主管工程师，著有久负盛名的畅销图书《ARM Cortex-M3与Cortex-M4权威指南（第3版）》（清华大学出版社）。本书适合的读者对象包括：嵌入式产品设计工程师、嵌入式软件开发人员、电子爱好者以及学习嵌入式系统课程（ARM Cortex-M0与Cortex-M0 ）的高年级本科生及研究生等。作者提供了详实的配书工程源文件（见封面下载地址）。l  深度剖析系统模型、指令集以及中断处理，以利于理解ARM Cortex-M0与Cortex-M0 的工作方式；l  综合运用汇编语言和C语言实现的丰富的ARM Cortex-M0与Cortex-M0 编程案例，有助于快速动手实践；l  系统论述软件的开发流程，并以常用软件开发工具为例，介绍程序设计的实例及如何定位程序代码问题和软件移植等方面的知识；l  全面揭秘从其他架构处理器进行软件移植的方法，包括ARM7TDMI、ARM Cortex-M3以及8051微控制器移植的实例；l  深入解析Cortex-M0和Cortex-M0 处理器架构特性的差异（如非特权执行等级、向量表重定位）；l  细致分析了Cortex-M0 处理器的优势，比如新的单周期I/O接口、更优的能耗效率、更高的性能以及微跟踪缓冲（MTB）特性；l  详尽介绍了软件开发工具方面的新内容，如Keil MDK版本5、IAR Embedded Workbench for ARM、ARM gcc、CooCox及mbed使用示例；l  提供了基于CMSIS-RTOS API的Keil RTX实时操作系统的新实例；l  提供了Cortex-M0和Cortex-M0 微控制器使用实例，包括Freescale Freedom板（FRDM-KL25Z）、STM32F0 Discovery、STM32L0 Discovery和NXP LPC1114（DIP封装）面包板等。 </p>]<p><h2>作者简介</h2></p>[<p>Joseph Yiu 英国ARM公司资深专家，12年半导体行业从业经历（在ARM公司工作15年以上）。曾参与多个处理器设计项目，包括ARM Cortex-M3和Cortex-M0，并参与了多种ARM IP（知识产权）产品的开发。Joseph Yiu为微控制器系统级设计专家，并涉猎了诸多相关领域，包括ARM Cortex-M系列微控制器软件开发、微控制器市场以及片上系统设计技术。其他代表性著作有《The Definitive Guide to the ARM Cortex-M3, 2nd Edition》、《The Definitive Guide to ARM Cortex-M3 and Cortex-M4 Processors, 3rd Edition》（中文翻译版均由清华大学出版社出版发行）。 </p>]<p><h2>目录</h2></p>
     
 
 
目录
译者序1
 
推荐序3
 
前言5
 
致谢7
 
术语和缩写9
 
本书约定13
 
 
第1章概论
 
1.1欢迎来到嵌入式处理器的世界
 
1.1.1处理器有什么作用
 
1.1.2处理器、CPU、内核、微控制器及其命名
 
1.1.3嵌入式系统的编程
 
1.1.4学习微控制器需要了解什么
 
1.2理解处理器的类型
 
1.2.1处理器为什么有很多种类
 
1.2.2ARM处理器家族概述
 
1.2.3模糊边界
 
1.2.4ARM Cortex�睲处理器系列
 
1.2.5ARM Cortex�睲0和Cortex�睲0 处理器简介
 
1.2.6从Cortex�睲0处理器到Cortex�睲0 处理器
 
1.2.7Cortex�睲0和Cortex�睲0 处理器的应用
 
1.3微控制器内部有什么
 
1.3.1微控制器内常见部件
 
1.3.2微控制器应用的处理器的特点
 
1.3.3硅片技术
 
1.4ARM介绍
 
1.4.1ARM生产芯片吗
 
1.4.2ARM的产品是什么
 
1.4.3芯片厂商为什么不设计自己的处理器
 
1.4.4ARM生态系统有什么特殊之处
 
1.5ARM处理器和ARM微控制器方面的资源
 
1.5.1ARM主页
 
1.5.2微控制器厂商提供的资源
 
1.5.3工具厂商提供的资源
 
1.5.4其他资源
 
第2章技术综述
 
2.1Cortex�睲0和Cortex�睲0 处理器
 
2.2模块框图
 
2.3典型系统
 
2.4什么是ARMv6�睲架构
 
2.5Cortex�睲处理器间的软件可移植性
 
2.6ARM Cortex�睲0和Cortex�睲0 处理器的优势
 
2.6.1低功耗和能耗效率
 
2.6.2高代码密度
 
2.6.3低中断等待和确定行为
 
2.6.4易于使用
 
2.6.5系统级特性和OS支持特性
 
2.6.6调试特性
 
2.6.7可配置性、灵活性和可扩展性
 
2.6.8软件可移植性和可重用性
 
2.6.9产品选择的多样性
 
2.6.10生态系统支持
 
2.7Cortex�睲0和Cortex�睲0 处理器的应用
 
2.7.1微控制器
 
2.7.2传感器
 
2.7.3传感器集线器
 
2.7.4电源管理IC
 
2.7.5ASSP和ASIC
 
2.7.6片上系统中的子系统
 
2.8为什么要在微控制器应用中使用32位处理器
 
2.8.1性能
 
2.8.2代码密度
 
2.8.3ARM架构的其他优势
 
2.8.4软件可重用性
 
第3章嵌入式软件开发介绍
 
3.1欢迎进入嵌入式系统编程
 
3.2基本概念
 
3.2.1复位
 
3.2.2时钟
 
3.2.3电压
 
3.2.4输入和输出
 
3.2.5嵌入式软件程序流程介绍
 
3.2.6编程语言选择
 
3.3ARM Cortex�睲编程介绍
 
3.3.1C编程数据类型
 
3.3.2用C访问外设
 
3.3.3程序映像内有什么
 
3.3.4SRAM中的数据
 
3.3.5微控制器启动时会发生什么
 
3.4软件开发流程
 
3.5Cortex微控制器软件接口标准
 
3.5.1CMSIS介绍
 
3.5.2CMSIS�睠ORE所做的标准化
 
3.5.3CMSIS�睠ORE的组织
 
3.5.4使用CMSIS�睠ORE
 
3.5.5CMSIS的优势
 
3.6软件开发的其他信息
 
第4章架构
 
4.1ARMv6�睲架构综述
 
4.1.1架构的含义
 
4.1.2ARMv6�睲架构背景
 
4.2编程模型
 
4.2.1操作模式和状态
 
4.2.2寄存器和特殊寄存器
 
4.2.3APSR的行为
 
4.3存储器系统
 
4.3.1概述
 
4.3.2单周期I/O接口
 
4.3.3存储器保护单元
 
4.4栈存储操作
 
4.5异常和中断
 
4.6嵌套向量中断控制器
 
4.6.1灵活的中断管理
 
4.6.2嵌套中断支持
 
4.6.3向量异常入口
 
4.6.4中断屏蔽
 
4.7系统控制块
 
4.8调试系统
 
4.9程序映像和启动流程
 
第5章指令集
 
5.1指令集是什么
 
5.2ARM和Thumb指令集背景
 
5.3汇编基础
 
5.3.1汇编语法一览
 
5.3.2后缀的使用
 
5.3.3统一汇编语言(UAL)
 
5.4指令列表
 
5.4.1处理器内传送数据
 
5.4.2存储器访问
 
5.4.3栈存储访问
 
5.4.4算术运算
 
5.4.5逻辑运算
 
5.4.6移位和循环移位运算
 
5.4.7展开和顺序反转运算
 
5.4.8程序流控制
 
5.4.9存储器屏障指令
 
5.4.10异常相关指令
 
5.4.11休眠模式特性相关指令
 
5.4.12其他指令
 
5.5伪指令
 
第6章指令使用示例
 
6.1概述
 
6.2程序控制
 
6.2.1if�瞭hen�瞖lse
 
6.2.2循环
 
6.2.3跳转指令
 
6.2.4跳转指令的典型用法
 
6.2.5函数调用和函数返回
 
6.2.6跳转表
 
6.3数据访问
 
6.3.1简单数据访问
 
6.3.2使用存储器访问指令的例子
 
6.4数据类型转换
 
6.4.1数据大小的转换
 
6.4.2大小端转换
 
6.5数据处理
 
6.5.164位/128位加法
 
6.5.264位/128位减法
 
6.5.3整数除法
 
6.5.4无符号整数开方根
 
6.5.5位和位域计算
 
第7章存储器系统
 
7.1微控制器中的存储器系统
 
7.2Cortex�睲0和Cortex�睲0 处理器中的总线系统
 
7.3存储器映射
 
7.3.1概述
 
7.3.2系统级设计
 
7.4程序存储器、Bootloader和存储器重映射
 
7.4.1程序存储器和Bootloader
 
7.4.2存储器映射
 
7.5数据存储器
 
7.6小端和大端支持
 
7.7数据类型
 
7.8存储器属性和存储器访问权限
 
7.9硬件行为对编程的影响
 
7.9.1数据对齐
 
7.9.2访问非法地址
 
7.9.3多加载和存储指令的使用
 
7.9.4等待状态
 
第8章异常和中断
 
8.1异常和中断的含义
 
8.2Cortex�睲0和Cortex�睲0 处理器内的异常类型
 
8.2.1概述
 
8.2.2不可屏蔽中断
 
8.2.3HardFault
 
8.2.4SVC
 
8.2.5可挂起的系统调用
 
8.2.6系统节拍
 
8.2.7中断
 
8.3NVIC简介
 
8.4异常优先级定义
 
8.5向量表
 
8.6异常流程概述
 
8.6.1接受异常
 
8.6.2压栈和出栈
 
8.6.3异常返回指令
 
8.6.4末尾连锁
 
8.6.5延迟到达
 
8.7EXC_RETURN
 
8.8用于中断控制的NVIC控制寄存器
 
8.8.1NVIC控制寄存器概述
 
8.8.2中断使能和清除使能
 
8.8.3中断挂起和清除挂起
 
8.8.4中断优先级
 
8.9异常屏蔽寄存器(PRIMASK)
 
8.10中断输入和挂起行为
 
8.10.1简单中断处理
 
8.10.2简单的脉冲中断处理
 
8.10.3中断挂起状态在得到服务前取消
 
8.10.4外设在确认中断请求时清除挂起状态
 
8.10.5ISR完成后中断请求保持为高
 
8.10.6进入ISR前产生了多个中断请求脉冲
 
8.10.7在ISR执行期间产生了中断请求脉冲
 
8.10.8已禁止中断的中断请求确认
 
8.11异常入口流程
 
8.11.1压栈
 
8.11.2取出向量并更新PC
 
8.11.3更新寄存器
 
8.12异常退出流程
 
8.12.1寄存器出栈
 
8.12.2从返回地址取指并执行
 
8.13中断等待
 
第9章系统控制和低功耗特性
 
9.1系统控制寄存器简介
 
9.2SCB中的寄存器
 
9.2.1SCB中的寄存器列表
 
9.2.2CPU ID寄存器
 
9.2.3用于系统异常管理的控制寄存器
 
9.2.4向量表偏移寄存器
 
9.2.5应用中断和复位控制寄存器
 
9.2.6系统控制寄存器
 
9.2.7配置和控制寄存器
 
9.2.8系统处理控制和状态寄存器
 
9.3使用自复位特性
 
9.4使用向量表重定位特性
 
9.5低功耗特性
 
9.5.1概述
 
9.5.2休眠模式
 
9.5.3等待事件和等待中断
 
9.5.4唤醒条件
 
9.5.5退出时休眠特性
 
9.5.6唤醒中断控制器
 
第10章操作系统支持特性
 
10.1支持OS的特性概述
 
10.2嵌入式系统的操作系统介绍
 
10.3SysTick定时器
 
10.3.1SysTick寄存器
 
10.3.2设置SysTick
 
10.3.3SysTick用于时间测量
 
10.3.4将SysTick用作单发定时器
 
10.4进程栈和PSP
 
10.5SVCall异常
 
10.6PendSV
 
10.7高级话题： 在编程中使用SVC和PendSV
 
10.7.1使用SVC异常
 
10.7.2使用PendSV异常
 
10.8高级话题： 实际的上下文切换
 
第11章错误处理
 
11.1错误异常概述
 
11.2错误是如何产生的
 
11.3分析错误
 
11.4意外切换至ARM状态
 
11.5实际应用中的错误处理
 
11.6软件开发期间的错误处理
 
11.7锁定
 
11.7.1锁定的原因
 
11.7.2锁定期间发生了什么
 
11.8避免锁定
 
11.9和ARMv7�睲架构中错误处理的对比
 
第12章存储器保护单元
 
12.1MPU是什么
 
12.2MPU适用的情形
 
12.3技术介绍
 
12.4MPU寄存器
 
12.4.1MPU类型寄存器
 
12.4.2MPU控制寄存器
 
12.4.3MPU区域编号寄存器
 
12.4.4MPU区域基地址寄存器
 
12.4.5MPU区域基本属性和大小寄存器
 
12.5设置MPU
 
12.6存储器屏障和MPU配置
 
12.7使用子区域禁止
 
12.7.1允许高效的存储器划分
 
12.7.2减少所需的区域总数
 
12.8使用MPU时的注意事项
 
12.8.1程序代码
 
12.8.2数据存储器
 
12.9和Cortex�睲3/M4/M7处理器的MPU间的差异
 
第13章调试特性
 
13.1软件开发和调试特性
 
13.2调试接口
 
13.2.1JTAG和串行线调试通信协议
 
13.2.2Cortex�睲处理器和CoreSight调试架构
 
13.2.3调试接口的设计考虑
 
13.3调试特性一览
 
13.4调试系统
 
13.5暂停模式和调试事件
 
13.6利用MTB实现指令跟踪
 
第14章Keil微控制器开发套件入门
 
14.1Keil微控制器开发套件介绍
 
14.1.1概述
 
14.1.2工具
 
14.1.3Keil MDK的优势
 
14.1.4安装
 
14.2典型的程序编译流程
 
14.3硬件介绍
 
14.3.1Freescale Freedom开发板(FRDM�睰L25Z)
 
14.3.2STMicroelectronics STM32L0 Discovery
 
14.3.3STMicroelectronics STM32F0 Discovery
 
14.3.4NXP LPC1114FN28
 
14.4μVision IDE入门
 
14.4.1如何开始
 
14.4.2启动Keil MDK
 
14.4.3Freescale FRDM�睰L25Z工程设置步骤
 
14.4.4STMicroelectronics STM32L0 Discovery工程设置步骤
 
14.4.5STMicroelectronice STM32F0 Discovery工程设置步骤
 
14.4.6NXP LPC1114FN28工程设置步骤
 
14.5使用IDE和调试器
 
14.6底层内容
 
14.6.1CMSIS文件
 
14.6.2时钟设置
 
14.6.3栈和堆的设置
 
14.6.4编译
 
14.7工程环境的优化
 
14.7.1目标选项
 
14.7.2优化选项
 
14.7.3运行时环境选项
 
14.7.4工程管理
 
14.8使用模拟器
 
14.9在SRAM中执行程序
 
14.10使用MTB指令跟踪
 
第15章IAR embedded workbench for ARM入门
 
15.1IAR embedded workbench for ARM概述
 
15.2典型的程序编译流程
 
15.3创建简单的blinky工程
 
15.4工程选项
 
15.5在IAR EWARM中使用MTB指令跟踪
 
15.6提示和要点
 
第16章GCC入门
 
16.1GCC工具链
 
16.2关于本章中的例子
 
16.3典型开发流程
 
16.4创建简单的Blinky工程
 
16.5命令行选项概述
 
16.6Flash编程
 
16.7在Keil MDK�睞RM中使用ARM嵌入式处理器GNU工具
 
16.8在CooCox IDE中使用ARM嵌入式处理器GNU工具
 
16.8.1概述和设置
 
16.8.2创建新的工程
 
16.8.3使用IDE和调试器
 
第17章mbed入门
 
17.1什么是mbed
 
17.2mbed系统是怎么工作的
 
17.3mbed的优势
 
17.4设置FRDM�睰L25Z板和mbed账号
 
17.4.1检查mbed Web网页
 
17.4.2注册mbed账号
 
17.4.3个人计算机的设置
 
17.5创建blinky程序
 
17.5.1只开关红色LED的简单版本
 
17.5.2利用脉宽调试控制LED
 
17.6支持的常用外设对象
 
17.7使用printf
 
17.8应用实例： 火车模型控制器
 
17.9中断
 
17.10要点和提示
 
第18章编程实例
 
18.1利用通用异步收发器来产生输出
 
18.1.1通用异步收发器通信概述
 
18.1.2微控制器上的UART配置概述
 
18.1.3配置FRDM�睰L25Z中的UART
 
18.1.4配置STM32L0 Discovery板中的UART
 
18.1.5配置STM32F0 Discovery板上的UART
 
18.1.6配置LPC1114FN28上的UART
 
18.2实现printf
 
18.2.1概述
 
18.2.2Keil MDK的重定向
 
18.2.3IAR EWARM的重定向
 
18.2.4GNU编译器套件的重定向
 
18.2.5IAR EWARM的半主机
 
18.2.6CoIDE的半主机
 
18.3开发输入和输出函数
 
18.3.1为何要重新开发
 
18.3.2其他接口
 
18.3.3有关scanf的其他信息
 
18.4中断编程实例
 
18.4.1中断处理概述
 
18.4.2中断控制函数概述
 
18.5应用实例： 火车模型用的另一个控制器
 
18.6CMSIS�睠ORE的不同版本
 
第19章超低功耗设计
 
19.1超低功耗使用示例
 
19.1.1概述
 
19.1.2进入休眠模式
 
19.1.3WFE与WFI
 
19.1.4利用退出时休眠特性
 
19.1.5利用挂起发送事件特性
 
19.1.6利用唤醒中断控制器
 
19.1.7利用事件通信接口
 
19.2低功耗设计要求
 
19.3能量去哪里了
 
19.4开发低功耗应用
 
19.4.1低功耗设计概述
 
19.4.2降低功耗的各种方法
 
19.4.3选择正确的方法
 
19.5调试考虑
 
19.5.1调试和低功耗
 
19.5.2调试和Flash编程的“安全模式”
 
19.5.3低电压引脚和调试接口
 
19.6低电压设备的检测
 
19.6.1ULPBench的背景
 
19.6.2ULPBench�睠P概述
 
19.7Freescale KL25Z低功耗特性使用示例
 
19.7.1目标
 
19.7.2测试设置
 
19.7.3KL25Z的低功耗模式
 
19.7.4时钟设计
 
19.7.5测试设置
 
19.7.6测量结果
 
19.8LPC1114低功耗特性使用示例
 
19.8.1LPC1114FN28概述
 
19.8.2实验1:使用12MHz内部和外部晶振
 
19.8.3实验2:使用降频1MHz和100kHz
 
19.8.4其他改进
 
19.8.5利用LPC1114的深度休眠
 
第20章嵌入式OS编程
 
20.1介绍
 
20.1.1背景
 
20.1.2嵌入式OS和RTOS
 
20.1.3为什么要使用嵌入式OS
 
20.1.4CMSIS�睷TOS的作用
 
20.1.5关于Keil RTX Kernel
 
20.1.6在Keil MDK中构建一个简单RTX实例
 
20.2RTX Kernel概述
 
20.2.1线程
 
20.2.2RTX配置
 
20.2.3深入研究**个例子
 
20.2.4线程间通信概述
 
20.2.5信号事件通信
 
20.2.6互斥体(Mutex)
 
20.2.7信号量
 
20.2.8消息队列
 
20.2.9邮件队列
 
20.2.10内存池管理特性
 
20.2.11通用等待函数和超时数值
 
20.2.12定时器特性
 
20.2.13给非特权线程增加SVC服务
 
20.3在应用中使用RTX
 
20.4调试RTX应用
 
20.5疑难解答
 
20.5.1栈大小需求
 
20.5.2优先级
 
20.5.3利用OS错误报告
 
20.5.4OS特性配置
 
20.5.5其他问题
 
20.6其他要点和提示
 
20.6.1修改RTX_Config_CM.c
 
20.6.2线程优先级
 
20.6.3缩短等待时间
 
20.6.4其他信息
 
第21章混合语言工程
 
21.1汇编在工程开发中的应用
 
21.2汇编编程实践和AAPCS
 
21.3汇编函数概述
 
21.3.1ARM工具链
 
21.3.2GCC工具链
 
21.3.3IAR Embedded Workbench for ARM
 
21.3.4汇编函数结构
 
21.4内联汇编
 
21.4.1ARM工具链
 
21.4.2GNU编译器组件
 
21.5嵌入汇编特性(ARM工具链)
 
21.6混合语言工程
 
21.6.1概述
 
21.6.2在汇编代码中调用C函数
 
21.6.3在C代码中调用汇编函数
 
21.7在Keil MDK�睞RM中创建汇编工程
 
21.7.1一个简单的工程
 
21.7.2Hello World
 
21.7.3其他文本输出函数
 
21.8用于中断控制的通用汇编代码
 
21.8.1使能和禁止中断
 
21.8.2设置和清除中断挂起状态
 
21.8.3设置中断优先级
 
21.9汇编语言的其他编程技巧
 
21.9.1为变量分配数据空间
 
21.9.2复杂跳转处理
 
21.10使用特殊指令
 
21.10.1CMSIS�睠ORE
 
21.10.2习语识别
 
第22章软件移植
 
22.1概述
 
22.2从8位/16位微控制器向ARM
Cortex�睲移植软件
 
22.2.1通用改动
 
22.2.2存储器需求
 
22.2.38位或16位微控制器不再适用的优化
 
22.2.4实例： 从8051移植到ARM Cortex�睲0/Cortex�睲0 
 
22.3ARM7TDMI和Cortex�睲0/M0 处理器间的差异
 
22.3.1经典ARM处理器概述
 
22.3.2操作模式
 
22.3.3寄存器
 
22.3.4指令集
 
22.3.5中断
 
22.4从ARM7TDMI向Cortex�睲0/Cortex�睲0 处理器移植软件
 
22.4.1启动代码和向量表
 
22.4.2中断
 
22.4.3C程序代码
 
22.4.4汇编代码
 
22.4.5原子访问
 
22.4.6优化
 
22.5各种Cortex�睲处理器间的差异
 
22.5.1概述
 
22.5.2系统模型
 
22.5.3NVIC和异常
 
22.5.4指令集
 
22.5.5系统级特性
 
22.5.6调试和跟踪特性
 
22.6在Cortex�睲处理器间移植时的通用改动
 
22.7Cortex�睲0/M0 和Cortex�睲1间的软件移植
 
22.8Cortex�睲0/M0 和Cortex�睲3间的软件移植
 
22.9Cortex�睲0/M0 和Cortex�睲4/M7间的软件移植
 
第23章高级话题
 
23.1C语言实现的位数据处理
 
23.2C实现的启动代码
 
23.3栈溢出检测
 
23.3.1什么是栈溢出
 
23.3.2工具链的栈分析
 
23.3.3栈的测试分析
 
23.3.4利用存储器保护单元对栈进行限制
 
23.3.5OS上下文切换期间的栈检测
 
23.4中断服务程序重入
 
23.5信号量设计
 
23.6存储器顺序和存储器屏障
 
附录A指令集快速参考
 
附录B异常类型快速参考
 
B.1异常类型
 
B.2异常压栈后栈的内容
 
附录CCMSIS�睠ORE快速参考
 
C.1数据类型
 
C.2异常枚举
 
C.3嵌套向量中断控制器访问函数
 
C.4系统和SysTick操作函数
 
C.5内核寄存器操作函数
 
C.6特殊指令操作函数
 
附录DNVIC、SCB和SysTick寄存器快速参考
 
D.1NVIC寄存器一览
 
D.2中断设置使能寄存器(NVIC�睮SER)
 
D.3中断清除使能寄存器(NVIC�睮CER)
 
D.4中断设置挂起寄存器(NVIC�睮SPR)
 
D.5中断清除挂起寄存器(NVIC�睮CPR)
 
D.6中断优先级寄存器(NVIC�睮RQ［0］到NVIC�睮RQ［7］)
 
D.7SCB寄存器一览
 
D.8CPU ID寄存器(SCB�睠PUID)
 
D.9中断控制状态寄存器(SCB�睮CSR)
 
D.10向量表偏移寄存器(SCB�睼TOR，0xE000ED08)
 
D.11应用中断和控制状态寄存器(SCB�睞IRCR)
 
D.12系统控制寄存器(SCB�睸CR)
 
D.13配置控制寄存器(SCB�睠CR)
 
D.14系统处理优先级寄存器2(SCB�睸HR［0］)
 
D.15系统处理优先级寄存器3(SCB�睸HR［1］)
 
D.16系统处理控制和状态寄存器
 
D.17SysTick寄存器一览
 
D.18SysTick控制和状态寄存器(SysTick�睠TRL)
 
D.19SysTick重装载值寄存器(SysTick�睱OAD)
 
D.20SysTick当前值寄存器(SysTick�睼AL)
 
D.21SysTick校准值寄存器(SysTick�睠ALIB)
 
附录E调试寄存器快速参考
 
E.1内核调试寄存器
 
E.2断点单元
 
E.3数据监视点单元
 
E.4ROM表寄存器
 
E.5微跟踪缓冲
 
E.6POSITION寄存器
 
E.7MASTER寄存器
 
E.8FLOW寄存器
 
E.9BASE寄存器
 
E.10包格式
 
E.11实例
 
附录F调试接头分配
 
F.110针Cortex调试连接头
 
F.220针Cortex调试 ETM接头
 
F.3老式的20针IDC接头排列
 
附录G疑难解答
 
G.1程序不运行/启动
 
G.1.1向量表丢失或位置错误
 
G.1.2使用了错误的C启动代码
 
G.1.3复位向量中的值错误
 
G.1.4程序映像没有被正确地编程到Flash中
 
G.1.5错误的工具链配置
 
G.1.6错误的栈指针初始值
 
G.1.7错误的大小端设置
 
G.2程序启动，却进入了硬件错误
 
G.2.1非法存储器访问
 
G.2.2非对齐数据访问
 
G.2.3存储器访问权限(只限于Cortex�睲0 处理器)
 
G.2.4从总线返回错误
 
G.2.5异常处理中的栈被破坏
 
G.2.6程序在某些C函数中崩溃
 
G.2.7意外地试图切换至ARM状态
 
G.2.8在错误的优先级上执行SVC
 
G.3休眠问题
 
G.3.1执行WFE不进入休眠
 
G.3.2退出时休眠过早地引起休眠
 
G.3.3中断已经在挂起态时SEVONPEND不工作
 
G.3.4由于休眠模式可能禁止了某些时钟，处理器无法唤醒
 
G.3.5竞态
 
G.4中断问题
 
G.4.1执行了多余的中断处理
 
G.4.2执行了多余的SysTick处理
 
G.4.3在中断处理中禁止中断
 
G.4.4错误的中断返回指令
 
G.4.5异常优先级设置的数值
 
G.5其他问题
 
G.5.1错误的SVC参数传递方法
 
G.5.2调试连接受到I/O设置或低功耗模式的影响
 
G.5.3调试协议选择/配置
 
G.5.4使用事件输出作为脉冲I/O
 
G.5.5向量表和代码位置的设备实际需求
 
G.6其他可能的编程陷阱
 
G.6.1中断优先级
 
G.6.2同时使用主栈和进程栈时的栈溢出
 
G.6.3数据对齐
 
G.6.4丢失volatile关键字
 
G.6.5函数指针
 
G.6.6读�残薷莫残�
 
G.6.7中断禁止
 
G.6.8SystemInit函数
 
G.6.9断点和内联
 
附录HARM Cortex�睲0微控制器面包板工程
 
H.1背景
 
H.2硬件设计
 
附录I参考文档
