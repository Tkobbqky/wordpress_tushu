C++高级编程(第4版) PDF下载 [美]马克·葛瑞格尔（MarcGreg 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730252631
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730252631
<p>书名:C++高级编程(第4版)</p><p>作者:[美]马克·葛瑞格尔（Marc Greg</p><p>页数:0</p><p>定价:¥138.0</p><p>出版社:清华大学出版社</p><p>出版日期:2018-08-01</p><p>ISBN:9787302526315</p><p><h2>本书特色</h2></p>[<p>
·展现C  思考方式，以便充分利用该语言中影响深远的功能来开发高效的解决方案。
·阐释鲜为人知的元素，披露避开常见陷阱的技巧，分享提示、技巧和方案，以帮助提高工作效率和软件性能。
·列出富有挑战、贴近实用、具有多种用途的代码段，可根据需要将这些代码段移植到任何项目中。
·浓墨重彩地描述C  17的新功能，如结构化绑定、嵌套的名称空间和constexpr if等。
·深入讨论C  17新的标准库功能，比如string_view、optional类、并行算法和文件系统API等。
                                        </p>]<p><h2>内容简介</h2></p>[<p>·展现C++思考方式，以便充分利用该语言中影响深远的功能来开发高效的解决方案。
·阐释鲜为人知的元素，披露避开常见陷阱的技巧，分享提示、技巧和方案，以帮助提高工作效率和软件性能。
·列出富有挑战、贴近实用、具有多种用途的代码段，可根据需要将这些代码段移植到任何项目中。
·浓墨重彩地描述C++17的新功能，如结构化绑定、嵌套的名称空间和constexpr if等。
·深入讨论C++17新的标准库功能，比如string_view、optional类、并行算法和文件系统API等。</p>]<p><h2>作者简介</h2></p>[<p>Marc Gregoire 是一名软件工程师，毕业于比利时鲁文大学，拥有计算机科学工程硕士学位。之后，他在<br/>鲁文大学获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium 工作。他曾在<br/>Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris 上运行关键2G和3G软件的咨询服务。<br/>这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc 目前担任Nikon Metrology<br/>(www.nikonmetrology.com)的软件架构师；Nikon Metrology 是Nikon 的分公司，是领先的精密光学仪器和3D 扫<br/>描软件供应商。<br/>Marc 的主要技术专长是C/C  ，特别是Microsoft VC  和MFC 框架。他还擅长在Windows 和Linux 平台<br/>上开发24×7 小时运行的C  程序，例如KNX/EIB 家庭自动化监控软件。除了C/C  之外，Marc 还喜欢C#，并<br/>且会用PHP 创建网页。Marc Gregoire 是一名软件工程师，毕业于比利时鲁文大学，拥有计算机科学工程硕士学位。之后，他在<br/>鲁文大学获得人工智能专业的优等硕士学位。完成学业后，他开始为软件咨询公司Ordina Belgium 工作。他曾在<br/>Siemens 和Nokia Siemens Networks为大型电信运营商提供有关在Solaris 上运行关键2G和3G软件的咨询服务。<br/>这份工作要求与来自南美、美国、欧洲、中东、非洲和亚洲的国际团队合作。Marc 目前担任Nikon Metrology<br/>(www.nikonmetrology.com)的软件架构师；Nikon Metrology 是Nikon 的分公司，是领先的精密光学仪器和3D 扫<br/>描软件供应商。<br/>Marc 的主要技术专长是C/C  ，特别是Microsoft VC  和MFC 框架。他还擅长在Windows 和Linux 平台<br/>上开发24×7 小时运行的C  程序，例如KNX/EIB 家庭自动化监控软件。除了C/C  之外，Marc 还喜欢C#，并<br/>且会用PHP 创建网页。<br/>2007 年4 月，他凭借Visual C  方面的专业技能，获得了微软年度MVP 称号。<br/>Marc 还是比利时C  用户组(www.becpp.org)的创始人，是C   Standard Library Quick Reference(Apress)一<br/>书的作者，以及多家出版社出版的多本书籍的技术编辑，是CodeGuru 论坛上的活跃分子(id 为Marc G)。Marc<br/>还在www.nuonsoft.com/blog/上维护了一个博客，他热爱旅游和烹饪。</p>]<p><h2>目录</h2></p>
    目 录第 I 部分 专业的C  简介第1 章 C  和标准库速成   21.1 C  基础知识   21.1.1 小程序“hello world”    31.1.2 名称空间   .51.1.3 字面量   61.1.4 变量   71.1.5 运算符   81.1.6 类型   101.1.7 条件语句   121.1.8 逻辑比较运算符   141.1.9 函数   151.1.10 C风格的数组   161.1.11 std::array   171.1.12 std::vector    171.1.13 结构化绑定   181.1.14 循环   181.1.15 初始化列表   191.1.16 这些都是基础   191.2 深入研究C     201.2.1 C  中的字符串   201.2.2 指针和动态内存   201.2.3 const的多种用法   241.2.4 引用   241.2.5 异常   251.2.6 类型推断   261.3 作为面向对象语言的C      271.3.1 定义类   271.3.2 使用类   291.4 统一初始化   291.5 标准库   311.6 **个有用的C  程序   311.6.1 雇员记录系统   321.6.2 Employee类   321.6.3 Database类   341.6.4 用户界面    361.6.5 评估程序    381.7 本章小结    38第2 章 使用string 和string_view    392.1 动态字符串    392.1.1 C风格的字符串    392.1.2 字符串字面量    412.1.3 C   std::string类    422.1.4 std::string_view类    462.1.5 非标准字符串    472.2 本章小结    47第3 章 编码风格   483.1 良好外观的重要性    483.1.1 事先考虑    483.1.2 良好风格的元素    493.2 为代码编写文档    493.2.1 使用注释的原因    493.2.2 注释的风格    523.3 分解       553.3.1 通过重构分解    563.3.2 通过设计来分解    563.3.3 本书中的分解    563.4 命名       563.4.1 选择恰当的名称    573.4.2 命名约定    573.5 使用具有风格的语言特性    593.5.1 使用常量    593.5.2 使用引用代替指针    593.5.3 使用自定义异常    593.6 格式       603.6.1 关于大括号对齐的争论    603.6.2 关于空格和圆括号的争论    613.6.3 空格和制表符    613.7 风格的挑战    613.8 本章小结       62第 II 部分 专业的C  软件设计第4 章 设计专业的C  程序   644.1 程序设计概述    644.2 程序设计的重要性    654.3 C  设计的特点    664.4 C  设计的两个原则    674.4.1 抽象       674.4.2 重用       684.5 重用代码       694.5.1 关于术语的说明    694.5.2 决定是否重用代码    704.5.3 重用代码的策略    714.5.4 绑定第三方应用程序    744.5.5 开放源代码库    754.5.6 C  标准库    764.6 设计一个国际象棋程序    764.6.1 需求       764.6.2 设计步骤    774.7 本章小结       80第5 章 面向对象设计   825.1 过程化的思考方式    825.2 面向对象思想    835.2.1 类       835.2.2 组件       835.2.3 属性       835.2.4 行为       845.2.5 综合考虑    845.3 生活在对象世界里    855.3.1 过度使用对象    855.3.2 过于通用的对象    855.4 对象之间的关系    865.4.1 “有一个”关系    865.4.2 “是一个”关系(继承)    875.4.3 “有一个”与“是一个”的区别   885.4.4 not-a关系    905.4.5 层次结构    915.4.6 多重继承    915.4.7 混入类     925.5 抽象        935.5.1 接口与实现     935.5.2 决定公开的接口    935.5.3 设计成功的抽象    945.6 本章小结       95第6 章 设计可重用代码    966.1 重用哲学       966.2 如何设计可重用代码    976.2.1 使用抽象    976.2.2 构建理想的重用代码     986.2.3 设计有用的接口    1026.2.4 SOLID原则      1066.3 本章小结       106第 III 部分 专业的C  编码方法第7 章 内存管理      1087.1 使用动态内存     1087.1.1 如何描绘内存     1097.1.2 分配和释放    1107.1.3 数组        1117.1.4 使用指针    1167.2 数组-指针的对偶性    1177.2.1 数组就是指针      1177.2.2 并非所有指针都是数组   1197.3 低级内存操作   1197.3.1 指针运算    1197.3.2 自定义内存管理    1207.3.3 垃圾回收    1207.3.4 对象池     1217.4 智能指针       1217.4.1 unique_ptr     1227.4.2 shared_ptr     1247.4.3 weak_ptr     1257.4.4 移动语义    1267.4.5 enable_shared_from_this     1277.4.6 旧的、过时的/取消的auto_ptr   1277.5 常见的内存陷阱     1277.5.1 分配不足的字符串     1277.5.2 访问内存越界     1287.5.3 内存泄漏    1287.5.4 双重删除和无效指针    1317.6 本章小结       131第8 章 熟悉类和对象   1328.1 电子表格示例介绍    1328.2 编写类       1338.2.1 类定义    1338.2.2 定义方法   1358.2.3 使用对象   1378.3 对象的生命周期   1388.3.1 创建对象   1388.3.2 销毁对象   1498.3.3 对象赋值   1498.3.4 编译器生成的复制构造函数和复制赋值运算符    1518.3.5 复制和赋值的区别    1518.4 本章小结       153第9 章 精通类与对象     1549.1 友元      1549.2 对象的动态内存分配   1559.2.1 Spreadsheet类   1559.2.2 使用析构函数释放内存   1579.2.3 处理复制和赋值    1589.2.4 使用移动语义处理移动   1629.2.5 零规则    1679.3 与方法有关的更多内容   1679.3.1 静态方法   1679.3.2 const方法   1689.3.3 方法重载   1699.3.4 内联方法   1709.3.5 默认参数   1719.4 不同的数据成员类型   1729.4.1 静态数据成员   1729.4.2 静态常量数据成员    1739.4.3 引用数据成员   1749.4.4 常量引用数据成员    1759.5 嵌套类       1759.6 类内的枚举类型   1769.7 运算符重载   1779.7.1 示例：为SpreadsheetCell实现加法   1779.7.2 重载算术运算符    1799.7.3 重载比较运算符    1819.7.4 创建具有运算符重载的类型   1819.8 创建稳定的接口   1829.9 本章小结         184第10 章 揭秘继承技术     18510.1 使用继承构建类   18510.1.1 扩展类   18610.1.2 重写方法    18810.2 使用继承重用代码    19410.2.1 WeatherPrediction类    19410.2.2 在派生类中添加功能    19510.2.3 在派生类中替换功能    19610.3 利用父类       19610.3.1 父类构造函数    19610.3.2 父类的析构函数    19710.3.3 使用父类方法    19810.3.4 向上转型和向下转型    20010.4 继承与多态性    20110.4.1 回到电子表格    20110.4.2 设计多态性的电子表格单元格  20110.4.3 SpreadsheetCell基类    20210.4.4 独立的派生类    20310.4.5 利用多态性    20410.4.6 考虑将来    20510.5 多重继承       20610.5.1 从多个类继承    20610.5.2 名称冲突和歧义基类    20710.6 有趣而晦涩的继承问题    20910.6.1 修改重写方法的特征    20910.6.2 继承的构造函数    21110.6.3 重写方法时的特殊情况    21410.6.4 派生类中的复制构造函数和赋值运算符    21910.6.5 运行时类型工具    22010.6.6 非public继承    22110.6.7 虚基类    22110.7 本章小结       222第11 章 理解灵活而奇特的C      22311.1 引用       22311.1.1 引用变量    22411.1.2 引用数据成员    22511.1.3 引用参数    22511.1.4 将引用作为返回值    22611.1.5 右值引用    22611.1.6 使用引用还是指针    22711.2 关键字的疑问    22911.2.1 const关键字    22911.2.2 static关键字    23211.2.3 非局部变量的初始化顺序 23511.2.4 非局部变量的销毁顺序    23511.3 类型和类型转换    23511.3.1 类型别名    23511.3.2 函数指针的类型别名    23611.3.3 方法和数据成员的指针的类型别名   23811.3.4 typedef    23811.3.5 类型转换    23911.4 作用域解析    24211.5 特性       24311.5.1 [[noreturn]]特性    24311.5.2 [[deprecated]]特性    24411.5.3 [[fallthrough]]特性    24411.5.4 [[nodiscard]]特性    24411.5.5 [[maybe_unused]]特性    24411.5.6 供应商专用特性    24511.6 用户定义的字面量    24511.7 头文件       24611.8 C 的实用工具    24711.8.1 变长参数列表    24711.8.2 预处理器宏     24911.9 本章小结       250
