C++17入门经典(第5版) PDF下载 [美]艾佛?霍尔顿IvorHorton 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730252769
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730252769
<p>书名:C++17入门经典(第5版)</p><p>作者:[美]艾佛?霍尔顿Ivor Horton</p><p>页数:0</p><p>定价:¥99.0</p><p>出版社:清华大学出版社</p><p>出版日期:2019-06-01</p><p>ISBN:9787302527695</p><p><h2>本书特色</h2></p>[<p>
《C   17入门经典(第5版)》介绍如何使用*的C  17编写程序。从基础知识讲起，通过详细分析示例，帮助读者成为能够自己编写程序的C  程序员。参考《C   17入门经典(第5版)》的内容，并安装*的C  编译器，读者很快就能编写真正的C  程序。《C   17入门经典(第5版)》不需要读者有任何编程经验，因此在讲解所有语言概念时，均给出了可以工作的程序示例，并且全部章节都包含练习题，以帮助读者检测并练习自己学到的知识。《C   17入门经典(第5版)》为正文中的所有代码示例和练习题提供可下载的代码。
《C   17入门经典(第5版)》内容已针对C  语言的*版本C  17做了全面更新，并且介绍了现代C  的约定和*实践。《C   17入门经典(第5版)》还介绍了C  标准库的元素，它们为C  17语言提供了必要的支持。
                                        </p>]<p><h2>内容简介</h2></p>[<p>《C++ 17入门经典(第5版)》介绍如何使用很新的C++17编写程序。从基础知识讲起，通过详细分析示例，帮助读者成为能够自己编写程序的C++程序员。参考《C++ 17入门经典(第5版)》的内容，并安装很新的C++编译器，读者很快就能编写真正的C++程序。《C++ 17入门经典(第5版)》不需要读者有任何编程经验，因此在讲解所有语言概念时，均给出了可以工作的程序示例，并且全部章节都包含练习题，以帮助读者检测并练习自己学到的知识。《C++ 17入门经典(第5版)》为正文中的所有代码示例和练习题提供可下载的代码。
《C++ 17入门经典(第5版)》内容已针对C++语言的很新版本C++17做了全面更新，并且介绍了现代C++的约定和很好实践。《C++ 17入门经典(第5版)》还介绍了C++标准库的元素，它们为C++17语言提供了必要的支持。</p>]<p><h2>作者简介</h2></p>[<p>Ivor Horton从数学系毕业，却被信息技术领域工作量少、回报高的前景所吸引。虽然现实证明，工作量大，回报相对一般，但是他与计算机一直相伴到今天。在不同的时期，他参与过编程、系统设计、咨询以及相当复杂的项目的管理和实施工作。<br/>Ivor有多年工程设计和制造控制系统的设计和实施经验。他使用多种编程语言开发过在不同场景中很实用的应用程序，并教会一些科学家和工程师如何使用编程语言开发一些实用的程序。他目前出版的图书涉及C、C  和Java等编程语言。当他没有在撰写编程图书或者为他人提供咨询服务时，他会去钓鱼或旅行，享受生活。<br/><br/>Peter Van Weert是一名软件工程师，主要兴趣和专长是应用软件开发、编程语言、算法和数据结构。他在鲁汶大学以最优毕业生荣誉获得计算机科学硕士学位，并得到了考试委员会的祝贺。2010年，他在鲁汶大学的声明式编程语言和人工智能研究组完成了博士论文，主题是基于规则的编程语言的设计和高效编译。在攻读博士期间，他担任面向对象编程(Java)、软件分析与设计以及声明式编程的助教。Ivor Horton从数学系毕业，却被信息技术领域工作量少、回报高的前景所吸引。虽然现实证明，工作量大，回报相对一般，但是他与计算机一直相伴到今天。在不同的时期，他参与过编程、系统设计、咨询以及相当复杂的项目的管理和实施工作。<br/>Ivor有多年工程设计和制造控制系统的设计和实施经验。他使用多种编程语言开发过在不同场景中很实用的应用程序，并教会一些科学家和工程师如何使用编程语言开发一些实用的程序。他目前出版的图书涉及C、C  和Java等编程语言。当他没有在撰写编程图书或者为他人提供咨询服务时，他会去钓鱼或旅行，享受生活。<br/><br/>Peter Van Weert是一名软件工程师，主要兴趣和专长是应用软件开发、编程语言、算法和数据结构。他在鲁汶大学以最优毕业生荣誉获得计算机科学硕士学位，并得到了考试委员会的祝贺。2010年，他在鲁汶大学的声明式编程语言和人工智能研究组完成了博士论文，主题是基于规则的编程语言的设计和高效编译。在攻读博士期间，他担任面向对象编程(Java)、软件分析与设计以及声明式编程的助教。<br/>毕业后，Peter在Nikon Metrology工作了6年多，负责3D激光扫描和点云检查领域的大规模工业应用软件设计。他学习并精通C  以及极大规模代码库的重构和调试，并进一步熟悉了软件开发过程的各个方面，包括功能和技术需求的分析，以及敏捷的、基于Scrum的项目和团队管理。<br/>如今，Peter就职于Danaher的数字牙医软件研发部，为未来的牙医业开发软件。<br/>在空余时间，他与人合作撰写了两本关于C  的图书，开发了两个获奖的Windows 8应用，并且是比利时C  用户组的定期专家演讲人和董事会成员。<br/><br/></p>]<p><h2>目录</h2></p>
    目    录第1章  基本概念   11.1  现代C     11.2  标准库   21.3  C  程序概念   21.3.1  源文件和头文件   31.3.2  注释和空白   31.3.3  预处理指令和标准库头文件   31.3.4  函数   31.3.5  语句   41.3.6  数据的输入输出   41.3.7  return语句   51.3.8  名称空间   51.3.9  名称和关键字   61.4  类和对象   61.5  模板   61.6  代码的表示样式和编程风格   71.7  创建可执行文件   71.8  过程化编程和面向对象编程   81.9  表示数字   91.9.1  二进制数   91.9.2  十六进制数   101.9.3  负的二进制数   111.9.4  八进制数   121.9.5  Big-Endian和Little-Endian系统   121.9.6  浮点数   131.10  表示字符   141.10.1  ASCII 码   141.10.2  UCS和Unicode   141.11  C  源字符   151.12  本章小结   171.13  练习   17第2章  基本数据类型   192.1  变量、数据和数据类型   192.1.1  定义整型变量   192.1.2  零初始化   222.1.3  定义有固定值的变量   222.2  整型字面量   222.2.1  十进制整型字面量   232.2.2  十六进制的整型字面量   232.2.3  八进制的整型字面量   242.2.4  二进制的整型字面量   242.3  整数的计算   242.4  赋值运算   262.5  sizeof运算符   292.6  整数的递增和递减   302.7  定义浮点变量   312.8  浮点字面量   322.9  浮点数的计算   322.9.1  缺点   322.9.2  无效的浮点结果   332.9.3  数学函数   332.10  输出流的格式化   352.11  混合的表达式和类型转换   372.12  显式类型转换   382.13  确定数值的上下限   402.14  使用字符变量   412.15  auto关键字   422.16  本章小结   432.17  练习   43第3章  处理基本数据类型   453.1  运算符的优先级和相关性   453.2  位运算符   463.2.1  移位运算符   473.2.2  位模式下的逻辑运算   493.3  枚举数据类型   533.4  数据类型的别名   553.5  变量的生存期   563.6  全局变量   563.7  本章小结   593.8  练习   59第4章  决策   614.1  比较数据值   614.1.1  应用比较运算符   624.1.2  比较浮点数值   634.2  if语句   634.2.1  嵌套的if语句   654.2.2  字符分类和转换   664.3  if-else语句   684.3.1  嵌套的if-else语句   694.3.2  理解嵌套的if语句   704.4  逻辑运算符   714.4.1  逻辑与运算符   714.4.2  逻辑或运算符   714.4.3  逻辑非运算符   724.4.4  组合逻辑运算符   724.4.5  对整数操作数应用逻辑运算符   734.4.6  对比逻辑运算符与位运算符   744.5  条件运算符   754.6  switch语句   764.7  语句块和变量作用域   814.8  本章小结   824.9  练习   83第5章  数组和循环   855.1  数组   855.2  理解循环   875.3  for循环   875.4  避免幻数   895.5  用初始化列表定义数组的大小   905.6  确定数组的大小   905.7  用浮点数控制for循环   915.8  使用更复杂的for循环控制表达式   935.9  基于范围的for循环   945.10  while循环   955.11  do-while循环   965.12  嵌套的循环   985.13  跳过循环迭代   1005.14  循环的中断   1015.15  使用无符号整数控制for循环   1035.16  字符数组   1045.17  多维数组   1075.17.1  初始化多维数组   1085.17.2  多维字符数组   1105.18  在运行期间给数组分配内存空间   1115.19  数组的替代品   1125.19.1  使用array容器   1135.19.2  使用std::vector容器   1165.20  本章小结   1195.21  练习   120第6章  指针和引用   1216.1  什么是指针   1216.2  地址运算符   1236.3  间接运算符   1246.4  为什么使用指针   1256.5  char类型的指针   1256.6  常量指针和指向常量的指针   1286.7  指针和数组   1306.7.1  指针的算术运算   1306.7.2  使用数组名的指针表示法   1326.8  动态内存分配   1336.8.1  栈和自由存储区   1346.8.2  运算符new和delete   1346.8.3  数组的动态内存分配   1356.9  通过指针选择成员   1386.10  动态内存分配的危险   1386.10.1  悬挂指针和多次释放   1386.10.2  分配与释放的不匹配   1396.10.3  内存泄漏   1396.10.4  自由存储区的碎片   1396.11  内存分配的黄金准则   1406.12  原始指针和智能指针   1406.12.1  使用unique_ptr指针   1416.12.2  使用shared_ptr指针   1436.13  理解引用   1466.13.1  定义引用   1466.13.2  在基于范围的for循环中使用引用变量   1476.14  本章小结   1486.15  练习   148第7章  操作字符串   1517.1  更强大的string类   1517.1.1  定义string对象   1517.1.2  string对象的操作   1547.1.3  访问字符串中的字符   1577.1.4  访问子字符串   1587.1.5  比较字符串   1587.1.6  搜索字符串   1627.1.7  修改字符串   1677.1.8  对比std::string与std::vector   1707.2  将字符串转换为数字   1717.3  字符串流   1717.4  国际字符串   1727.4.1  存储wchar_t字符的字符串   1727.4.2  包含Unicode字符串的对象   1737.5  原始字符串字面量   1737.6  本章小结   1747.7  练习   175第8章  定义函数   1778.1  程序的分解   1778.1.1  类中的函数   1778.1.2  函数的特征   1788.2  定义函数   1788.2.1  函数体   1798.2.2  返回值   1808.2.3  函数声明   1818.3  给函数传送实参   1828.3.1  按值传送   1828.3.2  按引用传送   1878.3.3  字符串视图：新的const string引用   1928.4  默认实参值   1948.5  main()函数的实参   1968.6  从函数中返回值   1968.6.1  返回指针   1978.6.2  返回引用   1998.6.3  对比返回值与输出参数   2008.6.4  返回类型推断   2008.6.5  使用可选值   2018.7  静态变量   2038.8  内联函数   2048.9  函数重载   2048.9.1  重载和指针参数   2068.9.2  重载和引用参数   2068.9.3  重载和const参数   2078.9.4  重载和默认实参值   2088.10  递归   2098.10.1  基本示例   2098.10.2  递归算法   2108.11  本章小结   2158.12  练习   216第9章  函数模板   2199.1  函数模板   2199.2  创建函数模板的实例   2209.3  模板类型参数   2219.4  显式指定模板实参   2219.5  函数模板的特例   2229.6  函数模板和重载   2229.7  带有多个参数的函数模板   2249.8  模板的返回类型推断   2259.8.1  decltype和拖尾返回类型   2259.8.2  对比decltype(auto)、拖尾decltype()与auto   2269.9  模板参数的默认值   2269.10  非类型的模板参数   2279.11  本章小结   2299.12  练习   229第10章  程序文件和预处理指令   23110.1  理解转换单元   23110.1.1  单一定义规则   23110.1.2  程序文件和链接   23210.1.3  确定名称的链接属性   23210.1.4  外部函数   23310.1.5  外部变量   23310.1.6  内部名称   23510.2  预处理源代码   23610.3  定义预处理宏   23610.3.1  定义类似于函数的宏   23810.3.2  取消宏的定义   23910.4  包含头文件   24010.4.1  防止重复头文件的内容   24010.4.2  **个头文件   24110.5  名称空间   24210.5.1  全局名称空间   24210.5.2  定义名称空间   24210.5.3  应用using声明   24410.5.4  函数和名称空间   24410.5.5  未命名的名称空间   24610.5.6  嵌套的名称空间   24710.5.7  名称空间的别名   24810.6  逻辑预处理指令   24810.6.1  逻辑#if指令   24810.6.2  测试指定标识符的值   24910.6.3  多个代码选择   24910.6.4  标准的预处理宏   25010.6.5  检查头文件是否可用   25110.7  调试方法   25110.7.1  集成调试器   25210.7.2  调试中的预处理指令   25210.7.3  使用assert()宏   25410.8  静态断言   25510.9  本章小结   25710.10  练习   257第11章  定义自己的数据类型   25911.1  类和面向对象编程   25911.1.1  封装   26011.1.2  继承   26211.1.3  多态性   26311.2  术语   26311.3  定义类   26411.4  构造函数   26511.4.1  默认构造函数   26511.4.2  定义类的构造函数   26611.4.3  使用default关键字   26711.4.4  在类的外部定义函数和构造函数   26711.4.5  默认构造函数的参数值   26811.4.6  使用成员初始化列表   26911.4.7  使用explicit关键字   26911.4.8  委托构造函数   27111.4.9  副本构造函数   27211.5  访问私有类成员   27311.6  this指针   27411.7  const对象和const成员函数   27511.7.1  const成员函数   27611.7.2  const正确性   27711.7.3  重载const   27711.7.4  常量的强制转换   27911.7.5  使用mutable关键字   27911.8  友元   28011.8.1  类的友元函数   28011.8.2  友元类   28111.9  类的对象数组   28211.10  类对象的大小   28311.11  类的静态成员   28311.11.1  静态成员变量   28311.11.2  访问静态成员变量   28611.11.3  静态常量   28611.11.4  类类型的静态成员变量   28711.11.5  静态成员函数   28811.12  析构函数   28811.13  使用指针作为类成员   29011.14  嵌套类   29911.15  本章小结   30211.16  练习   303第12章  运算符重载   30512.1  为类实现运算符   30512.1.1  运算符重载   30512.1.2  实现重载运算符   30612.1.3  非成员运算符函数   30712.1.4  提供对运算符的全部支持   30812.1.5  在类中实现所有的比较运算符   30912.2  可以重载的运算符   31112.3  运算符函数习语   31312.4  为输出流重载模板   48118.5  本章小结   48218.6  练习   483第19章  容器与算法   48519.1  容器   48519.1.1  顺序容器   48519.1.2  栈和队列   48819.1.3  集合   48919.1.4  映射   49119.2  迭代器   49419.2.1  迭代器设计模式   49519.2.2  标准库容器的迭代器   49619.2.3  数组的迭代器   50219.3  算法   50319.3.1  **个示例   50319.3.2  寻找元素   50419.3.3  输出多个值   50519.3.4  删除-擦除技术   50719.3.5  排序   50719.3.6  并行算法   50819.4  本章小结   50819.5  练习   509
