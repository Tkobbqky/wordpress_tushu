Unity 3D脚本编程-使用C#语言开发跨平台游戏 PDF下载 陈嘉栋 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712129718
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712129718
<p>书名:Unity 3D脚本编程-使用C#语言开发跨平台游戏</p><p>作者:陈嘉栋</p><p>页数:404</p><p>定价:¥79.0</p><p>出版社:电子工业出版社</p><p>出版日期:2016-09-01</p><p>ISBN:9787121297182</p><p><h2>本书特色</h2></p>[<p>
      本书以Unity 3D的跨平台基础Mono以及其游戏脚本语言C#为基础进行讲解。全面系统地剖析了Unity 3D的跨平台原理以及游戏脚本开发的特点。第1章主要介绍了Unity 3D引擎的历史以及编辑器的基本知识；第2章主要介绍了Mono，以及Unity 3D利用Mono实现跨平台的原理，并且分析了C#语言为何更加适合Unity 3D游戏开发；第3章到第10章主要介绍了Unity 3D游戏脚本语言C#在使用Unity 3D开发过程中的知识点，包括Unity 3D脚本的类型基础、数据结构、在Unity 3D脚本中使用泛型、使用委托和事件打造自己的消息系统、利用定制特性来拓展Unity 3D的编辑器、Unity 3D协程背后的秘密——迭代器以及可空类型和序列化在Unity 3D中使用的相关知识；第11章到第14章，则主要介绍了Unity 3D的资源管理以及优化和编译的内容。
                                        </p>]<p><h2>内容简介</h2></p>[<p>1. 微软MVP张善友倾情作序，力荐本书。
2. 本书作者是2015年微软MVP，博客园推荐博客博主，在游戏蛮牛及InfoQ网站发表过多篇文章。
3. 本书以Unity 3D的跨平台基础Mono及其游戏脚本语言C#为基础进行讲解，全面系统地剖析了Unity 3D的跨平台原理以及游戏脚本开发的特点。
4. 无论是初次接触Unity 3D脚本编程的新人，还是有一定经验的老手，相信都可以借本书来提高自己在Unity 3D 方面的水平。 </p>]<p><h2>作者简介</h2></p>[<p>      陈嘉栋，毕业于大连海事大学，目前任光宇在线客户端高级开发工程师。博客园推荐博客作者，微软2015年度Visual Studio and Development Technologies最有价值专家（Most Valuable Professional）。认为编程首先是爱好，其次才是职业。专注前沿技术，热爱开源。深信代码改变世界。
      没有值得吹嘘的项目，只有不断前行的动力。</p>]<p><h2>目录</h2></p>
    第1 章 Hello Unity 3D                          1  1.1 Unity 3D 游戏引擎进化史                      1  1.2 Unity 3D 编辑器初印象                      5    1.2.1 Project 视图                      5    1.2.2 Inspector 视图                    8    1.2.3 Hierarchy 视图                     9    1.2.4 Game 视图                     10    1.2.5 Scene 视图                    12    1.2.6 绘图模式                     14    1.2.7 渲染模式                    16    1.2.8 场景视图控制                     17    1.2.9 Effects 菜单和Gizmos 菜单                    18  1.3 Unity 3D 的组成                     18  1.4 为何需要游戏脚本                     20第1 章 Hello Unity 3D                          1  1.1 Unity 3D 游戏引擎进化史                      1  1.2 Unity 3D 编辑器初印象                      5    1.2.1 Project 视图                      5    1.2.2 Inspector 视图                    8    1.2.3 Hierarchy 视图                     9    1.2.4 Game 视图                     10    1.2.5 Scene 视图                    12    1.2.6 绘图模式                     14    1.2.7 渲染模式                    16    1.2.8 场景视图控制                     17    1.2.9 Effects 菜单和Gizmos 菜单                    18  1.3 Unity 3D 的组成                     18  1.4 为何需要游戏脚本                     20  1.5 本章总结                      21第2 章 Mono 所搭建的脚本核心基础                    22  2.1 Mono 是什么                    22    2.1.1 Mono 的组成                    22    2.1.2 Mono 运行时                     23  2.2 Mono 如何扮演脚本的角色                    24    2.2.1 Mono 和脚本                     24    2.2.2 Mono 运行时的嵌入                    26  2.3 Unity 3D 为何能跨平台？聊聊CIL                    38    2.3.1 Unity 3D 为何能跨平台                      38    2.3.2 CIL 是什么                     40    2.3.3 Unity 3D 如何使用CIL 跨平台                     44  2.4 脚本的选择，C# 或 JavaScript                    48    2.4.1 *熟悉的陌生人——UnityScript                    48    2.4.2 UnityScript 与 JavaScript                     51    2.4.3 C#与UnityScript                     55  2.5 本章总结                    57第3 章 Unity 3D 脚本语言的类型系统                    58  3.1 C#的类型系统                     58  3.2 值类型和引用类型                     65  3.3 Unity 3D 脚本语言中的引用类型                    73  3.4 Unity 3D 游戏脚本中的值类型                    90    3.4.1 Vector2、Vector3 以及Vector4                     90    3.4.2 其他常见的值类型                   94  3.5 装箱和拆箱                    95  3.6 本章总结                    98第4 章 Unity 3D 中常用的数据结构                   99  4.1 Array 数组                   100  4.2 ArrayList 数组                   101  4.3 List＜T＞数组                   102  4.4 C#中的链表——LinkedList＜T＞                    103  4.5 队列（Queue＜T＞）和栈（Stack＜T＞）                    107  4.6 Hash Table（哈希表）和Dictionary＜K,T＞（字典）                   112  4.7 本章总结                    120第5 章 在Unity 3D 中使用泛型                    121  5.1 为什么需要泛型机制                    121  5.2 Unity 3D 中常见的泛型                     124  5.3 泛型机制的基础                   127    5.3.1 泛型类型和类型参数                     128    5.3.2 泛型类型和继承                   131    5.3.3 泛型接口和泛型委托                     131    5.3.4 泛型方法                    136  5.4 泛型中的类型约束和类型推断                    139    5.4.1 泛型中的类型约束                   139    5.4.2 类型推断                144
  5.5 本章总结                    146
第6 章 在Unity 3D 中使用委托            149
  6.1 向Unity 3D 中的SendMessage 和BroadcastMessage 说拜拜            150
  6.2 认识回调函数机制——委托            151
  6.3 委托是如何实现的            154
  6.4 委托是如何调用多个方法的             160
  6.5 用事件（Event）实现消息系统            164
  6.6 事件是如何工作的             169
  6.7 定义事件的观察者，实现观察者模式             172
  6.8 委托的简化语法             177
    6.8.1 不必构造委托对象            177
    6.8.2 匿名方法             178
    6.8.3 Lambda 表达式             196
  6.9 本章总结             201
第7 章 Unity 3D 中的定制特性             202
  7.1 初识特性——Attribute             202
    7.1.1 DllImport 特性            203
    7.1.2 Serializable 特性             205
    7.1.3 定制特性到底是谁              207
  7.2 Unity 3D 中提供的常用定制特性            208
  7.3 定义自己的定制特性类             213
  7.4 检测定制特性             216
  7.5 亲手拓展Unity 3D 的编辑器              217
  7.6 本章总结            227
第8 章 Unity 3D 协程背后的迭代器              228
  8.1 初识Unity 3D 中的协程             228
    8.1.1 使用StartCoroutine 方法开启协程             229
    8.1.2 使用StopCoroutine 方法停止一个协程             233
  8.2 使用协程实现延时效果            234
  8.3 Unity 3D 协程背后的秘密——迭代器             238
    8.3.1 你好，迭代器             238
    8.3.2 原来是状态机             242
    8.3.3. 状态管理             248
  8.4 WWW和协程             253
  8.5 Unity 3D 协程代码实例             257
  8.6 本章总结            259
第9 章 在Unity 3D 中使用可空型              260
  9.1 如果没有值            260
  9.2 表示空值的一些方案             261
    9.2.1 使用魔值              261
    9.2.2 使用标志位             261
    9.2.3 借助引用类型来表示值类型的空值             265
  9.3 使用可空值类型             267
  9.4 可空值类型的简化语法             272
  9.5 可空值类型的装箱和拆箱              278
  9.6 本章总结             280
第10 章 从序列化和反序列化看Unity 3D 的存储机制             281
  10.1 初识序列化和反序列化             281
  10.2 控制类型的序列化和反序列化             290
    10.2.1 如何使类型可以序列化             290
    10.2.2 如何选择序列化的字段和控制反序列化的流程             292
    10.2.3 序列化、反序列化中流的上下文介绍及应用           296
  10.3 Unity 3D 中的序列化和反序列化             299
    10.3.1 Unity 3D 的序列化概览           299
    10.3.2 对Unity 3D 游戏脚本进行序列化的注意事项            302
    10.3.3 如何利用Unity 3D 提供的序列化器对自定义类型进行序列化           305
  10.4 Prefab 和实例化之谜——序列化和反序列化的过程            309
    10.4.1 认识预制体Prefab             309
    10.4.2 实例化一个游戏对象            311
    10.4.3 序列化和反序列化之谜            314
  10.5 本章总结            317
第11 章 移动平台动态读取外部文件             318
  11.1 假如我想在编辑器里动态读取文件            318
  11.2 移动平台的资源路径问题           320
  11.3 移动平台读取外部文件的方法            323
  11.4 使用Resources 类加载资源            330
  11.5 使用WWW类加载资源            332
    11.5.1 利用WWW类的构造函数实现资源下载            332
    11.5.2 利用 WWW.LoadFromCacheOrDownload 方法实现资源下载            333
    11.5.3 利用WWWForm 类实现POST 请求            335
  11.6 本章总结            335
第12 章 在Unity 3D 中使用AssetBundle           336
  12.1 初识AssetBundle           336
  12.2 使用AssetBundle 的工作流程            337
    12.2.1 开发阶段             337
    12.2.2 运行阶段            340
  12.3 如何使用本地磁盘中的AssetBundle 文件          344
  12.4 AssetBundle 文件的平台兼容性            345
  12.5 AssetBundle 如何识别资源          345
  12.6 本章总结            346
第13 章 Unity 3D 优化            347
  13.1 看看Unity 3D 优化需要从哪里着手           347
  13.2 CPU 方面的优化            348
    13.2.1 对DrawCall 的优化           348
    13.2.2 对物理组件的优化           354
    13.2.3 处理内存，却让CPU 受伤的GC            355
    13.2.4 对代码质量的优化            356
  13.3 对GPU 的优化           357
    13.3.1 减少绘制的数目          358
    13.3.2 优化显存带宽          358
  13.4 内存的优化           359
    13.4.1 Unity 3D 的内部内存           359
    13.4.2 Mono 的托管内存           360
  13.5 本章总结           363
第14 章 Unity 3D 的脚本编译             365
  14.1 Unity 3D 脚本编译流程概览            365
  14.2 JIT 即时编译            368
    14.2.1 使用编译器将游戏脚本编译为托管模块            368
    14.2.2 托管模块和程序集           369
    14.2.3 使用JIT 编译执行程序集的代码           370
    14.2.4 使用JIT 即时编译的优势             371
  14.3 AOT 提前编译            372
    14.3.1 在Unity 3D 中使用AOT 编译            372
    14.3.2 iOS 平台和Full-AOT 编译              373
    14.3.3 AOT 编译的优势             374
  14.4 谁偷了我的热更新？Mono、JIT 还是iOS             374
    14.4.1 从一个常见的报错说起            375
    14.4.2 美丽的JIT             377
    14.4.3 模拟JIT 的过程              378
    14.4.4 iOS 平台的自我保护              381
  14.5 Unity 3D 项目的编译与发布              382
    14.5.1 选择游戏场景和目标平台             382
    14.5.2 Unity 3D 发布项目的内部过程            384
    14.5.3 Unity 3D 部署到Android 平台             384
    14.5.4 Unity 3D 部署到iOS 平台             386
  14.6 本章总结             389信息
