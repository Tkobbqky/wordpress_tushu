C++Primer中文版-(第5版) PDF下载 （美）李普曼，（美）拉乔伊，（美）默著，王刚，杨巨峰译 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712115535
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712115535
<p>书名:C++Primer中文版-(第5版)</p><p>作者:（美）李普曼，（美）拉乔伊 ，（美）默 著，王刚，杨巨峰  译</p><p>页数:838</p><p>定价:¥128.0</p><p>出版社:电子工业出版社</p><p>出版日期:2013-09-01</p><p>ISBN:9787121155352</p><p><h2>节选</h2></p>[<p>英文版推荐:<br/><a href="http://product.dangdang.com/23225887.html" target="_blank">C++ Primer英文版(第5版)(史上*畅销C++书,全新标准全面重写) </a> <br/>C++领域权威 潘爱民|孟岩作序,代表技术圈鼎力推荐<br/>一线C++工程师腾讯Milo、微软刘未鹏|陈梓瀚、阿里李云|侯凤林高水准技术审校<br/>如果只读一本C++书籍,相信所有读过的人都会毫不犹豫选择本书,无论初学或老手<br/>既可用来理解C++11规则背后的原理,也可用其新语言特性与标准库来快速构建健壮程序<br/>采用中文版页码全面呈现原书大量交叉引用及详尽索引,新式辅学设置与课后操练用于避开陷阱、巩固良法</p>]<p><h2>本书特色</h2></p>[<p>

                                    
                                        英文版推荐：c++
primer英文版（第5版）(史上*畅销c++书，全新标准全面重写)　　
c++领域权威 潘爱民|孟岩作序，代表技术圈鼎力推荐
一线c++工程师腾讯milo、微软刘未鹏|陈梓瀚、阿里李云|侯凤林高水准技术审校
如果只读一本c++书籍，相信所有读过的人都会毫不犹豫选择本书，无论初学或老手
既可用来理解c++11规则背后的原理，也可用其新语言特性与标准库来快速构建健壮程序
采用中文版页码全面呈现原书大量交叉引用及详尽索引，新式辅学设置与课后操练用于避开陷阱、巩固良法                                    
                                        </p>]<p><h2>内容简介</h2></p>[<p>
                                    
                                        　　这本久负盛名的 c++经典教程，时隔八年之久，终迎来史无前例的重大升级。除令全球无数程序员从中受益，甚至为之迷醉的——c++
大师 stanley b. lippman 的丰富实践经验，c++标准委员会原负责人 josée lajoie
对c++标准的深入理解，以及c++ 先驱 barbara e. moo 在 c++教学方面的真知灼见外，更是基于全新的
c++11标准进行了全面而彻底的内容更新。非常难能可贵的是，《c++ primer 中文版(第5版)》所有示例均全部采用 c++11
标准改写，这在经典升级版中极其罕见——充分体现了 c++
语言的重大进展及其全面实践。书中丰富的教学辅助内容、醒目的知识点提示，以及精心组织的编程示范，让这本书在 c++
领域的权威地位更加不可动摇。无论是初学者入门，或是中、高级程序员提升，本书均为不容置疑的首选。                                    </p>]<p><h2>作者简介</h2></p>[<p>
                                    
                                        　　Stanley B. Lippman目前是微软公司 Visual C++
团队的架构师。他从1984年开始在贝尔实验室与C++的设计者Bjarne
Stroustrup一起从事C++的设计与开发。他在迪士尼和梦工厂从事动画制作，还担任过JPL的高级顾问。
　　Josée Lajoie曾经是IBM加拿大研究中心C/C++编译器开发团队的成员，在ISO
C++标准委员会工作了7年，担任过ISO核心语言工作组的主席和C++ Report杂志的专栏作家。
　　Barbara E.
Moo是拥有25年软件经验的独立咨询顾问。在AT&amp;T，她与Stroustrup、Lippman一起管理过复杂的C++开发项目。                                    </p>]<p><h2>目录</h2></p>
第1章  开始1.1  编写一个简单的c++程序1.1.1  编译、运行程序1.2  初识输入输出1.3  注释简介1.4  控制流1.4.1  while语句1.4.2  for语句1.4.3  读取数量不定的输入数据1.4.4  if语句1.5  类简介1.5.1  sales_item类1.5.2  初识成员函数1.6  书店程序小结术语表第ⅰ部分  c++基础第2章  变量和基本类型2.1  基本内置类型2.1.1  算术类型2.1.2  类型转换2.1.3  字面值常量2.2  变量2.2.1  变量定义2.2.2  变量声明和定义的关系2.2.3  标识符2.2.4  名字的作用域2.3  复合类型2.3.1  引用2.3.2  指针2.3.3  理解复合类型的声明2.4  const限定符2.4.1  const的引用2.4.2  指针和const2.4.3  顶层const2.4.4  constexpr和常量表达式2.5  处理类型2.5.1  类型别名2.5.2  auto类型说明符2.5.3  decltype类型指示符2.6  自定义数据结构2.6.1  定义sales_data类型2.6.2  使用sales_data类2.6.3  编写自己的头文件小结术语表第3章  字符串、向量和数组3.1  命名空间的using声明3.2  标准库类型string3.2.1  定义和初始化string对象3.2.2  string对象上的操作3.2.3  处理string对象中的字符3.3  标准库类型vector3.3.1  定义和初始化vector对象3.3.2  向vector对象中添加元素3.3.3  其他vector操作3.4  迭代器介绍3.4.1  使用迭代器3.4.2  迭代器运算3.5  数组3.5.1  定义和初始化内置数组3.5.2  访问数组元素3.5.3  指针和数组3.5.4  c风格字符串3.5.5  与旧代码的接口3.6  多维数组小结术语表第4章  表达式4.1  基础4.1.1  基本概念4.1.2  优先级与结合律4.1.3  求值顺序4.2  算术运算符4.3  逻辑和关系运算符4.4  赋值运算符4.5  递增和递减运算符4.6  成员访问运算符4.7  条件运算符4.8  位运算符4.9  sizeof运算符4.10  逗号运算符4.11  类型转换4.11.1  算术转换4.11.2  其他隐式类型转换4.11.3  显式转换4.12  运算符优先级表小结术语表第5章  语句5.1  简单语句5.2  语句作用域5.3  条件语句5.3.1  if语句5.3.2  switch语句5.4  迭代语句5.4.1  while语句5.4.2  传统的for语句5.4.3  范围for语句5.4.4  do while语句5.5  跳转语句5.5.1  break语句5.5.2  continue语句5.5.3  goto语句5.6  try语句块和异常处理5.6.1  throw表达式5.6.2  try语句块5.6.3  标准异常小结术语表第6章  函数6.1  函数基础6.1.1  局部对象6.1.2  函数声明6.1.3  分离式编译6.2  参数传递6.2.1  传值参数6.2.2  传引用参数6.2.3  const形参和实参6.2.4  数组形参6.2.5  main：处理命令行选项6.2.6  含有可变形参的函数6.3  返回类型和return语句6.3.1  无返回值函数6.3.2  有返回值函数6.3.3  返回数组指针6.4  函数重载6.4.1  重载与作用域6.5  特殊用途语言特性6.5.1  默认实参6.5.2  内联函数和constexpr函数6.5.3  调试帮助6.6  函数匹配6.6.1  实参类型转换6.7  函数指针小结术语表第7章  类7.1  定义抽象数据类型7.1.1  设计sales_data类7.1.2  定义改进的sales_data类7.1.3  定义类相关的非成员函数7.1.4  构造函数7.1.5  拷贝、赋值和析构7.2  访问控制与封装7.2.1  友元7.3  类的其他特性7.3.1  类成员再探7.3.2  返回*this的成员函数7.3.3  类类型7.3.4  友元再探7.4  类的作用域7.4.1  名字查找与类的作用域7.5  构造函数再探7.5.1  构造函数初始值列表7.5.2  委托构造函数7.5.3  默认构造函数的作用7.5.4  隐式的类类型转换7.5.5  聚合类7.5.6  字面值常量类7.6  类的静态成员小结术语表第ⅱ部  c++标准库第8章  io库8.1  io类8.1.1  io对象无拷贝或赋值8.1.2  条件状态8.1.3  管理输出缓冲8.2  文件输入输出8.2.1  使用文件流对象8.2.2  文件模式8.3  string流8.3.1  使用istringstream8.3.2  使用ostringstream小结术语表第9章  顺序容器9.1  顺序容器概述9.2  容器库概览9.2.1  迭代器9.2.2  容器类型成员9.2.3  begin和end成员9.2.4  容器定义和初始化9.2.5  赋值和swap9.2.6  容器大小操作9.2.7  关系运算符9.3  顺序容器操作9.3.1  向顺序容器添加元素9.3.2  访问元素9.3.3  删除元素9.3.4  特殊的forward_list操作9.3.5  改变容器大小9.3.6  容器操作可能使迭代器失效9.4  vector对象是如何增长的9.5  额外的string操作9.5.1  构造string的其他方法9.5.2  改变string的其他方法9.5.3  string搜索操作9.5.4  compare函数9.5.5  数值转换9.6  容器适配器小结术语表第10章  泛型算法10.1  概述10.2  初识泛型算法10.2.1  只读算法10.2.2  写容器元素的算法10.2.3  重排容器元素的算法10.3  定制操作10.3.1  向算法传递函数10.3.2  lambda表达式10.3.3  lambda捕获和返回10.3.4  参数绑定10.4  再探迭代器10.4.1  插入迭代器10.4.2  iostream迭代器10.4.3  反向迭代器10.5  泛型算法结构10.5.1  5类迭代器10.5.2  算法形参模式10.5.3  算法命名规范10.6  特定容器算法小结术语表第11章  关联容器11.1  使用关联容器11.2  关联容器概述11.2.1  定义关联容器11.2.2  关键字类型的要求11.2.3  pair类型11.3  关联容器操作11.3.1  关联容器迭代器11.3.2  添加元素11.3.3  删除元素11.3.4  map的下标操作11.3.5  访问元素11.3.6  一个单词转换的map11.4  无序容器小结术语表第12章  动态内存12.1  动态内存与智能指针12.1.1  shared_ptr类12.1.2  直接管理内存12.1.3  shared_ptr和new结合使用12.1.4  智能指针和异常12.1.5  unique_ptr12.1.6  weak_ptr12.2  动态数组12.2.1  new和数组12.2.2  allocator类12.3  使用标准库：文本查询程序12.3.1  文本查询程序设计12.3.2  文本查询程序类的定义小结术语表第ⅲ部分  类设计者的工具第13章  拷贝控制13.1  拷贝、赋值与销毁13.1.1  拷贝构造函数13.1.2  拷贝赋值运算符13.1.3  析构函数13.1.4  三/五法则13.1.5  使用=default13.1.6  阻止拷贝13.2  拷贝控制和资源管理13.2.1  行为像值的类13.2.2  定义行为像指针的类13.3  交换操作13.4  拷贝控制示例13.5  动态内存管理类13.6  对象移动13.6.1  右值引用13.6.2  移动构造函数和移动赋值运算符13.6.3  右值引用和成员函数小结术语表第14章  操作重载与类型转换14.1  基本概念14.2  输入和输出运算符14.2.1  重载输出运算符<<14.2.2  重载输入运算符>>14.3  算术和关系运算符14.3.1  相等运算符14.3.2  关系运算符14.4  赋值运算符14.5  下标运算符14.6  递增和递减运算符14.7  成员访问运算符14.8  函数调用运算符14.8.1  lambda是函数对象14.8.2  标准库定义的函数对象14.8.3  可调用对象与function14.9  重载、类型转换与运算符14.9.1  类型转换运算符14.9.2  避免有二义性的类型转换14.9.3  函数匹配与重载运算符小结术语表第15章  面向对象程序设计15.1  oop：概述15.2  定义基类和派生类15.2.1  定义基类15.2.2  定义派生类15.2.3  类型转换与继承15.3  虚函数15.4  抽象基类15.5  访问控制与继承15.6  继承中的类作用域15.7  构造函数与拷贝控制15.7.1  虚析构函数15.7.2  合成拷贝控制与继承15.7.3  派生类的拷贝控制成员15.7.4  继承的构造函数15.8  容器与继承15.8.1  编写basket类15.9  文本查询程序再探15.9.1  面向对象的解决方案15.9.2  query_base类和query类15.9.3  派生类15.9.4  eval函数小结术语表第16章  模板与泛型编程16.1  定义模板16.1.1  函数模板16.1.2  类模板16.1.3  模板参数16.1.4  成员模板16.1.5  控制实例化16.1.6  效率与灵活性16.2  模板实参推断16.2.1  类型转换与模板类型参数16.2.2  函数模板显式实参16.2.3  尾置返回类型与类型转换16.2.4  函数指针和实参推断16.2.5  模板实参推断和引用16.2.6  理解std::move16.2.7  转发16.3  重载与模板16.4  可变参数模板16.4.1  编写可变参数函数模板16.4.2  包扩展16.4.3  转发参数包16.5  模板特例化小结术语表第ⅳ部分  高级主题第17章  标准库特殊设施17.1  tuple类型17.1.1  定义和初始化tuple17.1.2  使用tuple返回多个值17.2  bitset类型17.2.1  定义和初始化bitset17.2.2  bitset操作17.3  正则表达式17.3.1  使用正则表达式库17.3.2  匹配与regex迭代器类型17.3.3  使用子表达式17.3.4  使用regex_replace17.4  随机数17.4.2  其他随机数分布bernoulli_distribution类17.5  io库再探17.5.1  格式化输入与输出17.5.2  未格式化的输入/输出操作17.5.3  流随机访问小结术语表第18章  用于大型程序的工具18.1  异常处理18.1.1  抛出异常18.1.2  捕获异常18.1.3  函数try语句块与构造函数18.1.4  noexcept异常说明18.1.5  异常类层次18.2  命名空间18.2.1  命名空间定义18.2.2  使用命名空间成员18.2.3  类、命名空间与作用域18.2.4  重载与命名空间18.3  多重继承与虚继承18.3.1  多重继承18.3.2  类型转换与多个基类18.3.3  多重继承下的类作用域18.3.4  虚继承18.3.5  构造函数与虚继承小结术语表第19章  特殊工具与技术19.1  控制内存分配19.1.1  重载new和delete19.1.2  定位new表达式19.2  运行时类型识别19.2.1  dynamic_cast运算符19.2.2  typeid运算符19.2.3  使用rtti19.2.4  type_info类19.3  枚举类型19.4  类成员指针19.4.1  数据成员指针19.4.2  成员函数指针19.4.3  将成员函数用作可调用对象19.5  嵌套类19.6  union：一种节省空间的类19.7  局部类19.8  固有的不可移植的特性19.8.1  位域19.8.2  volatile限定符19.8.3  链接指示：extern "c"小结术语表附录a  标准库a.1  标准库名字和头文件a.2  算法概览a.2.1  查找对象的算法a.2.2  其他只读算法a.2.3  二分搜索算法a.2.4  写容器元素的算法a.2.5  划分与排序算法a.2.6  通用重排操作a.2.7  排列算法a.2.8  有序序列的集合算法a.2.9  *小值和*大值a.2.10  数值算法a.3  随机数a.3.1  随机数分布a.3.2  随机数引擎c++11的新特性2.1.1  long long类型2.2.1  列表初始化2.3.2  nullptr常量2.4.4  constexpr变量2.5.1  类型别名声明2.5.2  auto类型指示符2.5.3  decltype类型指示符2.6.1  类内初始化3.2.2  使用auto或decltype缩写类型3.2.3  范围for语句3.3   定义vector对象的vector（向量的向量）3.3.1  vector对象的列表初始化3.4.1  容器的cbegin和cend函数3.5.3  标准库begin和end函数3.6   使用auto和decltype简化声明4.2   除法的舍入规则4.4   用大括号包围的值列表赋值4.9   将sizeof用于类成员5.4.3 范围for语句6.2.6  标准库initializer_list类6.3.2  列表初始化返回值6.3.3  定义尾置返回类型6.3.3  使用decltype简化返回类型定义6.5.2  constexpr函数7.1.4  使用=default生成默认构造函数7.3.1  类对象成员的类内初始化7.5.2  委托构造函数7.5.6  constexpr构造函数8.2.1  用string对象处理文件名9.1   array和forward_list容器9.2.3 容器的cbegin和cend函数9.2.4  容器的列表初始化9.2.5  容器的非成员函数swap9.3.1  容器insert成员的返回类型9.3.1  容器的emplace成员的返回类型9.4   shrink_to_fit9.5.5  string的数值转换函数10.3.2  lambda表达式10.3.3  lambda表达式中的尾置返回类型10.3.4  标准库bind函数11.2.1  关联容器的列表初始化11.2.3  列表初始化pair的返回类型11.3.2  pair的列表初始化11.4   无序容器12.1   智能指针12.1.1  shared_ptr类12.1.2  动态分配对象的列表初始化12.1.2  auto和动态分配12.1.5  unique_ptr类12.1.6  weak_ptr类12.2.1  范围for语句不能应用于动态分配数组12.2.1  动态分配数组的列表初始化12.2.1  auto不能用于分配数组12.2.2  allocator::construct可使用任意构造函数13.1.5  将=default用于拷贝控制成员13.1.6  使用=default阻止拷贝类对象13.5   用移动类对象代替拷贝类对象13.6.1  右值引用13.6.1  标准库move函数13.6.2  移动构造函数和移动赋值13.6.2  移动构造函数通常应该是noexcept13.6.2  移动迭代器13.6.3  引用限定成员函数14.8.3  function类模板14.9.1  explicit类型转换运算符15.2.2  虚函数的override指示符15.2.2  通过定义类为final来阻止继承15.3   虚函数的override和final指示符15.7.2  删除的拷贝控制和继承15.7.4  继承的构造函数16.1.2  声明模板类型形参为友元16.1.2  模板类型别名16.1.3  模板函数的默认模板参数16.1.5  实例化的显式控制16.2.3  模板函数与尾置返回类型16.2.5  引用折叠规则16.2.6  用static_cast将左值转换为右值16.2.7  标准库forward函数16.4   可变参数模板16.4   sizeof...运算符16.4.3  可变参数模板与转发17.1   标准库tuple类模板17.2.2  新的bitset运算17.3   正则表达式库17.4   随机数库17.5.1  浮点数格式控制18.1.4  noexcept异常指示符18.1.4  noexcept运算符18.2.1  内联名字空间18.3.1  继承的构造函数和多重继承19.3   有作用域的enum19.3   说明类型用于保存enum对象19.3   enum的提前声明19.4.3  标准库mem_fn类模板19.6   类类型的联合成员                            
