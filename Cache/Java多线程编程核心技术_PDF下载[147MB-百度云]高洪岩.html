Java多线程编程核心技术 PDF下载 高洪岩 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711150206
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711150206
<p>书名:Java多线程编程核心技术</p><p>作者:高洪岩</p><p>页数:306</p><p>定价:¥69.0</p><p>出版社:机械工业出版社</p><p>出版日期:2015-06-01</p><p>ISBN:9787111502067</p><p><h2>本书特色</h2></p>[<p>
全书共7章。第1章讲解了java多线程的基础，重点介绍线程类的核心api的使用。第2章讲解对并发访问的控制，即如何写出线程安全的程序。第3章介绍线程间通信，以提高cpu利用率和系统间的交互，同时增强对线程任务的把控与监督。第4章讲解lock对象，以更好实现并发访问时的同步处理。第5章讲解移动开发中使用较多的定时器类的多线程技术，这是计划/任务执行里很重要的技术点。第6章讲解如何安全、正确地将单例模式与多线程技术相结合，避免实际应用中可能会出现的麻烦。第7章将前面被遗漏的案例在本章节中进行补充，尽量做到不出现技术空白点。
                                        </p>]<p><h2>目录</h2></p>
    目  录?contents前 言第1章 java多线程技能  11.1 进程和多线程的概念及线程的优点  11.2 使用多线程  31.2.1 继承thread类  41.2.2 实现runnable接口  81.2.3 实例变量与线程安全  91.2.4 留意i与system.out.println()的异常  141.3 currentthread()方法  161.4 isalive()方法  181.5 sleep()方法  201.6 getid()方法  221.7 停止线程  231.7.1 停止不了的线程  231.7.2 判断线程是否是停止状态  241.7.3 能停止的线程——异常法  271.7.4 在沉睡中停止  301.7.5 能停止的线程——暴力停止  321.7.6 方法stop()与java.lang.threaddeath异常  331.7.7 释放锁的不良后果  341.7.8 使用return停止线程  351.8 暂停线程  361.8.1 suspend与resume方法的使用  361.8.2 suspend与resume方法的缺点——独占  381.8.3 suspend与resume方法的缺点——不同步  401.9 yield方法  421.10 线程的优先级  431.10.1 线程优先级的继承特性  431.10.2 优先级具有规则性  441.10.3 优先级具有随机性  471.10.4 看谁运行得快  491.11 守护线程  501.12 本章小结  51第2章 对象及变量的并发访问  522.1 synchronized同步方法  522.1.1 方法内的变量为线程安全  532.1.2 实例变量非线程安全  542.1.3 多个对象多个锁  572.1.4 synchronized方法与锁对象  592.1.5 脏读  632.1.6 synchronized锁重入  652.1.7 出现异常，锁自动释放  682.1.8 同步不具有继承性  692.2 synchronized同步语句块  712.2.1 synchronized方法的弊端  722.2.2 synchronized同步代码块的使用  742.2.3 用同步代码块解决同步方法的弊端  762.2.4 一半异步，一半同步  762.2.5 synchronized代码块间的同步性  782.2.6 验证同步synchronized(this)代码块是锁定当前对象的  802.2.7 将任意对象作为对象监视器  822.2.8 细化验证3个结论  912.2.9 静态同步synchronized方法与synchronized(class)代码块  962.2.10 数据类型string的常量池特性  1022.2.11 同步synchronized方法无限等待与解决  1052.2.12 多线程的死锁  1072.2.13 内置类与静态内置类  1092.2.14 内置类与同步：实验1  1112.2.15 内置类与同步：实验2  1132.2.16 锁对象的改变  1142.3 volatile关键字  1182.3.1 关键字volatile与死循环  1182.3.2 解决同步死循环  1192.3.3 解决异步死循环  1202.3.4 volatile非原子的特性  1242.3.5 使用原子类进行i++操作  1262.3.6 原子类也并不完全安全  1272.3.7 synchronized代码块有volatile同步的功能  1302.4 本章总结  132第3章 线程间通信  1333.1 等待/通知机制  1333.1.1 不使用等待/通知机制实现线程间通信  1333.1.2 什么是等待/通知机制  1353.1.3 等待/通知机制的实现  1363.1.4 方法wait()锁释放与notify()锁不释放  1433.1.5 当interrupt方法遇到wait方法  1463.1.6 只通知一个线程  1483.1.7 唤醒所有线程  1503.1.8 方法wait(long)的使用  1503.1.9 通知过早  1523.1.10 等待wait的条件发生变化  1553.1.11 生产者/消费者模式实现  1583.1.12 通过管道进行线程间通信：字节流  1713.1.13 通过管道进行线程间通信：字符流  1743.1.14 实战：等待/通知之交叉备份  1773.2 方法join的使用  1793.2.1 学习方法join前的铺垫  1793.2.2 用join()方法来解决  1803.2.3 方法join与异常  1813.2.4 方法join(long)的使用  1833.2.5 方法join(long)与sleep(long)的区别  1843.2.6 方法join()后面的代码提前运行：出现意外   1873.2.7 方法join()后面的代码提前运行：解释意外  1893.3 类threadlocal的使用  1913.3.1 方法get()与null  1913.3.2 验证线程变量的隔离性  1923.3.3 解决get()返回null问题  1953.3.4 再次验证线程变量的隔离性  1953.4 类inheritablethreadlocal的使用  1973.4.1 值继承  1973.4.2 值继承再修改  1983.5 本章总结  199第4章 lock的使用  2004.1 使用reentrantlock类  2004.1.1 使用reentrantlock实现同步：测试1  2004.1.2 使用reentrantlock实现同步：测试2  2024.1.3 使用condition实现等待/通知错误用法与解决  2044.1.4 正确使用condition实现等待/通知  2074.1.5 使用多个condition实现通知部分线程：错误用法  2084.1.6 使用多个condition实现通知部分线程：正确用法  2104.1.7 实现生产者/消费者模式：一对一交替打印  2134.1.8 实现生产者/消费者模式：多对多交替打印  2144.1.9 公平锁与非公平锁  2164.1.10 方法getholdcount()、getqueuelength()和getwaitqueuelength()的测试  2194.1.11 方法hasqueuedthread()、hasqueuedthreads()和haswaiters()的测试  2224.1.12 方法isfair()、isheldbycurrentthread()和islocked()的测试  2244.1.13 方法lockinterruptibly()、trylock()和trylock(long timeout,timeunit unit)的测试  2264.1.14 方法awaituninterruptibly()的使用  2304.1.15 方法awaituntil()的使用  2324.1.16 使用condition实现顺序执行  2344.2 使用reentrantreadwritelock类  2364.2.1 类reentrantreadwritelock的使用：读读共享  2364.2.2 类reentrantreadwritelock的使用：写写互斥  2374.2.3 类reentrantreadwritelock的使用：读写互斥  2384.2.4 类reentrantreadwritelock的使用：写读互斥  2394.3 本章总结  240第5章 定时器timer  2415.1 定时器timer的使用  2415.1.1 方法schedule（timertask task, date time）的测试  2415.1.2 方法schedule(timertask task, date firsttime, long period)的测试  2475.1.3 方法schedule(timertask task, long delay)的测试  2525.1.4 方法schedule(timertask task, long delay, long period)的测试  2535.1.5 方法scheduleatfixedrate(timertask task, date firsttime, long period)的测试  2545.2 本章总结  261第6章 单例模式与多线程  2626.1 立即加载/“饿汉模式”  2626.2 延迟加载/“懒汉模式”  2636.3 使用静态内置类实现单例模式  2716.4 序列化与反序列化的单例模式实现  2726.5 使用static代码块实现单例模式  2746.6 使用enum枚举数据类型实现单例模式  2756.7 完善使用enum枚举实现单例模式  2776.8 本章总结  278第7章 拾遗增补  2797.1 线程的状态  2797.1.1 验证new、runnable和terminated  2807.1.2 验证timed_waiting  2817.1.3 验证blocked  2827.1.4 验证waiting  2847.2 线程组  2857.2.1 线程对象关联线程组：1级关联  2857.2.2 线程对象关联线程组：多级关联  2877.2.3 线程组自动归属特性  2887.2.4 获取根线程组  2887.2.5 线程组里加线程组  2897.2.6 组内的线程批量停止  2907.2.7 递归与非递归取得组内对象  2907.3 使线程具有有序性  2917.4 simpledateformat非线程安全  2937.4.1 出现异常  2937.4.2 解决异常方法1  2947.4.3 解决异常方法2  2957.5 线程中出现异常的处理  2977.6 线程组内处理异常  2997.7 线程异常处理的传递  3017.8 本章总结  306
