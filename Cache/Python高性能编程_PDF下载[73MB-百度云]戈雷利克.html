Python高性能编程 PDF下载 戈雷利克 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711545489
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711545489
<p>书名:Python高性能编程</p><p>作者:戈雷利克</p><p>页数:331</p><p>定价:¥79.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2017-07-01</p><p>ISBN:9787115454898</p><p><h2>本书特色</h2></p>[<p>
Python语言是一种脚本语言，其应用领域非常广泛，包括数据分析、自然语言处理、机器学习、科学计算、推荐系统构建等。
本书共有12章，围绕如何进行代码优化和加快实际应用的运行速度进行详细讲解。本书主要包含以下主题：计算机内部结构的背景知识、列表和元组、字典和集合、迭代器和生成器、矩阵和矢量计算、并发、集群和工作队列等。*后，通过一系列真实案例展现了在应用场景中需要注意的问题。
本书适合初级和中级Python程序员、有一定Python语言基础想要得到进阶和提高的读者阅读。
                                        </p>]<p><h2>内容简介</h2></p>[<p>Python代码仅仅能够正确运行还不够，你需要让它运行得更快。通过探索设计决策背后的基础理论，本书帮助你更加深刻地理解Python的实现。你将学习如何找到性能瓶颈，以及如何在大数据量的程序中显著加快代码。
如何利用多核架构或集群的优点？如何构建一个在不损失可靠性的情况下具备可伸缩性的系统？有经验的Python程序员将学到针对这些问题或者其他问题的具体解决方案，以及来自那些在社交媒体分析、产品化机器学习和其他场景下使用高性能Python编程的公司的成功案例。
通过阅读本书，你将能够：
■ 更好地掌握numpy、Cython和剖析器；
■ 了解Python如何抽象化底层的计算机架构；
■ 使用剖析手段来寻找CPU时间和内存使用的瓶颈；
■ 通过选择合适的数据结构来编写高效的程序
■ 加速矩阵和矢量计算；
■ 使用工具把Python编译成机器代码；
■ 管理并发的多I O和计算操作；
■ 把多进程代码转换到在本地或者远程集群上运行；
■ 用更少的内存解决大型问题。
“ 尽管P y thon在学术和工业领域很流行， 但人们也经常由于Python程序运行太慢而放弃它。本书通过全面介绍改善优化Python计算速度和可扩展性的策略，从而消除人们的这种误
解。”——Jake VanderPlas 华盛顿大学 </p>]<p><h2>作者简介</h2></p>[<p>Micha Gorelick在bitly公司从事与数据打交道的工作，并负责建立了快速前进实验室（Fast Forward Labs），研究从机器学习到高性能流算法领域的问题。
Ian Ozsvald是ModelInsight.io的数据科学家和教师，有着超过十年的Python经验。他在yCon和PyData会议上教授Python编程，这几年一直在英国从事关于数据科学和高性能计算方面的咨询工作。</p>]<p><h2>目录</h2></p>
    目录

第1章　理解高性能Python　1
1.1　基本的计算机系统　1
1.1.1　计算单元　2
1.1.2　存储单元　5
1.1.3　通信层　6
1.2　将基本的元素组装到一起　8
1.3　为什么使用Python　12
第2章　通过性能分析找到瓶颈　15
2.1　高效地分析性能　16
2.2　Julia集合的介绍　17
2.3　计算完整的Julia集合　20
2.4　计时的简单方法——打印和修饰　24
2.5　用UNIX的time命令进行简单的计时　27
2.6　使用cProfile模块　28
2.7　用runsnakerun对cProfile的输出进行可视化　33
2.8　用line_profiler进行逐行分析　34
2.9　用memory_profiler诊断内存的用量　39
2.10　用heapy调查堆上的对象　45
2.11　用dowser实时画出变量的实例　47
2.12　用dis模块检查CPython字节码　49
2.13　在优化期间进行单元测试保持代码的正确性　53
2.14　确保性能分析成功的策略　56
2.15　小结　57
第3章　列表和元组　58
3.1　一个更有效的搜索　61
3.2　列表和元组　63
3.2.1　动态数组：列表　64
3.2.2　静态数组：元组　67
3.3　小结　68
第4章　字典和集合　69
4.1　字典和集合如何工作　72
4.1.1　插入和获取　73
4.1.2　删除　76
4.1.3　改变大小　76
4.1.4　散列函数和熵　76
4.2　字典和命名空间　80
4.3　小结　83
第5章　迭代器和生成器　84
5.1　无穷数列的迭代器　87
5.2　生成器的延迟估值　89
5.3　小结　93
第6章　矩阵和矢量计算　94
6.1　问题介绍　95
6.2　Python列表还不够吗　99
6.3　内存碎片　103
6.3.1　理解perf　105
6.3.2　根据perf输出做出抉择　106
6.3.3　使用numpy　107
6.4　用numpy解决扩散问题　110
6.4.1　内存分配和就地操作　113
6.4.2　选择优化点：找到需要被修正的地方　116
6.5　numexpr：让就地操作更快更简单　120
6.6　告诫故事：验证你的“优化”（scipy）　121
6.7　小结　123
第7章　编译成C　126
7.1　可能获得哪种类型的速度提升　127
7.2　JIT和AOT编译器的对比　129
7.3　为什么类型检查有助代码更快运行　129
7.4　使用C编译器　130
7.5　复习Julia集的例子　131
7.6　Cython　131
7.6.1　使用Cython编译纯Python版本　132
7.6.2　Cython注解来分析代码块　134
7.6.3　增加一些类型注解　136
7.7　Shed Skin　140
7.7.1　构建扩展模块　141
7.7.2　内存拷贝的开销　144
7.8　Cython和numpy　144
7.9　Numba　148
7.10　Pythran　149
7.11　PyPy　151
7.11.1　垃圾收集的差异　152
7.11.2　运行PyPy并安装模块　152
7.12　什么时候使用每种工具　154
7.12.1　其他即将出现的项目　155
7.12.2　一个图像处理单元（GPU）的注意点　156
7.12.3　一个对未来编译器项目的展望　157
7.13　外部函数接口　157
7.13.1　ctypes　158
7.13.2　cffi　160
7.13.3　f2py　163
7.13.4　CPython模块　166
7.14　小结　170
第8章　并发　171
8.1　异步编程介绍　172
8.2　串行爬虫　175
8.3　gevent　177
8.4　tornado　182
8.5　AsyncIO　185
8.6　数据库的例子　188
8.7　小结　191
第9章　multiprocessing模块　193
9.1　multiprocessing模块综述　196
9.2　使用蒙特卡罗方法来估算Pi　198
9.3　使用多进程和多线程来估算Pi　199
9.3.1　使用Python对象　200
9.3.2　并行系统中的随机数　207
9.3.3　使用numpy　207
9.4　寻找素数　210
9.5　使用进程间通信来验证素数　221
9.5.1　串行解决方案　225
9.5.2　Na ve Pool解决方案　225
9.5.3　Less Na ve Pool解决方案　226
9.5.4　使用Manager.Value作为一个标记　227
9.5.5　使用Redis作为一个标记　229
9.5.6　使用RawValue作为一个标记　232
9.5.7　使用mmap作为一个标记　232
9.5.8　使用mmap作为一个标记的终极效果　234
9.6　用multiprocessing来共享numpy数据　236
9.7　同步文件和变量访问　243
9.7.1　文件锁　243
9.7.2　给Value加锁　247
9.8　小结　249
第10章　集群和工作队列　251
10.1　集群的益处　252
10.2　集群的缺陷　253
10.2.1　糟糕的集群升级策略造成华尔街损失4.62亿美元　254
10.2.2　Skype的24小时全球中断　255
10.3　通用的集群设计　255
10.4　怎样启动一个集群化的解决方案　256
10.5　使用集群时避免痛苦的方法　257
10.6　三个集群化解决方案　258
10.6.1　为简单的本地集群使用Parallel Python模块　259
10.6.2　使用IPython Parallel来支持研究　260
10.7　为鲁棒生产集群的NSQ　265
10.7.1　队列　265
10.7.2　发布者 订阅者　266
10.7.3　分布式素数计算器　268
10.8　看一下其他的集群化工具　271
10.9　小结　272
第11章　使用更少的RAM　273
11.1　基础类型的对象开销高　274
11.2　理解集合中的RAM使用　278
11.3　字节和Unicode的对比　280
11.4　高效地在RAM中存储许多文本　281
11.5　使用更少RAM的窍门　290
11.6　概率数据结构　291
11.6.1　使用1字节的Morris计数器来做近似计数　292
11.6.2　K*小值　295
11.6.3　布隆过滤器　298
11.6.4　LogLog计数器　303
11.6.5　真实世界的例子　307
第12章　现场教训　311
12.1　自适应实验室（Adaptive Lab）的社交媒体分析（SoMA）　311
12.1.1　自适应实验室（Adaptive Lab）使用的Python　312
12.1.2　SoMA的设计　312
12.1.3　我们的开发方法论　313
12.1.4　维护SoMA　313
12.1.5　对工程师同行的建议　313
12.2　使用RadimRehurek.com让深度学习飞翔　314
12.2.1　*佳时机　314
12.2.2　优化方面的教训　316
12.2.3　总结　318
12.3　在Lyst.com的大规模产品化的机器学习　318
12.3.1　Python在Lyst的地位　319
12.3.2　集群设计　319
12.3.3　在快速前进的初创公司中做代码评估　319
12.3.4　构建推荐引擎　319
12.3.5　报告和监控　320
12.3.6　一些建议　320
12.4　在Smesh的大规模社交媒体分析　321
12.4.1　Python在Smesh中的角色　321
12.4.2　平台　321
12.4.3　高性能的实时字符串匹配　322
12.4.4　报告、监控、调试和部署　323
12.5　PyPy促成了成功的Web和数据处理系统　324
12.5.1　先决条件　325
12.5.2　数据库　325
12.5.3　Web应用　326
12.5.4　OCR和翻译　326
12.5.5　任务分发和工作者　327
12.5.6　结论　327
12.6　在Lanyrd.com中的任务队列　327
12.6.1　Python在Lanyrd中的角色　328
12.6.2　使任务队列变高性能　328
12.6.3　报告、监控、调试和部署　328
12.6.4　对开发者同行的建议　329

