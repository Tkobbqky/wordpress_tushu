Web2.0高级编程 PDF下载 Eric 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711516891
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711516891
<p>书名:Web2.0高级编程</p><p>作者:Eric</p><p>页数:465</p><p>定价:¥69.0</p><p>出版社:人民邮电出版社</p><p>出版日期:2008-01-01</p><p>ISBN:9787115168917</p><p><h2>内容简介</h2></p>[<p>Web 2.0旨在让Web重归发明它的初衷，即让用户创建内容。从技术角度说，Web 2.0就是以全新的方式使用大量已有的技术，这意味着专业开发人员必须了解众多Web 2.0技术，如HTML、CSS、HTTP、JavaScript、XML、服务器端编程等。市面上的大部分图书都过于专业化，对于Web 2.0应用使用的每项技术，都可找到大量介绍它们的优秀图书，但从专业角度阐述如何综合使用这些技术的图书凤毛麟角。本书旨在填补这一空白，让读者对Web 2.0技术及其如何协同工作有初步认识，从而真正理解Web 2.0应用的工作原理以及如何开发它们。 <br/>本书首先通过一个Web 2.0应用演示了服务器和浏览器之间的交互过程，让读者对本书中介绍的技术在Web 2.0应用中扮演的角色有更深入的认识；然后介绍了客户端技术，包括(X)HTML与CSS、JavaScript与Ajax、客户端设计准则、有望成为主流的客户端技术以及胖客户端替代品；接下来讨论了用于在客户端和服务器之间通信的协议和格式，包括HTTP与URI、XML及其替代品、联合、微格式和Web服务；*后，讨论了服务器端编程技术，包括通过HTTP提供XML、如何使用非XML数据源、如何创建联合频道、创建mashup、如何实现和维护URI空间、提供多媒体内容以及安全。 <br/>本书适合参与开发Web 2.0项目的专业开发人员阅读，也可供对Web 2.0开发感兴趣的人员参考。 <br/></p>]<p><h2>目录</h2></p>
    第1章　Web 2.0简介　1 1.1　BuzzWatch简介　1 1.2　概况　3 1.3　探究后台实现　5 1.4　让BuzzWatch成为更好的Web公民　25 1.5　让BuzzWatch更易于维护　29 1.6　完成*后一步　34 1.7　总结　36 第2章　页面表示　37 2.1　创建简洁的页面　37 2.1.1　生成有效的HTML　38 2.1.2　使用级联样式表　40 2.1.3　选择合适的元素　40 2.2　从HTML到XHTML　42 2.2.1　XHTML 1.0　42 2.2.2　XHTML 1.1　43 2.2.3　为何使用XHTML　43 2.2.4　与HTML的差别　44 2.3　文档对象模型　46 2.3.1　DOM级别　48 2.3.2　DOM API概述　48 2.3.3　DOM API参考　50 2.4　级联样式表　50 2.4.1　圆角　51 2.4.2　选项卡　53 2.5　工具　54 2.5.1　Firfox的DOM查看器　55 2.5.2　Firefox的Web开发工具栏　56 2.5.3　Internet Explorer开发工具栏　57 2.5.4　用于Firefox的DevBoi　58 2.6　总结　59 第3章　JavaScript和Ajax　60 3.1　JavaScript：了解鲜为人知但至关重要的特性　60 3.1.1　undefined的值和类型　60 3.1.2　===运算符　62 3.1.3　使用for-in进行迭代　63 3.1.4　函数式编程　65 3.1.5　函数参数　66 3.2　JavaScript优化　67 3.2.1　缩短JavaScript的下载时间　68 3.2.2　*大限度地减少DOM更新　68 3.3　Ajax　69 3.3.1　一切为了用户体验　69 3.3.2　XMLHttpRequest的历史　70 3.3.3　XMLHttpRequest示例　70 3.3.4　Yahoo! UI Library　73 3.3.5　Google Web Toolkit　76 3.3.6　处理内存泄露　77 3.4　总结　79 第4章　设计准则　80 4.1　常见的设计问题　81 4.1.1　书签　81 4.1.2　导航　85 4.1.3　*大限度地减少传输量　86 4.1.4　支持低级设备　89 4.1.5　易用性需求及指导原则　91 4.2　总结　105 第5章　Web 2.0的发展趋势　106 5.1　XSLT和XPath　106 5.1.1　XSLT Hello world示例　107 5.1.2　更多XSLT示例　109 5.1.3　XSLT样式　112 5.1.4　更多XSLT示例　113 5.1.5　在浏览器中使用XSLT　117 5.2　SVG　119 5.2.1　SVG Hello world示例　120 5.2.2　在SVG中指定样式　124 5.2.3　更多有关SVG的知识　126 5.3　XForms　136 5.3.1　XForms Hello World示例　137 5.3.2　给XForms指定样式　141 5.3.3　更多XForms示例　145 5.4　HTML的发展趋势　156 5.4.1　W3C的提案　157 5.4.2　WHATWG的提案　158 5.4.3　比较XHTML 2.0和HTML 5　159 5.5　总结　159 第6章　胖客户端　161 6.1　从浏览器到胖客户端　161 6.1.1　浏览器的缺点　162 6.1.2　一种解决方案——胖客户端　162 6.1.3　当前的胖客户端　163 6.2　比较胖客户端框架　163 6.2.1　OpenLaszlo　163 6.2.2　XUL　172 6.2.3　XAML　179 6.3　总结　183 第7章　HTTP和URI　184 7.1　Web是如何获得成功的　184 7.2　Web 1.0：HTML、URL和HTTP　185 7.2.1　表象之下　185 7.2.2　URL和URI　187 7.2.3　隐藏代码的危险　189 7.2.4　Web服务器究竟做什么　189 7.2.5　Web是双向的　190 7.3　Web模型和REST　190 7.3.1　资源　191 7.3.2　表示　191 7.3.3　状态　191 7.3.4　使用HTTP方法进行传输　193 7.4　创建HTTP服务时需要考虑的因素　193 7.4.1　媒体类型　194 7.4.2　感兴趣的资源　194 7.4.3　所需的表示　195 7.4.4　服务器响应　196 7.5　电缆上发生的情况　196 7.5.1　参考工具包　197 7.5.2　HTTP示例　197 7.6　其他表示　200 7.6.1　内容协商　202 7.6.2　使用HTTPTracer查看消息　204 7.7　总结　207 第8章　XML及其替换品　208 8.1　XML　208 8.1.1　XML基础知识　208 8.1.2　XML命名空间　212 8.1.3　Unicode和字符编码　214 8.1.4　处理二进制数据　216 8.1.5　通常不需要的特性　216 8.1.6　数据类型　217 8.1.7　模式语言　218 8.1.8　XSLT和XPath　220 8.1.9　其他XML技术　220 8.1.10　现有的数据格式和协议　221 8.1.11　API　221 8.2　XML的替换品　222 8.2.1　JSON　222 8.2.2　JavaScript　224 8.2.3　HTML　224 8.2.4　其他格式　227 8.3　总结　227 第9章　联合　228 9.1　有关联合的基础知识　228 9.1.1　微格式　228 9.1.2　提要　229 9.2　联合过程　230 9.3　联合格式　231 9.3.1　RSS 2.0：简单内容　231 9.3.2　RSS 1.0：资源描述　236 9.3.3　RSS 1.0规范和模块　240 9.3.4　Atom：在两方面都*好　241 9.3.5　Atom规范和扩展　245 9.3.6　比较不同格式的元素　245 9.3.7　enclosure和播客　246 9.4　总结　247 第10章　微格式　248 10.1　微格式基础　249 10.1.1　CSS和微格式　249 10.1.2　Semantic HTML　251 10.1.3　内容、表示和数据　252 10.1.4　消除模糊性　252 10.1.5　覆盖范围　253 10.1.6　2.0标准组织　256 10.2　创建微格式文档　257 10.3　总结　267 第11章　结合使用多种协议创建Web服务　268 11.1　澄清Web服务　268 11.2　REST服务　269 11.2.1　一个应用程序示例　269 11.2.2　Atom发布协议　272 11.2.3　当前的REST服务　273 11.2.4　更多有关REST的资源　275 11.3　WS-*服务　275 11.3.1　WS-*服务和SOAP　275 11.3.2　WS-*服务和WSDL　279 11.3.3　WS-*栈　282 11.4　REST Vs. WS-*　283 11.4.1　SOAP　283 11.4.2　WSDL　284 11.4.3　工具支持　286 11.5　总结　287 第12章　通过HTTP提供XML　288 12.1　与提供HTML有何不同　288 12.1.1　媒体类型　288 12.1.2　字符编码　288 12.1.3　提供定义良好的XML　289 12.2　提供静态内容　289 12.3　提供动态内容　290 12.3.1　原则　291 12.3.2　使用Java提供XML　291 12.3.3　使用ASP.NET和C#提供XML　296 12.3.4　使用Ruby on Rails提供XML　299 12.3.5　使用PHP、Perl、Python等提供XML　301 12.3.6　使用服务器端XSLT　301 12.3.7　使用XML平台　303 12.4　XQuery和XML数据库　307 12.4.1　使用eXist提供XML　307 12.4.2　WebDAV和Subversion　309 12.5　提供JSON　310 12.6　总结　310 第13章　数据库和非XML数据源　311 13.1　处理非XML数据源　311 13.2　将关系数据转换为XML　312 13.2.1　使用SQL Server进行服务器端转换　316 13.2.2　使用ADO.NET进行客户端转换　322 13.2.3　使用Oracle XSQL　326 13.3　将二进制数据转换为XML　336 13.3.1　手工转换　337 13.3.2　自动转换　340 13.4　总结　348 第14章　创建联合频道　349 14.1　简单的Atom服务　349 14.1.1　用户界面　349 14.1.2　应用程序的架构　351 14.1.3　Abdera Atom工具包　351 14.1.4　代码概览　352 14.2　运行应用程序　367 14.2.1　编译和部署应用程序　367 14.2.2　部署方面的考虑因素　368 14.3　添加电子邮件支持　368 14.3.1　理解邮件支持架构　369 14.3.2　建立本地邮件服务器　370 14.3.3　使用MailClient类　371 14.3.4　MessageReader接口　375 14.3.5　MailEntryCollector　375 14.4　总结　379 第15章　Mashup、HTML抓取和Web服务　380 15.1　流行的示例：地图mashup　381 15.2　为什么使用mashup　383 15.3　mashup的商业模式　384 15.4　屏幕抓取　385 15.4.1　优点和缺点　385 15.4.2　公平竞争　386 15.4.3　下载页面　386 15.4.4　分析页面　387 15.4.5　简单的屏幕抓取示例　388 15.5　创建提要　389 15.5.1　在服务器上部署　392 15.5.2　通过外部服务部署　392 15.6　地图服务和Badge　393 15.6.1　badge　394 15.6.2　Google Maps　395 15.7　总结　397 第16章　实现和维护URI空间　399 16.1　确保URI经受住时间的考验　400 16.1.1　独立于技术　400 16.1.2　层次结构和集合　400 16.1.3　末尾的斜杠和位置无关性　401 16.2　管理URI空间变更　402 16.2.1　HTTP重定向基础　402 16.2.2　永久性重定向资源　403 16.2.3　暂时重定向资源　404 16.2.4　不应使用的重定向方法　404 16.2.5　服务器端重定向　405 16.3　URI映射工具箱　405 16.3.1　Java Servlet　405 16.3.2　Apache mod_alias和mod_rewrite　406 16.3.3　ASP.NET和IIS　409 16.4　总结　410 第17章　播客和提供多媒体　411 17.1　格式迷宫　411 17.1.1　描述格式　412 17.1.2　容器和编码格式　422 17.2　协议　429 17.2.1　组播　429 17.2.2　单播　430 17.2.3　选择协议　431 17.3　总结　431 第18章　安全　432 18.1　什么是安全　432 18.1.1　资源安全　432 18.1.2　消息安全　433 18.2　历史教训　433 18.3　分层方法　434 18.4　身份验证和授权　434 18.4.1　IIS和ASP.NET中的身份验证和授权　435 18.4.2　IIS和ASP.NET中各种身份验证方法　436 18.4.3　Apache中的身份验证和授权　438 18.5　消息加密　439 18.5.1　对称加密　439 18.5.2　公钥设施　440 18.6　消息摘要　441 18.7　数字证书　441 18.8　安全套接字层　441 18.8.1　SSL通信的步骤　442 18.8.2　在IIS中配置SSL　442 18.8.3　在Apache中设置SSL　446 18.9　代码安全　449 18.10　Web服务安全　453 18.10.1　使用Web服务安全　453 18.10.2　该Web服务的工作原理　455 18.10.3　添加策略　456 18.10.4　添加自定义身份验证　457 18.10.5　创建客户端　460 18.10.6　改善安全性　464 18.11　总结　464
