Java核心技术系列JAVA多线程编程核心技术(第2版) PDF下载 高洪岩 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711161490
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711161490
<p>书名:Java核心技术系列JAVA多线程编程核心技术(第2版)</p><p>作者:高洪岩</p><p>页数:442</p><p>定价:¥99.0</p><p>出版社:机械工业出版社</p><p>出版日期:2019-05-01</p><p>ISBN:9787111614906</p><p><h2>本书特色</h2></p>[<p>
全书共7章。第1章讲解了Java多线程的基础，重点介绍线程类的核心API的使用。第2章讲解对并发访问的控制，即如何写出线程安全的程序。第3章介绍线程间通信，以提高CPU利用率和系统间的交互，同时增强对线程任务的把控与监督。第4章讲解Lock对象，以更好实现并发访问时的同步处理。第5章讲解移动开发中使用较多的定时器类中的多线程技术，这是计划/任务执行里很重要的技术点。第6章讲解如何安全、正确地将单例模式与多线程技术相结合，避免实际应用中可能会出现的麻烦。第7章将前面被遗漏的技术案例在本章节中进行补充，尽量做到不出现技术空白点。<br/>
</p>]<p><h2>内容简介</h2></p>[<p>全书共7章。章讲解了Java多线程的基础，重点介绍线程类的核心API的使用。第2章讲解对并发访问的控制，即如何写出线程安全的程序。第3章介绍线程间通信，以提高CPU利用率和系统间的交互，同时增强对线程任务的把控与监督。第4章讲解Lock对象，以更好实现并发访问时的同步处理。第5章讲解移动开发中使用较多的定时器类中的多线程技术，这是计划/任务执行里很重要的技术点。第6章讲解如何安全、正确地将单例模式与多线程技术相结合，避免实际应用中可能会出现的麻烦。第7章将前面被遗漏的技术案例在本章节中进行补充，尽量做到不出现技术空白点。</p>]<p><h2>作者简介</h2></p>[<p>高洪岩，某世界500强项目经理，有10年Java相关开发经验，精通Java语言，擅长J2EE、EJB、Android、报表和多线程，以及并发相关的技术内容，理论与实践经验颇丰。著有《Java多线程编程核心技术》《Java并发编程：核心方法与框架》《NIO与Socket编程技术指南》《Java EE核心框架实战 第2版》《Jasper Reports iReport报表开发详解》《Android学习精要》等书籍。</p>]<p><h2>目录</h2></p>
    前言第1章　Java多线程技能11.1　进程和多线程概述11.2　使用多线程51.2.1　继承Thread类51.2.2　使用常见命令分析线程的信息81.2.3　线程随机性的展现111.2.4　执行start()的顺序不代表执行run()的顺序121.2.5　实现Runnable接口131.2.6　使用Runnable接口实现多线程的优点141.2.7　实现Runnable接口与继承Thread类的内部流程161.2.8　实例变量共享造成的非线程安全问题与解决方案171.2.9　Servlet技术造成的非线程安全问题与解决方案211.2.10　留意i--与System.out.println()出现的非线程安全问题241.3　currentThread()方法261.4　isAlive()方法291.5　sleep(long millis)方法311.6　sleep(long millis, int nanos)方法331.7　StackTraceElement[] getStackTrace()方法331.8　static void dumpStack()方法351.9　static Map getAllStackTraces()方法361.10　getId()方法381.11　停止线程381.11.1　停止不了的线程391.11.2　判断线程是否为停止状态411.11.3　能停止的线程—异常法431.11.4　在sleep状态下停止线程471.11.5　用stop()方法暴力停止线程491.11.6　stop()方法与java.lang.ThreadDeath异常511.11.7　使用stop()释放锁给数据造成不一致的结果521.11.8　使用“return;”语句停止线程的缺点与解决方案541.12　暂停线程571.12.1　suspend()方法与resume()方法的使用571.12.2　suspend()方法与resume()方法的缺点—独占581.12.3　suspend()方法与resume()方法的缺点—数据不完整621.13　yield()方法631.14　线程的优先级641.14.1　线程优先级的继承特性651.14.2　优先级的规律性661.14.3　优先级的随机性681.14.4　优先级对线程运行速度的影响701.15　守护线程711.16　本章小结73第2章　对象及变量的并发访问742.1　synchronized同步方法742.1.1　方法内的变量为线程安全742.1.2　实例变量非线程安全问题与解决方案772.1.3　同步synchronized在字节码指令中的原理802.1.4　多个对象多个锁812.1.5　将synchronized方法与对象作为锁842.1.6　脏读892.1.7　synchronized锁重入912.1.8　锁重入支持继承的环境932.1.9　出现异常，锁自动释放942.1.10　重写方法不使用synchronized962.1.11　public static boolean holdsLock(Object obj)方法的使用992.2　synchronized同步语句块992.2.1　synchronized方法的弊端992.2.2　synchronized同步代码块的使用1022.2.3　用同步代码块解决同步方法的弊端1042.2.4　一半异步，一半同步1052.2.5　synchronized代码块间的同步性1082.2.6　println()方法也是同步的1102.2.7　验证同步synchronized(this)代码块是锁定当前对象的1102.2.8　将任意对象作为锁1132.2.9　多个锁就是异步执行1162.2.10　验证方法被调用是随机的1182.2.11　不同步导致的逻辑错误及其解决方法1212.2.12　细化验证3个结论1242.2.13　类Class的单例性1292.2.14　静态同步synchronized方法与synchronized(class)代码块1302.2.15　同步syn static方法可以对类的所有对象实例起作用1352.2.16　同步syn(class)代码块可以对类的所有对象实例起作用1372.2.17　String常量池特性与同步相关的问题与解决方案1382.2.18　同步synchronized方法无限等待问题与解决方案1412.2.19　多线程的死锁1432.2.20　内置类与静态内置类1462.2.21　内置类与同步：实验11492.2.22　内置类与同步：实验21512.2.23　锁对象改变导致异步执行1532.2.24　锁对象不改变依然同步执行1562.2.25　同步写法案例比较1582.3　volatile关键字1592.3.1　可见性的测试1592.3.2　原子性的测试1682.3.3　禁止代码重排序的测试1762.4　本章小结187第3章　线程间通信1883.1　wait/notify机制1883.1.1　不使用wait/notify机制实现线程间通信1883.1.2　wait/notify机制1913.1.3　wait/notify机制的原理1923.1.4　wait()方法的基本使用1923.1.5　完整实现wait/notify机制1943.1.6　使用wait/notify机制实现list.size()等于5时的线程销毁1953.1.7　对业务代码进行封装1983.1.8　线程状态的切换2013.1.9　wait()方法：立即释放锁2023.1.10　sleep()方法：不释放锁2033.1.11　notify()方法：不立即释放锁2043.1.12　interrupt()方法遇到wait()方法2063.1.13　notify()方法：只通知一个线程2083.1.14　notifyAll()方法：通知所有线程2113.1.15　wait(long)方法的基本使用2123.1.16　wait(long)方法自动向下运行需要重新持有锁2143.1.17　通知过早问题与解决方法2173.1.18　wait条件发生变化与使用while的必要性2203.1.19　生产者/消费者模式的实现2243.1.20　通过管道进行线程间通信—字节流2503.1.21　通过管道进行线程间通信—字符流2533.1.22　实现wait/notify的交叉备份2563.2　join()方法的使用2593.2.1　学习join()方法前的铺垫2593.2.2　join()方法和interrupt()方法出现异常2613.2.3　join(long)方法的使用2633.2.4　join(long)方法与sleep(long)方法的区别2643.2.5　join()方法后面的代码提前运行—出现意外 2683.2.6　join()方法后面的代码提前运行—解释意外2703.2.7　join(long millis, int nanos)方法的使用2733.3　类ThreadLocal的使用2733.3.1　get()方法与null2743.3.2　类ThreadLocal存取数据流程分析2753.3.3　验证线程变量的隔离性2773.3.4　解决get()方法返回null的问题2823.3.5　验证重写initialValue()方法的隔离性2833.4　类InheritableThreadLocal的使用2843.4.1　类ThreadLocal不能实现值继承2853.4.2　使用InheritableThreadLocal体现值继承特性2863.4.3　值继承特性在源代码中的执行流程2883.4.4　父线程有*新的值，子线程仍是旧值2913.4.5　子线程有*新的值，父线程仍是旧值2933.4.6　子线程可以感应对象属性值的变化2943.4.7　重写childValue()方法实现对继承的值进行加工2973.5　本章小结298第4章　Lock对象的使用2994.1　使用ReentrantLock类2994.1.1　使用ReentrantLock实现同步2994.1.2　验证多代码块间的同步性3014.1.3　await()方法的错误用法与更正3044.1.4　使用await()和signal()实现wait/notify机制3074.1.5　await()方法暂停线程运行的原理3094.1.6　通知部分线程—错误用法3124.1.7　通知部分线程—正确用法3144.1.8　实现生产者/消费者模式一对一交替输出3174.1.9　实现生产者/消费者模式多对多交替输出3194.1.10　公平锁与非公平锁3214.1.11　public int getHoldCount()方法的使用3244.1.12　public final int getQueue Length()方法的使用3254.1.13　public int getWaitQueue-Length (Condition condition)方法的使用3274.1.14　public final boolean has-QueuedThread (Thread thread)方法的使用3284.1.15　public final boolean has-QueuedThreads()方法的使用3294.1.16　public boolean hasWaiters (Con-dition condition)方法的使用3314.1.17　public final boolean isFair()方法的使用3324.1.18　public boolean isHeldBy-CurrentThread()方法的使用3334.1.19　public boolean isLocked()方法的使用3344.1.20　public void lockInterruptibly()方法的使用3354.1.21　public boolean tryLock()方法的使用3364.1.22　public boolean tryLock (long timeout, TimeUnit unit)方法的使用3384.1.23　public boolean await (long time, TimeUnit unit)方法的使用3394.1.24　public long awaitNanos(long nanosTimeout)方法的使用3414.1.25　public boolean awaitUntil(Date deadline)方法的使用3424.1.26　public void awaitUninterru-ptibly()方法的使用3444.1.27　实现线程按顺序执行业务3464.2　使用ReentrantReadWriteLock类3494.2.1　ReentrantLock类的缺点3494.2.2　ReentrantReadWriteLock类的使用—读读共享3514.2.3　ReentrantReadWriteLock类的使用—写写互斥3524.2.4　ReentrantReadWriteLock类的使用—读写互斥3524.2.5　ReentrantReadWriteLock类的使用—写读互斥3544.3　本章小结355第5章　定时器Timer3565.1　定时器Timer的使用3565.1.1　schedule(TimerTask task, Datetime)方法的测试3565.1.2　schedule(TimerTask task, Date firstTime, long period)方法的测试3665.1.3　schedule(TimerTask task, long delay)方法的测试3745.1.4　schedule(TimerTask task, long delay, long period)方法的测试3745.1.5　scheduleAtFixedRate (TimerTask task, Date firstTime, long period)方法的测试3755.2　本章小结384第6章　单例模式与多线程3856.1　立即加载/饿汉模式3856.2　延迟加载/懒汉模式3876.2.1　延迟加载/懒汉模式解析3876.2.2　延迟加载/懒汉模式的缺点3886.2.3　延迟加载/懒汉模式的解决方案3906.3　使用静态内置类实现单例模式3996.4　序列化与反序列化的单例模式实现4006.5　使用static代码块实现单例模式4026.6　使用enum枚举数据类型实现单例模式4046.7　完善使用enum枚举数据类型实现单例模式4056.8　本章小结407第7章　拾遗增补4087.1　线程的状态4087.1.1　验证NEW、RUNNABLE和TERMINATED4107.1.2　验证TIMED_WAITING4117.1.3　验证BLOCKED4127.1.4　验证WAITING4147.2　线程组4157.2.1　线程对象关联线程组：一级关联4167.2.2　线程对象关联线程组：多级关联4177.2.3　线程组自动归属特性4187.2.4　获取根线程组4197.2.5　线程组中加线程组4207.2.6　组内的线程批量停止4217.2.7　递归取得与非递归取得组内对象4227.3　Thread.activeCount()方法的使用4237.4　Thread.enumerate(Thread tarray[])方法的使用4237.5　再次实现线程执行有序性4247.6　SimpleDateFormat非线程安全4267.6.1　出现异常4267.6.2　解决异常的方法14287.6.3　解决异常的方法24307.7　线程中出现异常的处理4317.
