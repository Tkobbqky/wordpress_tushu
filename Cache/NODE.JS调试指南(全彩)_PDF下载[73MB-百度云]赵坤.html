NODE.JS调试指南(全彩) PDF下载 赵坤 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712134146
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#712134146
<p>书名:NODE.JS调试指南(全彩)</p><p>作者:赵坤</p><p>页数:248</p><p>定价:¥89.0</p><p>出版社:电子工业出版社</p><p>出版日期:2017-07-01</p><p>ISBN:9787121341465</p><p><h2>本书特色</h2></p>[<p>
《Node.js调试指南（全彩）》从CPU、内存、代码、工具、APM、日志、监控、应用这8 个方面讲解如何调试 Node.js，大部分小节都会以一段经典的问题代码为例进行分析并给出解决方案。其中，第1 章讲解CPU 相关的知识，涉及各种CPU 性能分析工具及火焰图的使用；第2 章讲解内存相关的知识，例如Core Dump 及如何分析 heapsnapshot 文件；第3 章讲解代码相关的知识，例如如何从代码层面避免写出难以调试的代码，并涉及部分性能调优知识；第4 章讲解工具相关的知识，涉及常用的Node.js 调试工具和模块；第5 章讲解APM（Application Performance Management）相关的知识，例如两个不同的应用程序性能管理工具的使用；第6 章讲解日志相关的知识，例如如何使用Node.js 的async_hooks 模块实现自动日志打点，并结合各种工具进行使用；第7 章讲解监控相关的知识，例如如何使用Telegraf   InfluxDB   Grafana 搭建一个完整的Node.js 监控系统；第8 章讲解应用相关的知识，给出了两个完整的Node.js 应用程序的性能解决方案。《Node.js调试指南（全彩）》并不适合Node.js 初学者，适合有一定Node.js 开发经验的人阅读。笔者倾向于将本书定位成参考书，每一小节基本独立，如果遇到相关问题，则可以随时翻到相应的章节进行阅读。
                                        </p>]<p><h2>内容简介</h2></p>[<p>《Node.js调试指南（全彩）》从CPU、内存、代码、工具、APM、日志、监控、应用这8 个方面讲解如何调试 Node.js，大部分小节都会以一段经典的问题代码为例进行分析并给出解决方案。其中，靠前 章讲解CPU 相关的知识，涉及各种CPU 性能分析工具及火焰图的使用；第2 章讲解内存相关的知识，例如Core Dump 及如何分析 heapsnapshot 文件；第3 章讲解代码相关的知识，例如如何从代码层面避免写出难以调试的代码，并涉及部分性能调优知识；第4 章讲解工具相关的知识，涉及常用的Node.js 调试工具和模块；第5 章讲解APM（Application Performance Management）相关的知识，例如两个不同的应用程序性能管理工具的使用；第6 章讲解日志相关的知识，例如如何使用Node.js 的async_hooks 模块实现自动日志打点，并结合各种工具进行使用；第7 章讲解监控相关的知识，例如如何使用Telegraf + InfluxDB + Grafana 搭建一个完整的Node.js 监控系统；第8 章讲解应用相关的知识，给出了两个完整的Node.js 应用程序的性能解决方案。《Node.js调试指南（全彩）》并不适合Node.js 初学者，适合有一定Node.js 开发经验的人阅读。笔者倾向于将本书定位成参考书，每一小节基本独立，如果遇到相关问题，则可以随时翻到相应的章节进行阅读。</p>]<p><h2>作者简介</h2></p>[<p>《Node.js实战（双色）》《Node.js实战（第2季）》主编及作者，iweb学院Node.js讲师，有丰富的Node.js开发及调优经验，现就职于某大型平台任后端开发师。Node.js贡献值之一。</p>]<p><h2>目录</h2></p>
    第1 章 CPU 11.1 理解perf 与火焰图（FlameGraph） 21.1.1 perf 21.1.2 火焰图 61.1.3 红蓝差分火焰图 81.2 使用 v8-profiler 分析 CPU 的使用情况 111.3 Tick Processor 及Web UI 161.3.1 Tick Processor 161.3.2 Web UI 21第2 章 内存 232.1 gcore 与llnode 242.1.1 Core 和 Core Dump 242.1.2 gcore 252.1.3 llnode 252.1.4 测试 Core Dump 262.1.5 分析Core 文件 272.1.6 --abort-on-uncaught-exception 292.1.7 小结 302.2 heapdump 302.2.1 使用heapdump 302.2.2 Chrome DevTools 322.2.3 对比快照 342.3 memwatch-next 352.3.1 使用memwatch-next 352.3.2 使用Heap Diff 382.3.3 结合 heapdump 使用 402.4 cpu-memory-monitor 412.4.1 使用cpu-memory-monitor 412.4.2 cpu-memory-monitor 源码解读 43第3 章 代码 463.1 Promise 473.1.1 Promise/A  规范 483.1.2 从零开始实现 Promise 483.1.3 Promise 的实现原理 503.1.4 safelyResolveThen 523.1.5 doResolve 和 doReject 543.1.6 Promise.prototype.then 和 Promise.prototype.catch 553.1.7 值穿透 583.1.8 Promise.resolve 和 Promise.reject 603.1.9 Promise.all 613.1.10 Promise.race 623.1.11 代码解析 633.2 Async   Await 693.2.1 例1 ：async   await 703.2.2 例2 ：co   yield 713.2.3 例3 ：co   yield* 723.2.4 例4 ：co   bluebird 733.2.5 从yield 转为yield* 遇到的坑 753.2.6 async   bluebird 763.3 Error Stack 773.3.1 Stack Trace 783.3.2 Error.captureStackTrace 803.3.3 captureStackTrace 在 Mongolass 中的应用 833.3.4 Error.prepareStackTrace 843.3.5 Error.prepareStackTrace 的其他用法 863.3.6 Error.stackTraceLimit 883.3.7 Long Stack Trace 883.4 node@8 893.4.1 Ignition   Turbofan 903.4.2 版本的对应关系 913.4.3 try/catch 913.4.4 delete 933.4.5 arguments 953.4.6 async 性能提升 973.4.7 不会优化的特性 983.5 Rust Addons 1003.5.1 Rust 1003.5.2 FFI 1003.5.3 Neon 1033.5.4 NAPI 1083.6 Event Loop 1103.6.1 什么是 Event Loop 1103.6.2 poll 阶段 1123.6.3 process.nextTick() 1123.6.4 代码解析 1133.7 处理 uncaughtException 1203.7.1 uncaughtException 1203.7.2 使用 llnode 1213.7.3 ReDoS 122第4 章 工具 1254.1 Source Map 1264.1.1 uglify-es 1264.1.2 TypeScript 1284.1.3 source-map-support 的高级用法 1294.2 Chrome DevTools 1294.2.1 使用 Chrome DevTools 1304.2.2 NIM 1324.2.3 inspect-process 1334.2.4 process._debugProcess 1334.3 Visual Studio Code 1344.3.1 基本调试 1344.3.2 launch.json 1364.3.3 技巧 1——条件断点 1384.3.4 技巧 2——skipFiles 1394.3.5 技巧 3——自动重启 1404.3.6 技巧 4——对特定操作系统的设置 1424.3.7 技巧 5——多配置 1424.3.8 总结 1444.4 debug   repl2   power-assert 1444.4.1 debug 1444.4.2 repl2 1464.4.3 power-assert 1484.5 supervisor-hot-reload 1514.5.1 Proxy 1514.5.2 用Proxy 实现 Hot Reload 1534.5.3 supervisor-hot-reload 1554.5.4 内存泄漏问题 160第5 章 日志 1615.1 koa-await-breakpoint 1625.1.1 koa-await-breakpoint 的实现原理 1625.1.2 使用 koa-await-breakpoint 1655.1.3 自定义日志存储 1675.2 使用async_hooks 1685.3 ELK 1775.3.1 安装 ELK 1775.3.2 使用 ELK 1785.4 OpenTracing   Jaeger 1825.4.1 什么是 OpenTracing 1825.4.2 什么是 Jaeger 1845.4.3 启动 Jaeger 及Jaeger UI 1845.4.4 使用 OpenTracing 及Jaeger 1855.4.5 koa-await-breakpoint-jaeger 1875.5 使用Sentry 190第6 章 APM 1976.1 使用NewRelic 1986.2 Elastic APM 2016.2.1 什么是 Elastic APM 2016.2.2 启动 ELK 2036.2.3 启动 APM Server 2036.2.4 使用 Elastic APM 2036.2.5 错误日志 205第7 章 监控 2077.1 Telegraf   InfluxDB   Grafana（上） 2087.1.1 Telegraf（StatsD）   InfluxDB   Grafana 简介 2087.1.2 启动 docker-statsd-influxdb-grafana 2087.1.3 熟悉 InfluxDB 2097.1.4 配置 Grafana 2107.1.5 node-statsd 2117.1.6 创建 Grafana 图表 2137.1.7 模拟真实环境 2147.2 Telegraf   InfluxDB   Grafana（下） 2177.2.1 Grafana   ELK 2177.2.2 监控报警 2207.2.3 脚本一键生成图表 222第8 章 应用 2248.1 使用 node-clinic 2258.2 alinode 2278.2.1 什么是 alinode 2278.2.2 创建 alinode 应用 2288.2.3 安装 alinode 2288.2.4 使用 alinode 诊断内存泄露 2298.2.5 使用 alinode 诊断 CPU 性能瓶颈 232
