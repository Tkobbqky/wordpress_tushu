Unity 游戏优化(第2版) PDF下载 [英]克里斯·迪金森（ChrisDi 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730255051
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#730255051
<p>书名:Unity 游戏优化(第2版)</p><p>作者:[英] 克里斯·迪金森（Chris Di</p><p>页数:0</p><p>定价:¥98.0</p><p>出版社:清华大学出版社</p><p>出版日期:2020-05-01</p><p>ISBN:9787302550518</p><p><h2>本书特色</h2></p>[<p>
● 使用Unity Profiler查找程序中任何地方的瓶颈，并发现解决它们的方法。
● 实现C#脚本编写的更佳实践，避免常见误区。
● 深入理解渲染管线，通过减少绘制调用和避免填充率瓶颈来更大化渲染管线的性能。
● 以大多数开发者都能理解的方式增强着色器，通过微妙而有效的性能调整优化它们。
● 充分利用物理引擎使场景尽可能保持动态。
● 组织、过滤并压缩艺术资源，保持高品质的同时更大化性能。
● 发现VR项目中各种严重的性能问题，找到解决它们的方法。
● 使用Mono框架和C#实现底层强化以更大化内存使用，避免垃圾回收。
● 了解项目组织的*实践，通过改进工作流来节省时间。
                                        </p>]<p><h2>内容简介</h2></p>[<p>● 使用Unity？Profiler查找程序中任何地方的瓶颈，并发现解决它们的方法。
● 实现C#脚本编写的很好实践，避免常见误区。
● 深入理解渲染管线，通过减少绘制调用和避免填充率瓶颈来优选化渲染管线的性能。
● 以大多数开发者都能理解的方式增强着色器，通过微妙而有效的性能调整优化它们。
● 充分利用物理引擎使场景尽可能保持动态。
● 组织、过滤并压缩艺术资源，保持高品质的同时优选化性能。
● 发现VR项目中各种严重的性能问题，找到解决它们的方法。
● 使用Mono框架和C#实现底层强化以优选化内存使用，避免垃圾回收。
● 了解项目组织的很好实践，通过改进工作流来节省时间。</p>]<p><h2>作者简介</h2></p>[<p>Chris Dickinson在英格兰一个安静的小角落里长大，对数学、科学，尤其是电子游戏满怀热情。他喜欢玩游戏并剖析游戏的玩法，并试图确定它们是如何工作的。Chris在获得电子物理学的硕士学位后，他飞到美国加州，在硅谷中心的科学研究领域工作。不久后，他不得不承认，研究工作并不适合他的性格。在四处投简历之后，他找到了一份工作，最终让他走上了软件工程的正确道路(据说，这对于物理学毕业生来说并不罕见)。<br/>Chris是IPBX电话系统的自动化工具开发人员，这段时间的工作更适合他的性格。现在，他正在研究复杂的设备链，帮助开发人员修复和改进这些设备，并开发自己的工具。Chris学习了很多关于如何使用大型、复杂、实时、基于事件、用户输入驱动的状态机的知识。在这方面，Chris基本上是自学成才的，他对电子游戏的热情再次高涨，促使他真正弄清楚电子游戏是如何创建的。当他有足够的信心时，他回到学校攻读游戏和模拟编程的学士学位。当他获得学位时，他已经在用C 编写自己的游戏引擎(尽管还很初级)，并在日常工作中经常使用这些技能。然而，如果想创建游戏，应该只是创建游戏，而不是编写游戏引擎。因此，Chris选择了他最喜欢的公开发行的游戏引引擎引擎擎——一个称为Unity3D的优秀小工具——并开始制作一些游戏。Chris Dickinson在英格兰一个安静的小角落里长大，对数学、科学，尤其是电子游戏满怀热情。他喜欢玩游戏并剖析游戏的玩法，并试图确定它们是如何工作的。Chris在获得电子物理学的硕士学位后，他飞到美国加州，在硅谷中心的科学研究领域工作。不久后，他不得不承认，研究工作并不适合他的性格。在四处投简历之后，他找到了一份工作，最终让他走上了软件工程的正确道路(据说，这对于物理学毕业生来说并不罕见)。<br/>Chris是IPBX电话系统的自动化工具开发人员，这段时间的工作更适合他的性格。现在，他正在研究复杂的设备链，帮助开发人员修复和改进这些设备，并开发自己的工具。Chris学习了很多关于如何使用大型、复杂、实时、基于事件、用户输入驱动的状态机的知识。在这方面，Chris基本上是自学成才的，他对电子游戏的热情再次高涨，促使他真正弄清楚电子游戏是如何创建的。当他有足够的信心时，他回到学校攻读游戏和模拟编程的学士学位。当他获得学位时，他已经在用C 编写自己的游戏引擎(尽管还很初级)，并在日常工作中经常使用这些技能。然而，如果想创建游戏，应该只是创建游戏，而不是编写游戏引擎。因此，Chris选择了他最喜欢的公开发行的游戏引引擎引擎擎——一个称为Unity3D的优秀小工具——并开始制作一些游戏。<br/>经过一段时间的独立游戏开发，Chris遗憾地决定，这条特定的职业道路的要求并不适合他，但他在短短几年积累的知识量，以大多数人的标准来看，都令人印象深刻，他喜欢利用这些知识帮助其他开发人员创建作品。从那以后，Chris编写了一本关于游戏物理的教程((Learning Game Physics with Bullet Physics and OpenGL，Packt Publishing)和两本关于Unity性能优化的书籍。他娶了他一生的挚爱Jamie，并开始在加州圣马特奥市的Jaunt公司工作，研究最酷的现代技术，担任测试领域的软件开发工程师(SDET)，这是一家专注于提供VR和AR体验(例如360视频)的虚拟现实/增强现实初创公司。<br/>工作之余，Chris一直抵抗对棋盘游戏的沉迷(特别是《太空堡垒：卡拉狄加与血腥狂怒》)，他痴迷于暴雪的《守望先锋》和《星际争霸2》，专注地盯着Unity最新版本，在纸上勾画出一组关于游戏的构思。
 
<br/>蔡俊鸿，拥有多年游戏开发经验，全程主导多个千万级IP游戏的客户端和服务器开发。擅长服务器和客户端的架构设计以及性能优化、客户端渲染等。目前就职于昆仑万维GameArk，担任技术总监一职。</p>]<p><h2>目录</h2></p>
    第1 章  研究性能问题  11.1  Unity Profiler  21.1.1  启动Profiler  31.1.2  Profiler窗口  71.2  性能分析的*佳方法  151.2.1  验证脚本是否出现  161.2.2  验证脚本次数  161.2.3  验证事件的顺序  171.2.4  *小化正在进行的代码更改  181.2.5  *小化内部影响  181.2.6  *小化外部影响  201.2.7  代码片段的针对性分析  201.3  关于分析的思考  251.3.1  理解Profiler工具  261.3.2  减少干扰  261.3.3  关注问题  271.4  本章小结  27第2 章  脚本策略  292.1  使用*快的方法获取组件  292.2  移除空的回调定义  312.3  缓存组件引用  342.4  共享计算输出  362.5  Update、Coroutines 和InvokeRepeating  362.6  更快的GameObject空引用检查  402.7  避免从GameObject取出字符串属性  402.8  使用合适的数据结构  432.9  避免运行时修改Transform的父节点  442.10  注意缓存Transform的变化  442.11  避免在运行时使用Find()和SendMessage()方法  462.11.1  将引用分配给预先存在的对象  492.11.2  静态类  512.11.3  单例组件  542.11.4  全局消息传递系统  582.12  禁用未使用的脚本和对象  692.12.1  通过可见性禁用对象  702.12.2  通过距离禁用对象  712.13  使用距离平方而不是距离  722.14  *小化反序列化行为  732.14.1  减小序列化对象  732.14.2  异步加载序列化对象  742.14.3  在内存中保存之前加载的序列化对象  742.14.4  将公共数据移入ScriptableObject  742.15  叠加、异步地加载场景  742.16  创建自定义的Update()层  762.17  本章小结  80第3 章  批处理的优势  813.1  Draw Call  823.2  材质和着色器  843.3  Frame Debugger  863.4  动态批处理  883.4.1  顶点属性  893.4.2  网格缩放  913.4.3  动态批处理总结  923.5  静态批处理  933.5.1  Static标记  933.5.2  内存需求  933.5.3  材质引用  943.5.4  静态批处理的警告  943.5.5  静态批处理总结  953.6  本章小结  96第4 章  着手处理艺术资源  974.1  音频  974.1.1  导入音频文件  984.1.2  加载音频文件  984.1.3  编码格式与品质级别  1014.1.4  音频性能增强  1034.2  纹理文件  1064.2.1  纹理压缩格式  1064.2.2  纹理性能增强  1084.3  网格和动画文件  1164.3.1  减少多边形数量  1174.3.2  调整网格压缩  1174.3.3  恰当使用Read-Write Enabled  1184.3.4  考虑烘焙动画  1184.3.5  合并网格  1194.4  Asset Bundle和Resource  1194.5  本章小结  120第5 章  加速物理  1215.1  物理引擎的内部工作情况  1225.1.1  物理和时间  1225.1.2  静态碰撞器和动态碰撞器  1255.1.3  碰撞检测  1265.1.4  碰撞器类型  1275.1.5  碰撞矩阵  1295.1.6  Rigidbody激活和休眠状态  1295.1.7  射线和对象投射  1305.1.8  调试物理  1305.2  物理性能优化  1325.2.1  场景设置  1325.2.2  适当使用静态碰撞器  1345.2.3  恰当使用触发体积  1345.2.4  优化碰撞矩阵  1355.2.5  首选离散碰撞检测  1365.2.6  修改固定更新频率  1375.2.7  调整允许的*大时间步长  1385.2.8  *小化射线发射和边界体积检查  1395.2.9  避免复杂的网格碰撞器  1405.2.10  避免复杂的物理组件  1425.2.11  使物理对象休眠  1435.2.12  修改处理器迭代次数  1445.2.13  优化布娃娃  1455.2.14  确定何时使用物理  1475.3  本章小结  148第6 章  动态图形  1496.1  管线渲染  1506.1.1  GPU前端  1516.1.2  GPU后端  1526.1.3  光照和阴影  1556.1.4  多线程渲染  1596.1.5  低级渲染API  1596.2  性能检测问题  1606.2.1  分析渲染问题  1606.2.2  暴力测试  1626.3  渲染性能的增强  1636.3.1  启用/禁用 GPU Skinning  1636.3.2  降低几何复杂度  1646.3.3  减少曲面细分  1646.3.4  应用GPU实例化  1646.3.5  使用基于网格的LOD  1656.3.6  使用遮挡剔除  1676.3.7  优化粒子系统  1686.3.8  优化Unity UI  1706.3.9  着色器优化  1746.3.10  使用更少的纹理数据  1816.3.11  测试不同的GPU纹理压缩格式  1816.3.12  *小化纹理交换  1826.3.13  VRAM限制  1836.3.14  照明优化  1846.3.15  优化移动设备的渲染性能  1866.4  本章小结  188第7 章  虚拟速度和增强加速度  1897.1  XR开发  1907.1.1  仿真  1917.1.2  用户舒适度  1927.2  性能增强  1947.2.1  物尽其用  1947.2.2  单通道立体渲染和多通道立体渲染  1957.2.3  应用抗锯齿  1967.2.4  首选前向渲染  1977.2.5  VR的图像效果  1977.2.6  背面剔除  1977.2.7  空间化音频  1987.2.8  避免摄像机物理碰撞  1987.2.9  避免欧拉角  1987.2.10  运动约束  1997.2.11  跟上*新发展  1997.3  本章小结  199第8 章  掌握内存管理  2018.1  Mono平台  2028.2  代码编译  2098.3  分析内存  2108.3.1  分析内存消耗  2108.3.2  分析内存效率  2118.4  内存管理性能增强  2128.4.1  垃圾回收策略  2128.4.2  手动JIT编译  2138.4.3  值类型和引用类型  2148.4.4  字符串连接  2218.4.5  装箱(Boxing)  2248.4.6  数据布局的重要性  2268.4.7  Unity API中的数组  2278.4.8  对字典键使用InstanceID  2278.4.9  foreach循环  2288.4.10  协程  2298.4.11  闭包  2298.4.12  .NET库函数  2308.4.13  临时工作缓冲区  2318.4.14  对象池  2318.4.15  预制池  2348.4.16  IL2CPP优化  2498.4.17  WebGL 优化  2498.5  Unity、Mono和IL2CPP的未来  2498.6  本章小结  252第9 章  提示与技巧  2539.1  编辑器热键提示  2549.1.1  GameObject  2549.1.2  Scene 窗口  2549.1.3  数组  2559.1.4  界面  2559.1.5  在编辑器内撰写文档  2569.2  编辑器UI提示  2569.2.1  脚本执行顺序  2569.2.2  编辑器文件  2569.2.3  Inspector 窗口  2589.2.4  Project窗口  2599.2.5  Hierarchy窗口  2609.2.6  Scene 和 Game 窗口  2609.2.7  Play模式  2629.3  脚本提示  2629.3.1  一般情况  2629.3.2  特性  2639.3.3  日志  2649.3.4  有用的链接  2649.4  自定义编辑器脚本和菜单提示  2659.5  外部提示  2669.6  本章小结  268
