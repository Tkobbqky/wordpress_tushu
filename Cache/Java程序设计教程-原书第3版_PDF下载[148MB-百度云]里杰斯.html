Java程序设计教程-原书第3版 PDF下载 里杰斯 百度云 电子书 下载 电子书下载
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711148990
PDF电子书下载不求人，看这篇文章就够了→ http://www.chendianrong.com/pdf#711148990
<p>书名:Java程序设计教程-原书第3版</p><p>作者:里杰斯</p><p>页数:667</p><p>定价:¥119.0</p><p>出版社:机械工业出版社</p><p>出版日期:2015-03-01</p><p>ISBN:9787111489900</p><p><h2>本书特色</h2></p>[<p>
本书采用从基础开始的讲法，先介绍面向过程的程序设计方法，打下牢固的编程基础后，再讲述面向对象的程序设计方法。主要内容包括：程序设计基础、数组、定义类、递归、继承和接口、图形用户接口、排序和查找、集合等，本书在大部分章节都配有练习题，对理解和消化书中的概念极有帮助，适合学生和初学者自学参考。
                                        </p>]<p><h2>目录</h2></p>
	前言 第1章 java编程简介 1.1 计算的基本概念 1.1.1 为什么要编程 1.1.2 硬件和软件 1.1.3 数字王国 1.1.4 程序设计的过程 1.1.5 为什么选择java 1.1.6 java编程环境 1.2 现在开始介绍java 1.2.1 字符串常量 1.2.2system.out.println 1.2.3 转义序列 1.2.4 print和println 1.2.5 标识符和关键字 1.2.6 一个复杂的例子：drawfigures1 1.2.7 注释与程序可读性 1.3 程序中的错误 1.3.1 语法错误 1.3.2 逻辑错误 1.4 过程分解 1.4.1静态方法 1.4.2 控制流程 1.4.3 调用其他方法的方法 1.4.4 运行时错误举例 1.5 案例分析：输出图形 1.5.1 结构化的版本 1.5.2 无冗余的*终版本 1.5.3 执行流程的分析 本章小结 第2章 基本数据类型和确定循环 2.1 数据的基本概念 2.1.1 基本类型 2.1.2 表达式 2.1.3 常值 2.1.4 算术运算符 2.1.5 优先级 2.1.6 类型混用和类型转换 2.2 变量 2.2.1 赋值和声明变量 2.2.2 字符串连接 2.2.3 增量和减量运算符 2.2.4 变量和混合类型 2.3 for循环 2.3.1 跟踪for循环 2.3.2 for循环模式 2.3.3 循环嵌套 2.4 复杂性管理 2.4.1 作用域 2.4.2 伪代码 2.4.3 类常量 2.5 案例分析：输出复杂的图形 2.5.1 问题分解和伪代码 2.5.2 **个结构化版本 2.5.3 增加一个类常量 2.5.4 进一步修改 本章小结 第3章 参数和对象 3.1 参数 3.1.1 参数的机制 3.1.2 参数的限制 3.1.3 多重参数 3.1.4 参数和常量 3.1.5 方法重载 3.2 具有返回值的方法 3.2.1 math类 3.2.2 编写具有返回值的方法 3.3 使用对象 3.3.1 string对象 3.3.2 交互式程序和scanner对象 3.3.3 交互式程序示例 3.4 案例分析：抛物线轨迹 3.4.1 非结构化解决方案 3.4.2 结构化解决方案 本章小结 第3g章 图形（选学） 3g.1 图形简介 3g.1.1 drawingpanel 3g.1.2 绘制线段和图形 3g.1.3 颜色 3g.1.4 循环绘图 3g.1.5 文本和字体 3g.2 图形处理中的过程分解 3g.3 案例分析：金字塔 3g.3.1 非结构的部分解决方案 3g.3.2 绘制金字塔的通用方法 3g.3.3 完全的结构化解决方案 本章小结 第4章 条件执行 4.1 if/else语句 4.1.1 关系运算符 4.1.2 嵌套if/else语句 4.1.3 对象的相等性 4.1.4 构造if/else语句 4.1.5 多重条件测试 4.2 积累式算法 4.2.1 累加和 4.2.2 *小/*大循环 4.2.3 使用if计算累加和 4.2.4 截断错误 4.3 文本处理 4.3.1 char类型 4.3.2 char与int 4.3.3 积累式文本处理算法 4.3.4 system.out.printf 4.4 条件执行的方法 4.4.1 前提条件和后置条件 4.4.2 抛出异常 4.4.3 重温返回值 4.4.4 推敲执行路径 4.5 案例分析：计算健康指数 4.5.1 单人版无结构化解决方案 4.5.2 两人版无结构化解决方案 4.5.3 两人版结构化解决方案 4.5.4 面向过程的程序设计原则 本章小结 第5章 程序逻辑和不确定循环 5.1 while循环 5.1.1 寻找*小约数的循环 5.1.2 随机数字 5.1.3 计算机模拟技术 5.1.4 do/while循环 5.2 篱笆桩算法 5.2.1 哨兵循环 5.2.2 使用if语句处理篱笆桩 5.3 布尔类型 5.3.1 逻辑运算符 5.3.2 短路特性 5.3.3 boolean变量和标志 5.3.4 boolean的禅意 5.3.5 布尔表达式的非运算 5.4 用户错误 5.4.1 初识scanner对象 5.4.2 处理用户错误 5.5 断言和程序逻辑 5.5.1 分析断言 5.5.2 断言举例 5.6 案例分析：猜数字 5.6.1 无提示的初始版本 5.6.2 带有提示的随机版本 5.6.3 健壮的*终版本 本章小结 第6章 文件处理 6.1 读取文件的基本方法 6.1.1 随处可见的数据 6.1.2 文件与文件对象 6.1.3 使用scanner对象读取文件内容 6.2 基于标记的文件处理 6.2.1 文件的结构和处理输入 6.2.2 scanner对象的参数 6.2.3 路径和目录 6.2.4 一个更复杂的输入文件 6.3 基于行的处理 6.4 高级文件处理 6.4.1 使用printstream输出文件内容 6.4.2 保证文件可读 6.5 案例分析：邮政编码查询 本章小结 第7章 数组 7.1 数组的基本概念 7.1.1 创建并遍历数组 7.1.2 访问数组 7.1.3 一个使用数组的完整程序 7.1.4 随机访问 7.1.5 数组与方法 7.1.6 for-each循环 7.1.7 数组初始化 7.1.8 arrays类 7.2 数组遍历算法 7.2.1 打印数组 7.2.2 查询与替换 7.2.3 判断相等性 7.2.4 逆序数组 7.2.5 字符串遍历算法 7.3 引用语义 7.4 高级数组技术 7.4.1 移动数组中的元素 7.4.2 对象数组 7.4.3 命令行参数 7.4.4 嵌套循环算法 7.5 多维数组 7.5.1 规则的二维数组 7.5.2 锯齿状二维数组 7.6 案例分析：本福德定律 7.6.1 计数器 7.6.2 完整的程序 本章小结 第8章 类 8.1 面向对象程序设计的基本概念 8.1.1 类和对象 8.1.2 point对象 8.2 对象的状态与行为 8.2.1 对象的状态：字段 8.2.2 对象的行为：方法 8.2.3 隐含的参数 8.2.4 修改器和访问器 8.2.5 tostring方法 8.3 对象的初始化：构造函数 8.3.1 关键字this 8.3.2 多个构造函数 8.4 封装 8.4.1 私有成员 8.4.2 类的不变式 8.4.3 改变类的内部实现 8.5 案例分析： 设计一个表示股票信息的类 8.5.1 面向对象程序设计讨论 8.5.2 stock类的字段和方法声明 8.5.3 stock类的构造函数和实例方法的实现 本章小结 第9章 继承和接口 9.1 继承的基本概念 9.1.1 程序设计之外的层次结构 9.1.2 扩展类 9.1.3 重写方法 9.2 与父类交互 9.2.1 调用重写的方法 9.2.2 访问继承的字段 9.2.3 调用父类的构造函数 9.2.4 dividendstock类的行为 9.2.5 object类 9.2.6 equals方法 9.2.7 instanceof关键字 9.3 多态性 9.3.1 多态机制 9.3.2 解析继承代码 9.3.3 解析复杂的调用关系 9.4 继承和设计 9.4.1 继承的误用 9.4.2 "是一个"和"有一个"关系 9.4.3 graphics2d类 9.5 接口 9.5.1 形状类的接口 9.5.2 实现接口 9.5.3 接口的优点 9.6 案例分析： 设计一组具有层次关系的金融类 9.6.1 设计类 9.6.2 初步实现 9.6.3 抽象类 本章小结 第10章 arraylist 10.1 arraylist 10.1.1 arraylist的基本操作 10.1.2 arraylist的查找方法 10.1.3 一个完整的arraylist程序 10.1.4 向arraylist添加或删除元素 10.1.5 使用for-each循环访问arraylist 10.1.6 包装类 10.2 comparable接口 10.2.1 自然排序和compareto方法 10.2.2 实现comparable接口 10.3 案例分析：词汇表比较 10.3.1 关于程序执行效率的考虑 10.3.2 版本1：计算词汇量 10.3.3 版本2：计算重叠部分 10.3.4 版本3：完整的程序 本章小结 第11章 java的集合框架 11.1 列表 11.1.1 集合 11.1.2 linkedlist与arraylist 11.1.3 迭代器 11.1.4 抽象数据类型 11.1.5 linkedlist类案例分析：筛法 11.2 数学集合 11.2.1 数学集合的概念 11.2.2 treeset与hashset 11.2.3 数学集合上的运算 11.2.4 set类案例分析：彩票机 11.3 映射 11.3.1 基本映射操作 11.3.2 映射视图（keyset和values） 11.3.3 treemap与hashmap 11.3.4 map类案例分析：字数统计 11.3.5 集合综述 本章小结 第12章 递归 12.1 递归的思想 12.1.1 一个与编程无关的例子 12.1.2 将迭代方法改写为递归方法 12.1.3 递归方法的结构 12.2 一个更好的递归实例 12.3 递归函数和数据 12.3.1 整数的幂运算 12.3.2 求*大公约数 12.3.3 目录爬虫 12.3.4 助手方法 12.4 递归图形 12.5 递归回溯 12.5.1 一个简单的例子：移动路线问题 12.5.2 8皇后问题 12.5.3 数独问题 12.6 案例分析：求解前序表达式 12.6.1 中序、前序、后序表达式 12.6.2 计算前序表达式 12.6.3 完整的程序 本章小结 第13章 查找与排序 13.1 java类库中的查找与排序 13.1.1 二分法查找 13.1.2 排序 13.1.3 洗牌 13.1.4 用比较器来自定义顺序 13.2 程序的复杂度 13.2.1 实验分析 13.2.2 算法的复杂度类型 13.3 查找和排序算法的实现 13.3.1 顺序查找 13.3.2 二分法查找 13.3.3 递归二分法查找 13.3.4 查找对象 13.3.5 选择排序 13.4 案例分析：归并排序算法的实现 13.4.1 分解与合并数组 13.4.2 递归的归并排序 13.4.3 完整的程序 本章小结 第14章 栈与队列 14.1 栈/队列基础 14.1.1 栈的概念 14.1.2 队列的概念 14.2 栈/队列常用操作 14.2.1 栈与队列互换 14.2.2 队列元素求和 14.2.3 栈元素求和 14.3 栈/队列高级操作 14.3.1 删除队列中的元素 14.3.2 比较两个栈 14.4 案例分析：表达式求值 14.4.1 标记分解 14.4.2 求值计算 本章小结 第15章 实现集合类 15.1 简单arrayintlist类 15.1.1 添加数值和打印功能 15.1.2 关于封装的思考 15.1.3 处理列表的中间内容 15.1.4 引入另一个构造函数和常量 15.1.5 前提条件和后置条件 15.2 更完整的arrayintlist类 15.2.1 抛出异常 15.2.2 方便的方法 15.3 高级功能 15.3.1 自动调整列表大小 15.3.2 添加迭代器 15.4 arraylist 类 本章小结 第16章 链表 16.1 链表节点 16.1.1 创建链表 16.1.2 链表基础操作 16.1.3 操作节点 16.1.4 链表遍历 16.2 链表类 16.2.1 简单linkedintlist类 16.2.2 追加新节点 16.2.3 操作中间节点 16.3 复杂的链表操作 16.4 intlist接口 16.5 linkedlist类 16.5.1 链表的变体技术 16.5.2 链表的迭代器 16.5.3 其他代码细节 本章小结 第17章 二叉树 17.1 二叉树基础 17.2 遍历二叉树 17.3 树的常见操作 17.3.1 节点求和 17.3.2 计算树的层数 17.3.3 计算叶子节点数量 17.4 二叉搜索树 17.4.1 二叉搜索树性质 17.4.2 构建二叉搜索树 17.4.3 x = change(x)模式 17.4.4 在树中进行搜索 17.4.5 二叉搜索树的复杂性 17.5 searchtree类 本章小结 第18章 高级数据结构 18.1 散列技术 18.1.1 利用数组实现数学集合 18.1.2 散列函数和散列表 18.1.3 冲突 18.1.4 再散列 18.1.5 非整型数据的散列处理 18.1.6 hashmap的实现 18.2 优先级队列和堆 18.2.1 优先级队列 18.2.2 堆的概述 18.2.3 从堆中删除元素 18.2.4 向堆添加元素 18.2.5 利用数组实现堆 18.2.6 堆排序 本章小结 附录a java总结 附录b java api规范和javadoc注释 附录c java 语法补充说明 索引
